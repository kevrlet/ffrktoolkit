define("scenes/battle/Conf", [], function() {
    return FF.ns.battle.Conf = {
        RECOMPILE: {
            VER: 10
        },
        ANIMATION_TYPE: {
            NORMAL: 1,
            BARRAGE: 3,
            DROP_ITEM: 5,
            DAMAGE: 7,
            DEAD: 8,
            DEFORM: 9,
            APPEARANCE: 11,
            TRANSITION: 12,
            JUMP_OUT: 13,
            JUMP_IN: 14,
            DEFORM_ATTACK: 15,
            ENEMY_JUMP: 16,
            INVALIDITY: 17,
            DEFORM_BARRAGE: 18,
            RERAISE_RISE: 19
        },
        WEAPON_EQUIP_TYPE: {
            RIGHT: 1,
            LEFT: 2,
            BOTH: 3,
            FREE: 4
        },
        ABILITY_LAUNCH_TYPE: {
            NORMAL: 1,
            BUDDY_ONLY: 2,
            ONCE: 3,
            NONE: 99
        },
        ABILITY_SHOT_TYPE: {
            NORMAL: 1,
            ATTRACT: 2,
            BACKWARD: 3,
            FORWARD: 4,
            NORMAL_ONCE: 11,
            ATTRACT_ONCE: 21,
            BACKWARD_ONCE: 31,
            FORWARD_ONCE: 41,
            NONE: 99
        },
        ABILITY_HIT_TYPE: {
            NORMAL: 1,
            MULTI_HIT: 2,
            MULTI_HIT_FAST: 3
        },
        ABILITY_RETURN_TYPE: {
            NORMAL: 1,
            ATTRACT: 2,
            BACKWARD: 3,
            FORWARD: 4,
            NONE: 99
        },
        DROP_ITEM_TYPE: {
            GIL: 11,
            POTION: 21,
            HI_POTION: 22,
            X_POTION: 23,
            ETHER: 31,
            TURBO_ETHER: 32,
            TREASURE: 41,
            ORB: 51,
            EVENT_ITEM: 61
        },
        SCORE_TYPE: {
            ACTION_NUM: 1001,
            DAMAGED_RATE: 1002,
            DROP_NUM: 1003,
            DEFEAT_NUM: 1004,
            ENEMY_ABILITY: 2003,
            ENEMY_ABILITY_TIMING: 2004,
            NOT_ENEMY_ABILITY: 2006,
            NOT_ENEMY_ABILITY_TIMING: 2007,
            DAMAGE_REDUCED: 2009,
            WITHOUT_SPECIAL_EQUIPMENT: 2019,
            DEFEAT_BEFORE_ABILITY: 2021,
            DEFEAT_BEFORE_LOOKING: 2022,
            SUCCESS_ENEMY_ABILITY: 2023,
            SUCCESS_ENEMY_ABILITY_TIMING: 2024,
            SUCCESS_STATUS_AILMENTS: 2025,
            SUCCESS_STATUS_AILMENTS_TIMING: 2026,
            SUCCESS_ENEMY_EXERCISE: 2027,
            SUCCESS_ENEMY_EXERCISE_TIMING: 2028,
            NOT_ENEMY_EXERCISE: 2029,
            NOT_ENEMY_EXERCISE_TIMING: 2030,
            NOT_DEFEAT: 2031,
            SUCCESS_ENEMY_DAMAGED_BY_ENEMY: 2032,
            SUCCESS_ENEMY_ABILITY_BY_ENEMY: 2033,
            SUCCESS_STATUS_AILMENTS_BY_ENEMY: 2034,
            HAS_BUDDY: 2035,
            NOT_DEFEAT_IN_ROUND: 2036,
            SUCCESS_ENEMY_JUMP_TIMING: 2037,
            DEFEAT_ENEMY_NUM: 2038
        },
        ACTOR_LOOKING_DEFAULT: 1,
        STATUS_AILMENTS_TYPE: {
            POISON: 200,
            SILENCE: 201,
            PARALYSIS: 202,
            CONFUSION: 203,
            HASTE: 204,
            SLOW: 205,
            STOP: 206,
            PROTECT: 207,
            SHELL: 208,
            REFLECTION: 209,
            BLINDED: 210,
            SLEEP: 211,
            PETRIFACTION: 212,
            DOOM: 213,
            INSTANT_DEATH: 214,
            BERSERKER: 215,
            REGEN: 216,
            LEVITATE: 218,
            WEAKENED: 219,
            ZOMBIE: 220,
            MINIMUM: 221,
            TOAD: 222,
            CURSE: 223,
            GRADUAL_PETRIFACTION: 224,
            BLINK: 225,
            WATER_IMP: 226,
            VANISH: 227,
            PORKY: 228,
            SAP: 229,
            PYRAMID: 231,
            PRISON_CAGE: 232,
            WATER_BALL: 233,
            POSSESSION: 234,
            STOCK_BREAK: 235,
            DOOM_30: 236,
            DOOM_45: 237,
            DOOM_90: 238,
            DOOM_120: 239,
            TRIPLE: 240,
            SWALLOWED: 241,
            STAN: 242,
            REGEN_STRONG: 243,
            ARM_CATCH: 244,
            REFLECTION_FULL_TIME: 245,
            MAGICAL_MINE: 246,
            REGEN_MIDDLE: 247,
            CHANGE_CAST_TIME: 248,
            RERAISE_40: 249,
            RERAISE_60: 250,
            RERAISE_80: 251,
            RERAISE_100: 252,
            RERAISE_DEATH: 253,
            MATK_BOOSTER: 501,
            PROVOKE: 502,
            CHARGE: 503,
            INVISIBLE: 505,
            DEFENSE: 506,
            DISABLE: 507,
            COUNTER_AIMING: 508,
            RUNIC: 509,
            AIRFORCE_SPECK: 510,
            FORCE_ESCAPE: 511,
            BASIC_MAGIC_BREAKER: 512,
            RAID: 513,
            LOCK_ON: 514,
            OVER_DRIVE: 515,
            ROAR: 516,
            MAGIC_SEAL: 517,
            MIRAGE_1: 518,
            MIRAGE_2: 519,
            MIRAGE_3: 520,
            NON_DAMAGE: 521,
            CHARM: 522,
            MIGHTY_GUARD_1: 523,
            SUCTION: 524,
            FURY: 525,
            INDOMITABLENESS: 526,
            MAGIC_CHARM: 527,
            CUSTOM_MATK_20_MDEF_50: 528,
            RAGE: 529,
            GRAND_CROSS: 531,
            TRANCE: 532,
            CUSTOM_MATK: 601,
            CUSTOM_MND: 602,
            CUSTOM_ATK: 603,
            CUSTOM_DEF: 604,
            CUSTOM_ATK_ACC: 605,
            CUSTOM_EVA: 606,
            CUSTOM_MDEF: 607,
            CUSTOM_DEF_MDEF: 608,
            CUSTOM_ATK_MATK_DEF_MDEF: 609,
            CUSTOM_ATK_MATK: 610,
            CUSTOM_ATK_DEF: 611,
            CUSTOM_ATK_MATK_DEF_MDEF_SPD_ACC_MND: 612,
            CUSTOM_SPD: 613,
            INVINCIBLE: 701,
            NULL_PHYSICAL: 702,
            NULL_MAGIC: 703,
            FARAWAY: 704,
            NULL_BASIC_MAGIC: 705,
            ATTACH_ELEMENT_LIGHTNING_WEAK: 801,
            ATTACH_ELEMENT_LIGHTNING_MIDDLE: 802,
            ATTACH_ELEMENT_LIGHTNING_STRONG: 803,
            ATTACH_ELEMENT_FIRE_WEAK: 804,
            ATTACH_ELEMENT_FIRE_MIDDLE: 805,
            ATTACH_ELEMENT_FIRE_STRONG: 806,
            IGNORE_INCONTROLLABLE: 901,
            DEATH: 999
        },
        STATUS_AILMENTS_EXCLUSIVE: {
            TOGETHER: 1,
            BLOCK: 2,
            EXTRUDE: 3
        },
        ACTION_ID_OF: {
            DEFORM: 9001,
            POISON: 9002,
            REGEN: 9003,
            DO_NOTHING: 9004,
            DEFORM_MULTI: 9005,
            DEFENSE: 911,
            HEAL_DEATH: 9006,
            SELF_CUSTOM_PARAM: 9007,
            INCREASE_MP: 9008,
            BUILTIN_INFLICT_SA: 9009,
            RERAISE_RISE: 9010
        },
        ABILITY_ID_OF: {
            DEFORM: 900101,
            POISON: 900201,
            REGEN: 900301,
            DO_NOTHING: 900401,
            DEFORM_MULTI: 900501,
            DEFENSE: 390001,
            ATTACK: 30151001,
            HEAL_DEATH: 900601,
            SELF_CUSTOM_PARAM: 900701,
            INCREASE_MP: 900801,
            BUILTIN_INFLICT_SA: 900901,
            RERAISE_RISE: 901001
        },
        MATERIA_NOTIFY_TYPE: {
            SETUP_ROUND: 1,
            RESET_FOR_CONTINUE: 2,
            DAMAGE_HOOK: 3,
            ABILITY_PANEL: 4,
            ACTION_EXIT: 5
        },
        ELEMENT_TYPE: {
            NONE: 0,
            FIRE: 100,
            ICE: 101,
            LIGHTNING: 102,
            EARTH: 103,
            WIND: 104,
            WATER: 105,
            HOLY: 106,
            DARK: 107,
            POISON: 108,
            NOTHING: 199
        },
        ADVANTAGE: {
            NONE: 0,
            WEAK: 1,
            HALF: 2,
            VOID: 3,
            ABSORPTION: 4
        },
        TARGET_RANGE: {
            SINGLE: 1,
            ALL: 2,
            SELF: 3
        },
        TARGET_SEGMENT: {
            OPPONENT: 1,
            COLLEAGUE: 2,
            BOTH: 3,
            BOTH_EXCEPT_MYSELF: 4,
            COLLEAGUE_EXCEPT_MYSELF: 5
        },
        TARGET_DEATH: {
            EXCLUDE: 1,
            INCLUDE: 2,
            EXCLUDE_PURE_DEATH: 3
        },
        TARGET_METHOD: {
            HP_RATIO_DESC: 1,
            HP_RATIO_ASC: 2,
            SA_RANDOM: 3,
            DIS_SA_RANDOM: 4,
            RANDOM: 5,
            NOTHING: 6,
            HP_DESC: 7,
            HP_ASC: 8,
            ESNA: 9,
            DISPEL: 10
        },
        ACTIVE_TARGET_METHOD: {
            BOTH_DISABLE: 1,
            OPPONENT_DISABLE: 2,
            COLLEGUE_DISABLE: 3,
            BOTH_ENABLE: 4
        },
        ROW_TYPE: {
            FRONT: 1,
            BACK: 2
        },
        ATK_TYPE: {
            DIRECT: 1,
            INDIRECT: 2
        },
        MESSAGE_TYPE: {
            ACTOR_APPEARED: 1,
            ACTOR_DEAD: 2,
            ACTOR_ABILITY: 3,
            ACTOR_HP_DECREASED: 4,
            ACTOR_LOOKING_CHANGED: 5,
            MESSAGE: 6,
            PROGRAM: 7
        },
        MESSAGE_DISPLAY_TYPE: {
            ONCE: 1,
            REPEAT: 2
        },
        EXERCISE_TYPE: {
            PHYSICAL: 1,
            WHITE_MAGIC: 3,
            BLACK_MAGIC: 4,
            BLUE_MAGIC: 5,
            SUMMON: 6,
            INBORN: 7,
            NINJA: 8,
            NO_CLASSIFIED: 9
        },
        JUDGE: {
            VICTORY: 1,
            LOSE: 2,
            FORCE_ESCAPE: 3
        },
        PANEL_TYPE: {
            COMMAND: 1,
            SUPPORT: 2,
            DEFENSE: 3
        },
        BACKGROUND_CHANGE_TYPE: {
            NONE: 0,
            WALK: 1,
            STOP: 2
        },
        TRANSITION_TYPE: {
            SCROLL: 1,
            NONE: 2
        },
        CONTINUE_TYPE: {
            SOUL_PIECE: 101,
            COIN: 201
        },
        CONTINUE_TXN_STAT: {
            STARTED: 1,
            CURED: 2,
            DONE: 3,
            CANCELED: 4,
            SELECTED: 5
        },
        CONTINUE_BONUS: {
            ATTACK: 11,
            DEFENSE: 12,
            ABILITY: 13,
            HP: 14
        },
        MATERIA_CONDTION_TYPE: {
            ALL: 1,
            ELEMENT: 2,
            EXERCISE: 3,
            ABILITY_ID: 4,
            FLIGHT: 5
        },
        COUNTER_CONDTION_TYPE: {
            ALL: 1,
            ELEMENT: 2,
            EXERCISE: 3,
            CUSTOM: 4
        },
        COUNTER_CONDTION_CUSTOM_TYPE: {
            BLACK_AND_WHITE_MAGIC_ATTACK: 1,
            SKIP_IN_REFLECTION: 2,
            COUNTER_AIMING: 3
        },
        RECEPTOR: {
            PANEL_ATTACK: 11,
            PANEL_FLEXIBLE_1: 12,
            PANEL_FLEXIBLE_2: 13,
            PANEL_DEFENSE: 14,
            SOUL_STRIKE: 21,
            SOUL_STRIKE_FLEXIBLE_1: 22,
            SOUL_STRIKE_FLEXIBLE_2: 23,
            SOUL_STRIKE_FLEXIBLE_3: 24,
            SOUL_STRIKE_FLEXIBLE_4: 25,
            SKIP: 31,
            SUPPORTER_SOUL_STRIKE: 41,
            POSITIVE_INCONTROLLABLE: 51,
            SPARE_PANEL_TRANCE_CLOUD_1: 10011,
            SPARE_PANEL_TRANCE_CLOUD_2: 10012,
            SPARE_PANEL_TRANCE_TINA_1: 10021,
            SPARE_PANEL_TRANCE_TINA_2: 10022
        },
        PANEL_TARGET_RECEPTABLE: {
            ENABLE: 1,
            DISABLE: 2,
            ANY: 3
        },
        PANEL_TARGET_REMAIN_NUM: {
            EXISTS: 1,
            EMPTY: 2,
            ANY: 3
        },
        PANEL_TARGET_USED_NUM: {
            USED: 1,
            NOT_USED: 2,
            ANY: 3
        },
        CALC_TYPE: {
            ATTACK: 1,
            MAGIC: 2,
            FRACTION: 3,
            HEAL: 4,
            HEAL_SA: 5,
            HEAL_DEATH: 6,
            POISON: 7,
            REGEN: 8,
            HP_BARTER: 9,
            STATUS_AILMENTS: 10,
            SELF_DESTRUCTION: 11,
            ENTRUSTING_SS_POINT: 12,
            ABILITY_PANEL: 13,
            DAMAGED_HP: 14,
            FIXED_DAMAGE: 15,
            PHYSICAL_STATUS_AILMENTS: 16,
            FRACTION_HEAL: 17
        },
        CALC_HOOK: {
            REFRECTOR: 101,
            COUNTER_ENABLE: 102,
            MATERIA: 103,
            RECEIVER_SA: 104,
            BRK_DEF: 105,
            FLIGHT_ATTACK: 106,
            UNDEAD_CURE: 201,
            UNDEAD_RAISE: 202,
            SEALING: 203,
            PYRAMID: 204,
            FARAWAY: 205,
            WATER_BALL: 206,
            NON_DAMAGE: 207,
            SWALLOWED: 208,
            FURY: 209,
            INDOMITABLENESS: 210,
            IGNORE_GENERAL_DAMAGED_RATE_SCORE: 211,
            INVINCIBLE: 212
        },
        PARAM_CONVERT_TYPE: {
            NONE: 0,
            DEF_CONVERT_ATK: 1,
            SPD_CONVERT_ATK: 2,
            VALIANT_ATTACK: 3
        },
        BREED_ID: {
            UNDEAD: 1
        },
        STATUS_AILMENTS_BUNDLE: {
            LOT: 1,
            ESNA: 2,
            DISPEL: 3,
            DEBARIA: 4,
            POISON_AND_PARALYSIS: 5,
            PHOTON_WING: 6,
            POISON_AND_BLINDED: 7,
            SILENCE_AND_STAN: 8,
            SERAPHIC_RAY: 9,
            BLINDED_AND_SILENCE: 10,
            CONFUSION_AND_SLEEP: 11,
            POISON_AND_SILENCE_AND_BLINDED_AND_SLOW: 12,
            PROTECT_AND_SHELL_AND_HASTE: 13
        },
        STATUS_BONUS_PARTS: {
            BUDDY: "buddy",
            WEAPON: "weapon",
            ARMOR: "armor",
            ACCESSORY: "accessory"
        },
        BGM_NAME: {
            VICTORY: "bgm_05_008",
            REQUIEM: "bgm_05_009"
        },
        SYSTEM_WINDOW: {
            NETWORK: 101,
            ERROR: 102,
            LOGIN: 103,
            BATTLE_RESULT: 104,
            EXPIRE: 105,
            CONFIRM_CONTINUE: 106,
            MAINTENANCE: 107,
            ESCAPE_ALERT: 108,
            OAUTH_TOKEN_REVOKED: 109,
            PAYMENT_NETWORK: 110
        },
        DEAD_ANIMATE_TYPE: {
            DEAD: 1,
            BOSS: 2,
            APPARENT_DEAD: 3,
            ESCAPE: 4
        },
        STATUS_BONUS_TYPE: {
            SERIES: 1,
            ROLE: 2
        },
        BRK_DEF_TYPE: {
            ATK: 401,
            DEF: 402,
            MATK: 403,
            MDEF: 404,
            MND: 405,
            SPD: 406
        },
        BUDDY_ID: {
            DESHI: 10000200,
            WARRIOR: 10000300,
            KNIGHT: 10000400,
            RED_MAGE: 10000900,
            BLACK_MAGE: 10001100,
            WHITE_MAGE: 10001400,
            SUMMONER: 10001700,
            MAGIC_KNIGHT: 10002100,
            RANGER: 10002600,
            THIEF: 10002700,
            BARD: 10002800,
            NINJA: 10003e3,
            GLADIATOR: 10003300,
            WOL: 10100100,
            FRIONIEL: 10200100,
            MARIA: 10200200,
            GORDON: 10200600,
            RICHARD: 10200800,
            JOSEF: 10200900,
            LUNETH: 10300100,
            ARC: 10300200,
            REFIA: 10300300,
            DARK_CECIL: 10400100,
            PALADIN_CECIL: 10400200,
            CAIN: 10400300,
            RYDIA: 10400400,
            ROSA: 10400600,
            TELLAH: 10401100,
            EDGE: 10401200,
            FUSOYA: 10401300,
            GOLBEZ: 10401400,
            BUTS: 10500800,
            LENNA: 10500200,
            FARIS: 10500900,
            KRILE: 10501200,
            FREELANCER_BUTS: 10500800,
            EXDEATH: 10501100,
            FREELANCER_KRILE: 10501200,
            TINA: 10600100,
            LOCK: 10600300,
            CELES: 10600400,
            EDGAR: 10600600,
            MASH: 10600700,
            CAYENNE: 10600900,
            STRAGUS: 10601200,
            KEFKA: 10601600,
            CLOUD: 10700100,
            TIFA: 10700300,
            AERITH: 10700400,
            RED_XIII: 10700500,
            SEPHIROTH: 10701e3,
            ZACK: 10700900,
            RENO: 10701200,
            SQUALL: 10800100,
            RINOA: 10800200,
            QUISTIS: 10800300,
            ZELL: 10800400,
            SELPHIE: 10800500,
            IRVINE: 10800600,
            LAGUNA: 10800900,
            GARNET: 10900200,
            VIVI: 10900300,
            TIDUS: 11000100,
            YUNA: 11000200,
            WAKKA: 11000300,
            LULU: 11000400,
            KIMAHRI: 11000500,
            RIKKU: 11000600,
            AURON: 11000700,
            VAAN: 11200100,
            BALFLEAR: 11200200,
            FRAN: 11200300,
            BASCH: 11200400,
            ASHE: 11200500,
            LIGHTNING: 11300100,
            SNOW: 11300200,
            VANILLE: 11300300,
            SAZH: 11300400,
            HOPE: 11300500,
            FANG: 11300600
        },
        SPECIAL_AURA_TYPE: {
            NONE: 0,
            NORMAL: 1,
            HAS_PARAM_BOOSTER: 2
        },
        SERIES_ID: {
            FF1: 101001,
            FF2: 102001,
            FF3: 103001,
            FF4: 104001,
            FF5: 105001,
            FF6: 106001,
            FF7: 107001,
            FF8: 108001,
            FF9: 109001,
            FF10: 110001,
            FF11: 111001,
            FF12: 112001,
            FF13: 113001,
            FF14: 114001
        },
        ENEMY_TARGETING: {
            SET_SA: 1,
            UNSET_SA: 2,
            HEAL_HP: 3
        },
        CAST_TIME_TYPE: {
            NORMAL_1: 101,
            SLOW_1: 201
        }
    }, FF.ns.battle.Conf
}), define("scenes/battle/AbilityFactory", ["./Conf", "underscore"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.ENEMY_TARGETING;
    FF.ns.battle.AbilityFactory = {
        getActionInfo: function(e) {
            var n = t.find(this.actionMap, function(t) {
                return t.actionId === e
            }, this);
            if (!n) throw new Error("actionInfo not found." + e);
            return n
        },
        create: function(e, n, r) {
            var i = FF.ns.battle.AbilityInfoMgr.getInstance(),
                s = i.getById(e),
                o = s.actionId,
                u = this.getActionInfo(o),
                a = FF.ns.battle.action[u.className];
            if (!a) throw new Error("actionInfo not found." + o);
            var f = i.getSaIdsForSetById(e),
                l = i.getSaIdsForUnsetById(e),
                c = i.getIgnoresReflection(e),
                h = {
                    abilityId: e,
                    actionId: o,
                    exerciseType: s.exerciseType,
                    atkStatusAilmentIds: f,
                    healStatusAilmentIds: l,
                    ignoresReflection: c,
                    abilityCategoryId: s.categoryId
                };
            t.extend(h, s.options, r);
            var p = new a(n, h),
                d = s.animationInfo;
            if (d && d.id) p.set("animationInfo", d);
            else if (p.get("dependsWeaponEffect")) {
                var v = n.getEquipWeaponEffectInfo();
                v && p.set("animationInfo", v)
            }
            return p
        },
        actionMap: [{
            actionId: 1,
            className: "PhysicalAttackAndHpBarterAction"
        }, {
            actionId: 2,
            className: "JumpAction"
        }, {
            actionId: 3,
            className: "PhysicalAttackAction"
        }, {
            actionId: 4,
            className: "PhysicalAttackAndAbsorbHpAction"
        }, {
            actionId: 5,
            className: "MagicAttackAction"
        }, {
            actionId: 6,
            className: "PhysicalAttackHitAction"
        }, {
            actionId: 7,
            className: "PhysicalAttackMultiAction"
        }, {
            actionId: 8,
            className: "HealSaMultiAction",
            ignoresReflectionArg: 2,
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [1]
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 10,
            className: "HealSaLotAction",
            isHeal: !0
        }, {
            actionId: 11,
            className: "HealDeathAction",
            isHeal: !0
        }, {
            actionId: 12,
            className: "HealHpAction",
            ignoresReflectionArg: 4,
            isHeal: !0,
            enemyTargeting: [r.HEAL_HP]
        }, {
            actionId: 13,
            className: "HealSaAction",
            isHeal: !0,
            unsetSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 14,
            className: "InflictSaAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [1, 2, 3, 4, 5],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 15,
            className: "InflictSaHitAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [1, 2, 3, 4, 5],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 16,
            className: "MagicAttackMultiAction",
            ignoresReflectionArg: 6
        }, {
            actionId: 17,
            className: "FractionalAttackByHpAction"
        }, {
            actionId: 19,
            className: "SelfDestructAction"
        }, {
            actionId: 20,
            className: "LvInflictSaAction"
        }, {
            actionId: 23,
            className: "LotAction"
        }, {
            actionId: 25,
            className: "ParamBoosterAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 27,
            className: "PhysicalAttackCriticalOrMissAction"
        }, {
            actionId: 28,
            className: "PhysicalAttackAndCustomParamAction"
        }, {
            actionId: 29,
            className: "FractionalAttackByMaxHpAction"
        }, {
            actionId: 30,
            className: "PhysicalAttackAndDefIgnoredAction"
        }, {
            actionId: 31,
            className: "MagicAttackAndDefIgnoredAction"
        }, {
            actionId: 32,
            className: "MagicAttackAndDeformAction"
        }, {
            actionId: 33,
            className: "CustomParamAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 34,
            className: "EnemyJumpAction"
        }, {
            actionId: 35,
            className: "PhysicalAttackElementAction"
        }, {
            actionId: 36,
            className: "MagicAttackAndAbsorbHpAction"
        }, {
            actionId: 37,
            className: "DamagedHpAttackAction"
        }, {
            actionId: 38,
            className: "EntrustSsPointAction"
        }, {
            actionId: 39,
            className: "CustomParamAndSelfDestructAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 40,
            className: "ReduceMpAction"
        }, {
            actionId: 41,
            className: "FixedDamageAction"
        }, {
            actionId: 42,
            className: "PhysicalAttackWithoutAimingBySaAction"
        }, {
            actionId: 43,
            className: "MagicAttackAndCustomParamAction"
        }, {
            actionId: 44,
            className: "FixedHpAction"
        }, {
            actionId: 45,
            className: "FractionalAttackByHpWithoutSaAction"
        }, {
            actionId: 46,
            className: "MagicAttackAndHealDeathAction"
        }, {
            actionId: 47,
            className: "PhysicalAttackWithHealSaAction"
        }, {
            actionId: 48,
            className: "PhysicalAttackWithMultiSaAction"
        }, {
            actionId: 49,
            className: "PhysicalAttackAndSelfCustomParamAction"
        }, {
            actionId: 50,
            className: "InflictSaAndFallbackMagicAttackAction"
        }, {
            actionId: 51,
            className: "InflictSaHitAndDeformAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [1, 2, 3, 4],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 52,
            className: "ShowAbilityEffectAction"
        }, {
            actionId: 53,
            className: "PhysicalAttackMultiAndDeformAction"
        }, {
            actionId: 54,
            className: "HealHpAndCustomParamAction",
            enemyTargeting: [r.HEAL_HP]
        }, {
            actionId: 55,
            className: "PhysicalAttackAndDeformAction"
        }, {
            actionId: 56,
            className: "FractionalAttackByHpWithoutSaAndInflictSaAction"
        }, {
            actionId: 58,
            className: "PhysicalAttackElementAndCustomParamAction"
        }, {
            actionId: 59,
            className: "HealAndInflictSaAction",
            ignoresReflectionArg: 5,
            setSa: {
                useStatusAilmentsId: !1,
                args: [2],
                bundleArgs: []
            },
            unsetSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 60,
            className: "IncreaseMpAction"
        }, {
            actionId: 61,
            className: "PhysicalDamagedHpAttackAction"
        }, {
            actionId: 63,
            className: "PhysicalAttackMultiWithMultiParamsAction"
        }, {
            actionId: 64,
            className: "HealHpAndInflictSaAction"
        }, {
            actionId: 65,
            className: "PhysicalCustomParamBidirectionallyAction"
        }, {
            actionId: 66,
            className: "PhysicalInflictSaBidirectionallyAction"
        }, {
            actionId: 67,
            className: "MagicAttackAndHealHpAction"
        }, {
            actionId: 68,
            className: "MagicAttackAndSelfCustomParamAction"
        }, {
            actionId: 69,
            className: "PhysicalAttackAndSelfSaAction"
        }, {
            actionId: 70,
            className: "FixedDamageMultiAction"
        }, {
            actionId: 71,
            className: "FixedHpAndDeformAction"
        }, {
            actionId: 72,
            className: "MagicAttackAndPhysicalAttackElementAction"
        }, {
            actionId: 73,
            className: "PhysicalAttackAndPartyCustomParamAction"
        }, {
            actionId: 74,
            className: "PhysicalAttackMultiAndCustomParamAction"
        }, {
            actionId: 76,
            className: "PhysicalAttackAndHealHpAction"
        }, {
            actionId: 77,
            className: "CustomParamMultiAndInflictSaMultiAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [8, 9, 10],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 78,
            className: "RageAction"
        }, {
            actionId: 79,
            className: "InflictSaAndCustomProbabilityDeformAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [1, 3, 5, 7, 9],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 80,
            className: "PhysicalAttackAndInflictSaAndSelfSaAction"
        }, {
            actionId: 81,
            className: "ShowAbilityEffectDeformAction"
        }, {
            actionId: 82,
            className: "CustomParamMultiAction"
        }, {
            actionId: 83,
            className: "PhysicalAttackElementMultiAndSelfCustomParamAction"
        }, {
            actionId: 84,
            className: "AttachElementAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [1],
                bundleArgs: []
            }
        }, {
            actionId: 85,
            className: "PhysicalAttackWithMultiHealSaAction",
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [4, 5, 6, 7, 8],
                bundleArgs: []
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 86,
            className: "HealHpAndHealSaMultiAction",
            isHeal: !0,
            ignoresReflectionArg: 4,
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [6, 7, 8],
                bundleArgs: [5]
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 87,
            className: "HealHpAndHealDeathAction",
            isHeal: !0
        }, {
            actionId: 88,
            className: "MagicAttackMultiAndSelfSaAction"
        }, {
            actionId: 89,
            className: "PhysicalAttackElementMultiAndPartyCustomParamAction"
        }, {
            actionId: 90,
            className: "HealHpAndHealSaAction",
            isHeal: !0,
            ignoresReflectionArg: 4,
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [6, 7, 8],
                bundleArgs: [5]
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 91,
            className: "PhysicalAttackMultiAndCustomParamAndSelfCustomParamAction"
        }, {
            actionId: 92,
            className: "MagicAttackMultiAndPartyCustomParamAction"
        }, {
            actionId: 93,
            className: "SelfDestructAndDeformAction"
        }, {
            actionId: 94,
            className: "ChangeCastTimeAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            }
        }, {
            actionId: 95,
            className: "MagicAttackAndInflictSaMultiAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [5, 6, 7, 8, 9],
                bundleArgs: [4]
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 96,
            className: "FractionalHealByHpAction",
            isHeal: !0,
            enemyTargeting: [r.HEAL_HP]
        }, {
            actionId: 97,
            className: "MagicAttackAndAbsorbHpAndDeformAction"
        }, {
            actionId: 98,
            className: "HealSaMultiAndDeformAction",
            ignoresReflectionArg: 2,
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [1]
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 99,
            className: "PhysicalAttackMultiAndInflictSaAndCustomParamAction"
        }, {
            actionId: 100,
            className: "PhysicalAttackMultiAndHealSaMultiAction",
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [7]
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 101,
            className: "PhysicalAttackMultiWithMultiSaAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [7]
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 102,
            className: "MagicAttackMultiWithMultiSaAction",
            ignoresReflectionArg: 6,
            setSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [7]
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 103,
            className: "PhysicalAttackMultiAndSelfSaAction"
        }, {
            actionId: 104,
            className: "MagicAttackAndDefIgnoredAndDeformAction"
        }, {
            actionId: 105,
            className: "MagicAttackMultiAndInflictSaMultiAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            }
        }, {
            actionId: 106,
            className: "MagicAttackAndDefBoostIgnoredAction"
        }, {
            actionId: 107,
            className: "PhysicalAttackMultiAndSelfSaMultiAction"
        }, {
            actionId: 108,
            className: "PhysicalAttackElementMultiAndSelfSaAndSelfCustomParamAction"
        }, {
            actionId: 109,
            className: "TranceAction"
        }, {
            actionId: 110,
            className: "InflictSaAndIncreaseMpAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [5, 6, 7, 8],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 111,
            className: "PhysicalAttackElementMultiAndSelfCustomParamWithEffectAction"
        }, {
            actionId: 113,
            className: "FixedDamageAndDeformAction"
        }, {
            actionId: 114,
            className: "HealHpAndIncreaseMpAction",
            ignoresReflectionArg: 4
        }, {
            actionId: 115,
            className: "PhysicalAttackMultiAndColleagueSaAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [7, 8],
                bundleArgs: []
            }
        }, {
            actionId: 119,
            className: "PhysicalAttackMultiAndSelfAttachElementAction"
        }, {
            actionId: 122,
            className: "PhysicalAttackDependedOnSaAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.POISON,
            className: "SaPoisonAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.REGEN,
            className: "SaRegenAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.DEFORM,
            className: "DeformAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.DEFORM_MULTI,
            className: "DeformMultiAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.DEFENSE,
            className: "DefenseAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.DO_NOTHING,
            className: "DoNothingAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.HEAL_DEATH,
            className: "BuiltinHealDeathAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.SELF_CUSTOM_PARAM,
            className: "BuiltinSelfCustomParamAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.INCREASE_MP,
            className: "BuiltinIncreaseMpAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.BUILTIN_INFLICT_SA,
            className: "BuiltinInflictSaAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.RERAISE_RISE,
            className: "ReraiseRiseAction"
        }]
    }
}), define("scenes/battle/AbilityInfoMgr", ["lib/ClassBase"], function(e) {
    var t = e.extend({
            initialize: function() {
                this._params = {}
            },
            load: function() {
                _.each(arguments, function(e) {
                    _.each(e, function(e) {
                        if (!e.abilityId) return;
                        this._parseParticleJson(e), this._params[e.abilityId] = e
                    }, this)
                }, this), _.each(FF.ns.battle.Config.getInstance().get("BuiltinAbilities"), function(e) {
                    this._params[e.abilityId] = e
                }, this)
            },
            _parseParticleJson: function(e) {
                if (!e && !e.animationInfo) return;
                e.animationInfo.launchParticleJson && (e.animationInfo.launchParticleJson = JSON.parse(e.animationInfo.launchParticleJson)), e.animationInfo.shotParticleJson && (e.animationInfo.shotParticleJson = JSON.parse(e.animationInfo.shotParticleJson)), e.animationInfo.hitParticleJson && (e.animationInfo.hitParticleJson = JSON.parse(e.animationInfo.hitParticleJson))
            },
            getById: function(e) {
                var t = this._params[e];
                if (!t) throw new Error("param not found.id=" + e);
                return t
            },
            isHealHpTypeById: function(e) {
                var t = this.getById(e),
                    n = FF.ns.battle.AbilityFactory.getActionInfo(t.actionId);
                return n.isHeal ? !0 : !1
            },
            getEnemyTargeting: function(e) {
                var t = "enemyTargeting",
                    n = this.getById(e),
                    r = FF.ns.battle.AbilityFactory.getActionInfo(n.actionId),
                    i = r[t];
                return _.isUndefined(i) ? [] : i
            },
            getIgnoresReflection: function(e) {
                var t = "ignoresReflectionArg",
                    n = this.getById(e),
                    r = FF.ns.battle.AbilityFactory.getActionInfo(n.actionId),
                    i = r[t];
                if (_.isUndefined(i)) return !1;
                if (_.isBoolean(i)) return i;
                if (i) {
                    var s = n.options["arg" + i];
                    return !!s
                }
                return !1
            },
            getSaIdsForSetById: function(e) {
                return this._getSaIdsById(e, "setSa")
            },
            getSaIdsForUnsetById: function(e) {
                return this._getSaIdsById(e, "unsetSa")
            },
            _getSaIdsById: function(e, t) {
                var n = this.getById(e),
                    r = FF.ns.battle.AbilityFactory.getActionInfo(n.actionId),
                    i = r[t],
                    s = [];
                if (_.isUndefined(i)) return s;
                var o = i.useStatusAilmentsId;
                o && n.options.statusAilmentsId && (s = _.union(s, [n.options.statusAilmentsId]));
                var u = i.args || [];
                _.each(u, function(e) {
                    var t = n.options["arg" + e];
                    t && (s = _.union(s, [t]))
                }, this);
                var a = i.bundleArgs || [];
                return _.each(a, function(e) {
                    var t = n.options["arg" + e];
                    if (t) {
                        var r = FF.ns.battle.StatusAilmentsConfig.getBundle(t);
                        s = _.union(s, r)
                    }
                }, this), s
            }
        }),
        n = void 0;
    FF.ns.battle.AbilityInfoMgr = {
        getInstance: function() {
            return n || (n = new t), n
        }
    }
}), define("scenes/battle/AbilityMgr", ["lib/ClassBase"], function(e) {
    var t = ["_beforeCounterInterrupters", "_counterInterrupters", "_bossInterrupters", "_statusAilmentsInterrupters", "_suspendedAbility"],
        n = e.extend({
            initialize: function() {
                this.reset()
            },
            reset: function() {
                _.each(t, function(e) {
                    this[e] = []
                }, this)
            },
            pushSuspend: function(e) {
                this._suspendedAbility.push(e)
            },
            shiftSuspend: function() {
                return this._suspendedAbility.shift()
            },
            interruptBoss: function(e) {
                this._bossInterrupters.push(e)
            },
            interruptCounter: function(e) {
                this._counterInterrupters.push(e)
            },
            interruptBeforeCounter: function(e) {
                this._beforeCounterInterrupters.push(e)
            },
            interruptStatusAilments: function(e) {
                this._statusAilmentsInterrupters.push(e)
            },
            shiftInterrupter: function() {
                var e = void 0;
                return e || (e = this._beforeCounterInterrupters.shift()), e || (e = this._counterInterrupters.shift()), e || (e = this._bossInterrupters.shift()), e || (e = this._statusAilmentsInterrupters.shift()), e && (this._isDead(e.executer) || this._isDyingCounter(e) || e.isCanceledInterruptAbility()) ? (e.forceQuit(), this.shiftInterrupter()) : e
            },
            _isDead: function(e) {
                return e.isContainer() ? e.isAllDead() : e.isDead()
            },
            _isDyingCounter: function(e) {
                var t = e.executer;
                return t.isContainer() ? !1 : t.judgeDeath() && !!e.get("isCounter")
            },
            shiftAbility: function() {
                for (var e = 0, t = this._suspendedAbility.length; e < t; e++)
                    if (this._suspendedAbility[e].isResumed()) return this._suspendedAbility.splice(e, 1)[0];
                var n = FF.ns.battle.ActorMgr.getAliveActors(),
                    r = _.filter(n, function(e) {
                        return e.isReadyToExecAbility() && e.canDoAbility()
                    });
                if (r.length <= 0) return;
                r.sort(function(e, t) {
                    return e.getReadyToExecAbilityAt() - t.getReadyToExecAbilityAt()
                });
                if (r[0]) return r[0].getAbility();
                return
            },
            cancelInterruptAbilityOfActor: function(e) {
                _.each(t, function(t) {
                    _.each(this[t], function(t) {
                        t.executer.equals(e) && t.cancelInterruptAbility()
                    }, this)
                }, this)
            }
        }),
        r = void 0;
    FF.ns.battle.AbilityMgr = {
        getInstance: function() {
            return r || (r = new n), r
        }
    }
}), define("scenes/battle/ActiveTarget", ["lib/ClassBase"], function(e) {
    FF.ns.battle.ActiveTarget = e.extend({
        initialize: function() {
            this._attributes = {
                selectedUid: void 0
            }
        },
        resetSelected: function() {
            this.get("selectedUid") && FF.logger.debug("uid:" + this.get("selectedUid") + " ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ"), this.set("selectedUid", null)
        },
        setSelected: function(e) {
            var t = this.get("selectedUid");
            if (t)
                if (t === e) this.set("selectedUid", null);
                else {
                    var n = t;
                    this.set("selectedUid", e)
                } else this.set("selectedUid", e)
        },
        getSelected: function() {
            return this.get("selectedUid")
        }
    })
}), define("lib/EventBase", ["underscore", "backbone"], function(e, t) {
    var n = function() {
        this.initialize.apply(this, arguments)
    };
    return e.extend(n.prototype, {
        initialize: function() {
            this._attributes = {}
        },
        dispose: function() {},
        get: function(e) {
            return this._attributes[e]
        },
        set: function(e, t) {
            this._attributes[e] = t
        },
        has: function(t) {
            return e.has(this._attributes, t)
        }
    }), e.extend(n.prototype, t.Events), n.extend = t.View.extend, n
}), define("scenes/battle/ActorBase", ["util", "lib/EventBase"], function(e, t) {
    var n = FF.ns.battle;
    return FF.ns.battle.ActorBase = t.extend({
        STATE2FUNC: {
            IDLE: {
                entry: "processForStateIdleEntry"
            },
            IN_CAST: {
                entry: "processForStateInCastEntry"
            },
            IN_ACTION: {
                entry: "processForStateInActionEntry",
                exit: "processForStateInActionExit"
            },
            END: {
                entry: "processForStateEndEntry"
            }
        },
        initialize: function(e, r, i) {
            t.prototype.initialize.call(this), _.extend(this._attributes, i), this._id = r, this._uid = e;
            var s = i.params[0];
            this._attributes.paramId = s.id, this._actorParamHolder = new n.ActorParamHolder(this, s), this.set("hp", i.initHp), this.statusAilments = new n.StatusAilments(this), this.counters = new n.Counters(this), this.lastApplyDamageObjectActor = void 0, _.each(i.statusAilments, function(e) {
                this.statusAilments.set(e, this)
            }, this), this.setupNewBattle()
        },
        getCurrentParam: function() {
            var e = this._attributes.paramMap,
                t = this._attributes.paramId,
                n = e[t];
            if (!n) throw new Error("param not found.id=" + t);
            return n
        },
        changeBaseParam: function(e) {
            var t = this.getCurrentParam();
            this.set("paramId", e);
            var n = this.getCurrentParam();
            this._actorParamHolder.changeBaseParam(n), this.trigger("ActorBase::changeBaseParam", this, n, t)
        },
        getBaseParam: function() {
            return this._actorParamHolder.getBaseParam()
        },
        get: function(e, n) {
            var r = this.getParamHolderForRead(n);
            if (r.has(e)) return r.get(e);
            var i = this.getCurrentParam();
            return i[e] ? i[e] : t.prototype.get.call(this, e)
        },
        set: function(n, r, i) {
            i = e.option({
                isAbsolute: !1
            }, i);
            var s = this.get(n),
                o;
            if (this._actorParamHolder.has(n)) {
                if (this._actorParamHolder.isBoostableParam(n)) throw new Error('can not set key "' + n + '"');
                if (_.isObject(r)) throw new Error("ActorBase::set val is Object");
                o = this._actorParamHolder.changeParam(n, r, i.isAbsolute)
            } else o = t.prototype.set.call(this, n, r);
            return this.trigger("ActorBase::set", this, n, r, s), o
        },
        setBoost: function(t, n, r) {
            r = e.option({
                isAbsolute: !1
            }, r);
            var i;
            return this._actorParamHolder.has(t) && (i = this._actorParamHolder.changeParam(t, n, r.isAbsolute)), this.trigger("ActorBase::setBoost", this, t, n), i
        },
        setAttachElementBoost: function(e, t, n, r) {
            var i;
            return this._actorParamHolder.has(e) && (i = this._actorParamHolder.changeAttachElementParam(e, t, n)), this.trigger("ActorBase::setAttachElementBoost", this, e, t, n), i
        },
        resetParam: function(e) {
            this._actorParamHolder.resetParamById(e)
        },
        getParamHolderForRead: function(e) {
            return this._actorParamHolder
        },
        setupNewBattle: function() {
            this.changeState("IDLE"), this.set("elapsedAtbTime", e.randomInt(this.getAtbTime() - 1)), this.set("elapsedCastTime", 0), this._readyToSelectAbilityAt = 0, this._readyToExecAbilityAt = 0, this._currentAbility = null, this._lastAbility = null
        },
        applyDamageObject: function(e) {
            e.healDeath && e.canHit && this.rise(), e.executer ? this.lastApplyDamageObjectActor = e.executer : this.lastApplyDamageObjectActor = void 0;
            if (e.isSsPoint && e.canHit) {
                var t = e.executer.getSoulStrike(),
                    n = e.receiver.getSoulStrike();
                t.addPoint(-1 * e.ssPoint), n.addPoint(e.ssPoint)
            }
            this.counters.evaluate(e);
            if (e.isAbilityPanel) e.abilityPanel.set("remainNum", e.currNum);
            else if (e.damage) {
                var r = this.get("hp");
                this.set("prevHp", r);
                var i = this.applyDamage(e.damage);
                e.actualDamage = r - i, e.executer && e.absorbHp && e.executer.applyDamage(e.absorbHp.damage), e.receiver && e.receiver.isBuddy() && e.receiver.getSoulStrike().addPointAsReceiver(e), this.statusAilments.processForDamaged(e), this.trigger("ActorBase::addDamage", this, e)
            }
            if (e.statusAilments) {
                var s = [];
                _.each(e.statusAilments, function(t) {
                    this.statusAilments.set(t, e.executer, e.statusAilmentsOptions) && s.push(t)
                }, this), e.statusAilments = s, this.trigger("ActorBase::addStatusAilments", this, e)
            }
            e.unsetStatusAilments && (_.each(e.unsetStatusAilments, function(e) {
                this.statusAilments.unset(e)
            }, this), this.trigger("ActorBase::unsetStatusAilments", this, e)), this.trigger("ActorBase::applyDamageObject", this, e)
        },
        applyDamage: function(e) {
            var t = this.get("maxHp"),
                n = this.get("hp") - e;
            return n <= 0 && (n = 0), n > t && (n = t), this.set("hp", n), n
        },
        canHealDeath: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.DEATH) || this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.RERAISE_DEATH)
        },
        judgeDeath: function() {
            return this.get("hp") <= 0 || this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH) || this.statusAilments.judgeDeathByDoom()
        },
        rise: function() {
            this.isInReraiseDeath() ? (this.statusAilments.unset(n.Conf.STATUS_AILMENTS_TYPE.RERAISE_DEATH), this.trigger("ActorBase::reraise::rise", this)) : (this.statusAilments.unset(n.Conf.STATUS_AILMENTS_TYPE.DEATH), this.trigger("ActorBase::rise", this))
        },
        kill: function() {
            this.statusAilments.set(n.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH, this)
        },
        die: function() {
            this.changeState("IDLE");
            var t = n.ActorMgr.getAbilityPanelSelector();
            t && t.equals(this) && n.ActorMgr.clearActiveTarget();
            var r = n.ActorMgr.getActiveTarget();
            r && r.equals(this) && n.ActorMgr.clearActiveTarget(), this.set("hp", 0), this.set("elapsedAtbTime", e.randomInt(this.getAtbTime() - 1)), this.set("elapsedCastTime", 0), this.statusAilments.set(n.Conf.STATUS_AILMENTS_TYPE.DEATH, this), this._readyToSelectAbilityAt = 0, this._readyToExecAbilityAt = 0, this._currentAbility = null, this._lastAbility = null, this.isInReraiseDeath() ? this.trigger("ActorBase::reraise::die", this) : this.trigger("ActorBase::die", this)
        },
        getReadyToSelectAbilityAt: function() {
            return this._readyToSelectAbilityAt
        },
        getReadyToExecAbilityAt: function() {
            return this._readyToExecAbilityAt
        },
        changeState: function(t) {
            var n = this.get("state");
            if (t === n) return;
            this.set("state", t), this._stateChangedAt = e.getTime();
            if (n) {
                var r = this.STATE2FUNC[n].exit;
                r && this[r]()
            }
            var i = this.STATE2FUNC[this.get("state")].entry;
            i && this[i](), this.trigger("ActorBase::changeState", this, t, n)
        },
        update: function() {
            var e = this.STATE2FUNC[this.get("state")].update;
            this[e] && this[e]()
        },
        isHittable: function(e, t) {
            return this.statusAilments.isHittable(e, t)
        },
        canDoAbility: function() {
            return this.statusAilments.canDoAbility()
        },
        canSelectAbility: function() {
            return this.statusAilments.canSelectAbility() && !n.BattleInfo.getInstance().get("isInAutoBattle")
        },
        canUseAllMagic: function() {
            return this.statusAilments.canUseAllMagic()
        },
        getAtbTimeFactor: function() {
            var e = this.statusAilments.getAtbTimeFactor();
            return _.isNumber(e) ? e : 100
        },
        getCastTimeFactor: function() {
            var e = {},
                t = this.getAbility();
            t && (e.abilityCategoryId = t.get("abilityCategoryId"));
            var n = this.statusAilments.getCastTimeFactor(e);
            return _.isNumber(n) ? n : 100
        },
        isReadyToSelectAbility: function() {
            return this.isStateIdle() && this.isAtbFull()
        },
        isReadyToExecAbility: function() {
            return this.isStateInCast() && this.isCastFull()
        },
        getAbility: function() {
            return this._currentAbility
        },
        setAbility: function(e) {
            if (!this.isReadyToSelectAbility()) throw new Error("can not set ability");
            this._currentAbility = e, this.changeState("IN_CAST")
        },
        getLastAbility: function() {
            return this._lastAbility
        },
        reset: function() {
            this.set("elapsedAtbTime", 0), this.set("elapsedCastTime", 0), this._readyToSelectAbilityAt = 0, this._readyToExecAbilityAt = 0, this._currentAbility = null, this.changeState("IDLE")
        },
        resetAtb: function() {
            this.set("elapsedAtbTime", 0)
        },
        resetAbility: function() {
            this._currentAbility = null
        },
        processForStateIdleEntry: function() {
            this.resetAbility(), this.resetAtb(), this._readyToSelectAbilityAt = 0, this._readyToExecAbilityAt = 0
        },
        processForStateInCastEntry: function() {
            this.set("elapsedCastTime", 0), this.statusAilments.processForStateInCastEntry()
        },
        processForStateInActionEntry: function() {
            this.trigger("ActorBase::entryInAction", this), this.statusAilments.processForStateInActionEntry(), this._lastAbility = this._currentAbility
        },
        processForStateInActionExit: function() {
            this.trigger("ActorBase::exitInAction", this), this.statusAilments.processForStateInActionExit()
        },
        notifyAbilityBegun: function(e) {
            this.trigger("ActorBase::notifyAbilityBegun", this, e)
        },
        notifyAbilityDone: function() {
            this.changeState("IDLE")
        },
        setEnd: function() {
            this.changeState("END")
        },
        processForStateEndEntry: function() {
            this.resetAbility()
        },
        notifyAtbFull: function() {
            this._readyToSelectAbilityAt = e.getTime()
        },
        notifyCastFull: function() {
            this._readyToExecAbilityAt = e.getTime()
        },
        getAtbTime: function() {
            var e = this.get("spd"),
                t = n.Config.getInstance().get("ATB", "a"),
                r = n.Config.getInstance().get("ATB", "b");
            return Math.floor(t - e / r)
        },
        getCastTime: function() {
            return this._currentAbility.getCastTime()
        },
        isAtbFull: function() {
            return this.get("elapsedAtbTime") >= this.getAtbTime()
        },
        isCastFull: function() {
            return this.get("elapsedCastTime") >= this.getCastTime()
        },
        isStateIdle: function() {
            return this.get("state") === "IDLE"
        },
        isStateInCast: function() {
            return this.get("state") === "IN_CAST"
        },
        isStateInAction: function() {
            return this.get("state") === "IN_ACTION"
        },
        isStateEnd: function() {
            return this.get("state") === "END"
        },
        getId: function() {
            return this._id
        },
        getUid: function() {
            return this._uid
        },
        isBuddy: function() {
            return !1
        },
        isEnemy: function() {
            return !1
        },
        isColleague: function(e) {
            return this.isBuddy() && e.isBuddy() || this.isEnemy() && e.isEnemy()
        },
        isOpponent: function(e) {
            return !this.isColleague(e)
        },
        isAlive: function(e) {
            return !this.isDead(e)
        },
        isDead: function(e) {
            return this.statusAilments.isDead(e)
        },
        canSubstitute: function(e) {
            var t = this.statusAilments.retrieveSubstituteTypes();
            return _.contains(t, e)
        },
        isInDefense: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.DEFENSE)
        },
        isInReflection: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.REFLECTION) || this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.REFLECTION_FULL_TIME)
        },
        isInConfusion: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.CONFUSION)
        },
        isInSleeping: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.SLEEP)
        },
        isInBerserker: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.BERSERKER)
        },
        isInRage: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.RAGE)
        },
        hasReraise: function() {
            return this.statusAilments.hasReraise()
        },
        isInReraiseDeath: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.RERAISE_DEATH)
        },
        isInProtect: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.PROTECT)
        },
        isInShell: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.SHELL)
        },
        isPositiveIncontrollable: function() {
            return this.isInRage() && !this.shouldIgnoreIncontrollable() ? !0 : !1
        },
        isIncontrollable: function() {
            if (this.isPositiveIncontrollable()) return !0;
            if (this.isInConfusion() || this.isInBerserker())
                if (!this.shouldIgnoreIncontrollable()) return !0;
            return !1
        },
        shouldIgnoreIncontrollable: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.IGNORE_INCONTROLLABLE) ? !0 : !1
        },
        isContainer: function() {
            return !1
        },
        isPossibleToTarget: function() {
            return this.statusAilments.isPossibleToTarget()
        },
        getEquipWeaponEffectInfo: function() {
            var e = n.BattleInfo.getInstance().getActorParam(this.getUid());
            return _.has(e, "weaponEffect") ? e.weaponEffect.animationInfo : void 0
        },
        getCount: function() {
            return this.statusAilments.getCount()
        },
        isBlinded: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.BLINDED)
        },
        isReflected: function() {
            return this.isInReflection()
        },
        isUndeadBreed: function() {
            return this.get("breedId") === n.Conf.BREED_ID.UNDEAD || this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.ZOMBIE)
        },
        isContinuousBattle: function() {
            return this.isAlive() && this.statusAilments.isContinuousBattle()
        },
        isForceEscaped: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.FORCE_ESCAPE)
        },
        isInvisible: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.INVISIBLE)
        },
        isInvincible: function() {
            return this.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.INVINCIBLE)
        },
        getAbilityInfoByPositiveIncontrollable: function() {
            var e = {
                abilityId: 0,
                abilityOptions: {}
            };
            if (!this.isInRage()) throw new Error("not found vaild status ailments");
            return e.abilityId = this.statusAilments.getNextAbilityIdForRage(), e
        },
        getAttributes: function(e) {
            var t = {};
            return _.each(e, function(e) {
                t[e] = this.get(e)
            }, this), t
        },
        equals: function(e) {
            return this.getUid() === e.getUid()
        },
        toPlainObject: function() {
            return {
                attributes: this._attributes,
                statusAilments: this.statusAilments.toPlainObject(),
                actorParamHolder: this._actorParamHolder.toPlainObject(),
                counters: this.counters.toPlainObject()
            }
        },
        applyPlainObject: function(e) {
            _.extend(this._attributes, e.attributes), this.statusAilments.applyPlainObject(e.statusAilments), this._actorParamHolder.applyPlainObject(e.actorParamHolder), this.counters.applyPlainObject(e.counters)
        },
        getRemainingHpRate: function() {
            return Math.floor(this.get("hp") / this.get("maxHp") * 100)
        },
        cancelInterruptAbility: function() {
            n.AbilityMgr.getInstance().cancelInterruptAbilityOfActor(this)
        },
        getAttachElementAddOnFactor: function(e, t) {
            return 100
        },
        setStatusAilments: function(e) {
            e = _.isArray(e) ? e : [e];
            var t = n.util.DamageCalculator.makeDamageObject(this, this, void 0, {
                statusAilments: e
            });
            this.applyDamageObject(t)
        }
    }), FF.ns.battle.ActorBase
}), define("scenes/battle/ActorBuddy", ["./ActorBase", "util"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.ActorBuddy = e.extend({
        initialize: function(r, i, s) {
            e.prototype.initialize.apply(this, arguments), _.extend(this._attributes, t.option({
                posId: void 0,
                no: s.no
            }, s));
            var o = n.BattleInfo.getInstance().getActorParam(this.getUid());
            this.receptors = {}, _.each([{
                "class": "AbilityPanel",
                info: o.abilityPanels
            }, {
                "class": "AbilityPanel",
                info: n.Config.getInstance().get("BuiltinPanels")
            }, {
                "class": "SoulStrike",
                info: _.extend({}, o.soulStrikes[0], {
                    point: o.soulStrikeGauge
                })
            }, {
                "class": "SoulStrikePanel",
                info: o.soulStrikes
            }, {
                "class": "Skip"
            }, {
                "class": "PositiveIncontrollable"
            }], function(e) {
                var t = e.class,
                    r = _.isArray(e.info) ? e.info : [e.info];
                _.each(r, function(e) {
                    (new n.recept[t](this)).load(e)
                }, this)
            }, this), this.sparePanelReceptors = {}, this._setupStatusBonusFlgOf(o), this._setupStatusBonusTypeOf(o), this.set("seriesId", o.seriesIdMap ? o.seriesIdMap.buddy : void 0), this.materiaHolder = n.MateriaFactory.createMateriaHolder(this, s.materias), this._isPossessedBySupporter = !1
        },
        update: function() {
            e.prototype.update.apply(this, arguments), this.materiaHolder.update(), this.isIncontrollable() && this.isReadyToSelectAbility() && (this.isPositiveIncontrollable() ? n.BuddyPartyMgr.getInstance().reserveAbilityForPositiveIncontrollable(this) : n.BuddyPartyMgr.getInstance().reserveAbility(this, n.Conf.RECEPTOR.PANEL_ATTACK)), n.BattleInfo.getInstance().get("isInAutoBattle") && this.isReadyToSelectAbility() && n.BuddyPartyMgr.getInstance().reserveAbilityForAutoBattle(this)
        },
        processForStateInActionEntry: function() {
            e.prototype.processForStateInActionEntry.apply(this, arguments);
            var t = this.getAbility();
            if (t.get("isAbilityPanel")) {
                var r = t.get("receptorId");
                this.getReceptorById(r).decreaseResources()
            } else t.get("isSoulStrike") && this.getSoulStrike().decreaseResources();
            t.get("isSupporterSoulStrike") && (this._isPossessedBySupporter = !0, n.ActorMgr.getSupporter().getSupporterSoulStrike().decreaseResources())
        },
        processForStateInActionExit: function() {
            e.prototype.processForStateInActionExit.apply(this, arguments);
            var t = this.getLastAbility();
            t.get("isAbilityPanel") && this.getSoulStrike().addPointAsExecuter(t), t.get("isSupporterSoulStrike") && (this._isPossessedBySupporter = !1), t.get("isPositiveIncontrollable") && t.get("shouldAddSsPoint") && this.getSoulStrike().addPointAsExecuter(t), this.materiaHolder.notify(n.Conf.MATERIA_NOTIFY_TYPE.ACTION_EXIT, {
                ability: t
            })
        },
        getParamHolderForRead: function(r) {
            return r = t.option({
                usesSelfBaseParam: !1
            }, r), this._isPossessedBySupporter && !r.usesSelfBaseParam ? n.ActorMgr.getSupporter().getParamHolderForRead() : e.prototype.getParamHolderForRead.apply(this, arguments)
        },
        getAbilityPanels: function() {
            var e = [].concat(_.values(this.receptors), _.values(this.sparePanelReceptors));
            return _.filter(e, function(e) {
                return e instanceof n.recept.AbilityPanel ? e.isLocated() ? !0 : !1 : !1
            }, this)
        },
        getAbilityPanelReceptorByPanelNo: function(e) {
            return _.find(this.getAbilityPanels(), function(t) {
                return +t.get("panelNo") === +e
            }, this)
        },
        findSparePanelInfo: function(e) {
            var t = this.getUid();
            this.isPossessedBySupporter() && (t = n.ActorMgr.getSupporter().getUid());
            var r = n.BattleInfo.getInstance().getActorParam(t);
            return _.find(r.sparePanels, function(t) {
                return t.receptorId && +t.receptorId === +e
            })
        },
        _validateSparePanelReceptorId: function(e) {
            if (!_.contains(n.Config.getInstance().get("SparePanelReceptors"), +e)) throw new Error("invalid spare ability panel receptorId. " + e)
        },
        retrieveAndLoadSparePanel: function(e) {
            this._validateSparePanelReceptorId(e);
            var t = this.getReceptorById(e);
            if (t) return t;
            var r = this.findSparePanelInfo(e);
            if (!r) throw new Error("Not found such receptorId." + e);
            return t = new n.recept.AbilityPanel(this), t.load(_.extend({}, r, {
                isSpare: !0
            })), t
        },
        swapSparePanel: function(e, n, r) {
            r = t.option({
                highlight: !1
            }, r), this._validateSparePanelReceptorId(e);
            var i = this.retrieveAndLoadSparePanel(e);
            if (i.isLocated()) throw new Error("already located. receptorId:" + e);
            i.set("highlight", r.highlight);
            var s = this.getAbilityPanelReceptorByPanelNo(n),
                o = void 0;
            return s ? (o = s.get("receptorId"), s.dislocate(), i.locate(n)) : i.locate(n), o
        },
        rewindSparePanel: function(e, t) {
            this._validateSparePanelReceptorId(e);
            var n = this.getReceptorById(e);
            if (!n || !n.isLocated()) throw new Error("cannot rewind spare. receptorId:" + e);
            if (t) {
                var r = this.getReceptorById(t),
                    i = n.get("panelNo");
                r.locate(i)
            }
            n.dislocate()
        },
        getSoulStrikePanels: function() {
            var e = _.values(n.Config.getInstance().get("SoulStrikePanels"));
            return _.pick(this.receptors, e)
        },
        getSoulStrike: function() {
            return this.getReceptorById(n.Conf.RECEPTOR.SOUL_STRIKE)
        },
        getAtkSsPointFactor: function() {
            var e = this.get("atkSsPointFactor"),
                t = this.get("atkSsPointFactorByMateria") || 0;
            return e + t
        },
        getDefSsPointFactor: function() {
            var e = this.get("defSsPointFactor"),
                t = this.get("defSsPointFactorByMateria") || 0;
            return e + t
        },
        getSkip: function() {
            return this.getReceptorById(n.Conf.RECEPTOR.SKIP)
        },
        getPositiveIncontrollable: function() {
            return this.getReceptorById(n.Conf.RECEPTOR.POSITIVE_INCONTROLLABLE)
        },
        isBuddy: function() {
            return !0
        },
        isFatal: function() {
            var e = this.get("maxHp"),
                t = this.get("hp");
            return this.isAlive() && t / e <= .125
        },
        resetForContinue: function() {
            var e = n.BattleInfo.getInstance().getActorParam(this.getUid()),
                t = e.maxHp;
            this.statusAilments = new n.StatusAilments(this), this._actorParamHolder.resetAllParam(), this.set("hp", t), this.set("maxHp", t), this.set("damage", 0), this.setupNewBattle(), _.each(this.getAbilityPanels(), function(e) {
                e.resetForContinue()
            }, this), this.materiaHolder.notify(n.Conf.MATERIA_NOTIFY_TYPE.RESET_FOR_CONTINUE)
        },
        _setupStatusBonusFlgOf: function(e) {
            this._statusBonusFlgOf = {};
            var t = e.statusBonusFlgOf || {};
            _.each(n.Conf.STATUS_BONUS_PARTS, function(e) {
                this._statusBonusFlgOf[e] = !!t[e]
            }, this)
        },
        _setupStatusBonusTypeOf: function(e) {
            this._statusBonusTypeOf = e.statusBonusTypeOf
        },
        getStatusBonusFlgOf: function() {
            return this._statusBonusFlgOf
        },
        getStatusBonusTypeOf: function() {
            return this._statusBonusTypeOf
        },
        getSeriesId: function() {
            return this.get("seriesId")
        },
        isPossessedBySupporter: function() {
            return this._isPossessedBySupporter
        },
        isSameSeries: function(e) {
            return this.getSeriesId() === e
        },
        isInDefense: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInDefense.apply(this, arguments)
        },
        isInReflection: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInReflection.apply(this, arguments)
        },
        isInConfusion: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInConfusion.apply(this, arguments)
        },
        isInSleeping: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInSleeping.apply(this, arguments)
        },
        isInBerserker: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInBerserker.apply(this, arguments)
        },
        isInRage: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInRage.apply(this, arguments)
        },
        hasReraise: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.hasReraise.apply(this, arguments)
        },
        isInReraiseDeath: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInReraiseDeath.apply(this, arguments)
        },
        isBlinded: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isBlinded.apply(this, arguments)
        },
        canSubstitute: function(t) {
            return this.isPossessedBySupporter() ? !1 : e.prototype.canSubstitute.apply(this, arguments)
        },
        canUseAllMagic: function() {
            return this.isPossessedBySupporter() ? !0 : e.prototype.canUseAllMagic.apply(this, arguments)
        },
        getReceptorById: function(e) {
            var t = this.receptors[e];
            return t || (t = this.sparePanelReceptors[e]), t
        },
        toPlainObject: function() {
            var t = e.prototype.toPlainObject.apply(this, arguments);
            return t.receptors = {}, _.each(this.receptors, function(e, n) {
                t.receptors[n] = e.toPlainObject()
            }), t.sparePanelReceptors = {}, _.each(this.sparePanelReceptors, function(e, n) {
                t.sparePanelReceptors[n] = e.toPlainObject()
            }), t.materiaHolder = this.materiaHolder.toPlainObject(), t
        },
        applyPlainObject: function(t) {
            e.prototype.applyPlainObject.apply(this, arguments);
            if (!t) return;
            _.each(this.receptors, function(e, n) {
                e.applyPlainObject(t.receptors[n])
            }), _.each(t.sparePanelReceptors, function(e, t) {
                var r = new n.recept.AbilityPanel(this);
                r.applyPlainObject(e), this.sparePanelReceptors[t] = r
            }, this), this.materiaHolder.applyPlainObject(t.materiaHolder)
        },
        getAttachElementAddOnFactor: function(t, n) {
            var r = 100;
            if (!t) return r;
            var i = n || this.getAbility();
            if (!i) return r;
            if (i.get("isSupporterSoulStrike")) return r;
            var s = this.statusAilments.getRefsOfAttachElementInfoMap();
            return s && s.attachElementId === t ? i.get("isSoulStrike") ? s.soulStrikeDamageFactor : s.normalAbilityDamageFactor : e.prototype.getAttachElementAddOnFactor.apply(this, arguments)
        },
        getSwapAbilityByAttachedElement: function() {
            var e = this.statusAilments.getRefsOfAttachElementInfoMap();
            return e ? e.swapAbilityId : void 0
        }
    })
}), define("scenes/battle/ActorSupporter", ["./ActorBase", "util"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.ActorSupporter = e.extend({
        initialize: function(r, i, s) {
            e.prototype.initialize.apply(this, arguments), _.extend(this._attributes, t.option({}, s));
            var o = n.BattleInfo.getInstance().getActorParam(this.getUid());
            this.receptors = {}, (new n.recept.SupporterSoulStrike(this)).load(_.extend({
                restCount: o.supporterSsGauge
            }, o.soulStrikes[0])), this._setupStatusBonusFlgOf(o), this._setupStatusBonusTypeOf(o)
        },
        isBuddy: function() {
            return !0
        },
        resetForContinue: function() {
            var e = n.BattleInfo.getInstance().getActorParam(this.getUid());
            this.getSupporterSoulStrike().set("restCount", e.maxSupporterSsGauge)
        },
        _setupStatusBonusFlgOf: function(e) {
            this._statusBonusFlgOf = {};
            var t = e.statusBonusFlgOf || {};
            _.each(n.Conf.STATUS_BONUS_PARTS, function(e) {
                this._statusBonusFlgOf[e] = !!t[e]
            }, this)
        },
        _setupStatusBonusTypeOf: function(e) {
            this._statusBonusTypeOf = e.statusBonusTypeOf
        },
        getStatusBonusFlgOf: function() {
            return this._statusBonusFlgOf
        },
        getStatusBonusTypeOf: function() {
            return this._statusBonusTypeOf
        },
        getSupporterSoulStrike: function() {
            return this.receptors[n.Conf.RECEPTOR.SUPPORTER_SOUL_STRIKE]
        },
        toPlainObject: function() {
            var t = e.prototype.toPlainObject.apply(this, arguments);
            return t.receptors = {}, _.each(this.receptors, function(e, n) {
                t.receptors[n] = e.toPlainObject()
            }), t
        },
        applyPlainObject: function(t) {
            e.prototype.applyPlainObject.apply(this, arguments);
            if (!t) return;
            _.each(this.receptors, function(e, n) {
                e.applyPlainObject(t.receptors[n])
            })
        }
    })
}), define("scenes/battle/ActorEnemy", ["util", "./ActorBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.ActorEnemy = t.extend({
        initialize: function(e, r, i) {
            t.prototype.initialize.apply(this, arguments), this._abilityBox = {}, this._abilityBoxFirst = {}, this._atbFullTurnNum = 0, this._abilityUnlockTurnNumInfo = {}, this._abilityTag = {}, _.each(i.params, function(e) {
                var t = [],
                    r = [],
                    i = [],
                    s = [],
                    o = {};
                _.each(e.abilities, function(e) {
                    t.push(e.abilityId), r.push(e.weight), !n.AbilityInfoMgr.getInstance().isHealHpTypeById(e.abilityId) && e.weight > 0 && (i.push(e.abilityId), s.push(e.weight)), o[e.abilityId] = e.unlockTurnNum, e.tag && (this._abilityTag[e.tag] = e.abilityId)
                }, this), this._abilityBox[e.id] = new n.LotteryBox(t, r), i.length && (this._abilityBoxFirst[e.id] = new n.LotteryBox(i, s)), this._abilityUnlockTurnNumInfo[e.id] = o, _.each(e.counters, function(t) {
                    this.counters.addWithParamId(e.id, t.abilityId, t.conditionType, t.conditionValue, t.rate)
                }, this)
            }, this), this._registerAbilityCount = 0, this.stateMap = n.ai.StateMapBuilder.createById(i.aiId, this), this.set("atbTime", i.atbTime), this.materiaHolder = n.MateriaFactory.createMateriaHolder(this, [])
        },
        set: function(e, n) {
            return t.prototype.set.apply(this, arguments)
        },
        update: function() {
            t.prototype.update.apply(this, arguments);
            if (this.isIncontrollable() && this.isReadyToSelectAbility()) {
                if (this.isPositiveIncontrollable()) throw new Error("ActorEnemy cannot use PositiveIncontrollable");
                var e = this.detectAbilityInNegativeIncontrollable();
                n.Commander.getInstance().register(e, this)
            } else this.stateMap.update()
        },
        notifyAtbFull: function() {
            this._atbFullTurnNum++, t.prototype.notifyAtbFull.apply(this, arguments)
        },
        getAtbFullTurnNum: function() {
            return this._atbFullTurnNum
        },
        hasAbilityTag: function(e) {
            var t = this._abilityTag[e];
            return _.isUndefined(t) ? !1 : !0
        },
        getAbilityIdByTag: function(e) {
            var t = this._abilityTag[e];
            if (_.isUndefined(t)) throw new Error("invalid tag [" + e + "]");
            return t
        },
        getCurrentBox: function() {
            return this._abilityBox[this.get("paramId")]
        },
        getCurrentBoxFirst: function() {
            return this._abilityBoxFirst[this.get("paramId")]
        },
        lotAndRegisterAbility: function() {
            var e = this.lotAbility();
            return this.registerAbility(e)
        },
        lotAndRegisterAbilityWithout: function(e) {
            var t = this.lotAbilityWithout(e);
            return this.registerAbility(t)
        },
        withoutAndLotAndRegisterAbility: function(e) {
            var t = this.getWithoutAbilityList(e);
            return this.lotAndRegisterAbilityWithout(t)
        },
        _decideUsingBox: function() {
            var e = this.getCurrentBox(),
                t = this.getCurrentBoxFirst();
            return this._registerAbilityCount <= 0 && t && (e = t), e
        },
        lotAbility: function() {
            return this.lotAbilityWithout([])
        },
        lotAbilityWithout: function(e) {
            var t = this._decideUsingBox(),
                n = this._getLockedAbilityIdList(),
                r = _.union(n, e),
                i = t.lotWithout(r);
            if (!i) throw new Error("invalid box");
            return i
        },
        _getLockedAbilityIdList: function() {
            var e = this._decideUsingBox(),
                t = e._params.lottery,
                n = this.get("paramId"),
                r = this._abilityUnlockTurnNumInfo[n],
                i = this.getAtbFullTurnNum(),
                s = _.filter(t, function(e) {
                    var t = r[e],
                        n = t <= i;
                    return !n
                }, this);
            return s
        },
        registerAbility: function(e, t) {
            return this._registerAbility(e, t)
        },
        registerAbilityByTag: function(e, t) {
            var n = this.getAbilityIdByTag(e);
            return this.registerAbility(n, t)
        },
        registerInterruptAbility: function(e, t, n) {
            return n || (n = {
                interruptBoss: !0
            }), this._registerAbility(e, t, n)
        },
        registerInterruptAbilityByTag: function(e, t, n) {
            var r = this.getAbilityIdByTag(e);
            return this.registerInterruptAbility(r, t, n)
        },
        _registerAbility: function(e, t, r) {
            if (this._getCandidatableAbilityIds().indexOf(e) < 0) throw new Error("invalid abilityId [" + e + "]");
            var i = n.Commander.getInstance().register(e, this, t, r);
            return this._registerAbilityCount++, i
        },
        _getCandidatableAbilityIds: function() {
            var e = FF.ns.battle.Config.getInstance().get("BuiltinAbilities"),
                t = _.map(e, function(e) {
                    return e.abilityId
                }),
                n = [].concat(this.getCurrentBox().getCandidates(), t);
            return n
        },
        resetAbilityBox: function(e) {
            var t = this.getCurrentBox();
            t.resetBox(e)
        },
        isEnemy: function() {
            return !0
        },
        die: function() {
            t.prototype.die.call(this)
        },
        getSize: function() {
            return this.get("size")
        },
        notifyJudgedDeath: function() {
            return this.stateMap.notifyJudgedDeath(this)
        },
        setDeadAnimateType: function(e) {
            this._deadAnimateType = e
        },
        getDeadAnimateType: function() {
            return this._deadAnimateType
        },
        setInvisible: function() {
            this.statusAilments.set(n.Conf.STATUS_AILMENTS_TYPE.INVISIBLE, this)
        },
        getWithoutAbilityList: function(e) {
            var t = this._decideUsingBox(),
                r = t._params.lottery,
                i = n.util.EnemyTargeting.getWithoutAbilityList(this, r, e);
            return i
        },
        detectAbilityInNegativeIncontrollable: function() {
            var e = n.Config.getInstance().get("EnemyAblityTag", "NegativeIncontrollable");
            return this.hasAbilityTag(e) ? this.getAbilityIdByTag(e) : this.getCurrentBox().getCandidates()[0]
        },
        getCastTime: function() {
            var e = n.Config.getInstance().get("EnemyCastTime"),
                r = e[this.get("castTimeType")];
            return _.isNumber(r) ? r : t.prototype.getCastTime.call(this)
        },
        resetCastAbility: function() {
            if (!this.isStateInCast()) return;
            this.reset(), this.set("elapsedAtbTime", this.getAtbTime() - 1)
        }
    })
}), define("scenes/battle/ActorMgr", ["lib/Events", "util"], function(e, t) {
    var n = {},
        r = {},
        i = {},
        s = [],
        o = void 0,
        u = void 0,
        a = 0,
        f = FF.ns.battle;
    FF.ns.battle.ActorMgr = _.extend({
        registerBuddy: function(e) {
            _.isArray(e) || (e = [e]);
            if (!e.length) throw new Error("empty buddies");
            _.each(e, function(e) {
                var t = e.uid,
                    r = new f.ActorBuddy(t, e.id, e);
                n[t] = r, this._startListening(r), this.trigger("ActorMgr::registerBuddy", r)
            }, this)
        },
        registerSupporter: function(e) {
            _.isArray(e) || (e = [e]), _.each(e, function(e) {
                var t = e.uid;
                r[t] = new f.ActorSupporter(t, e.id, e)
            }, this)
        },
        registerEnemy: function(e) {
            _.isArray(e) || (e = [e]);
            if (!e.length) throw new Error("empty enemies");
            var t = 0,
                n = 0,
                r = 0,
                o = 0,
                u;
            for (t = 0, n = e.length; t < n; t++) {
                var a = e[t];
                u = {};
                for (r = 0, o = a.children.length; r < o; r++) {
                    var l = a.children[r],
                        c = new f.ActorEnemy(l.uid, a.id, l);
                    u[c.get("no")] = c, i[l.uid] = c, this._startListening(c), this.trigger("ActorMgr::registerEnemy", c)
                }
                var h = new f.EnemyContainer(a, u);
                s.push(h)
            }
        },
        getAllEnemyContainers: function() {
            return s
        },
        getAliveEnemyContainers: function() {
            return _.filter(this.getAllEnemyContainers(), function(e) {
                return !e.isAllDead()
            })
        },
        getAll: function() {
            return [].concat(_.values(n)).concat(_.values(i))
        },
        getAliveActors: function() {
            return _.filter(this.getAll(), function(e) {
                return e.isAlive()
            })
        },
        getAllBuddies: function() {
            return _.values(n)
        },
        getAliveBuddies: function() {
            return _.filter(this.getAllBuddies(), function(e) {
                return e.isAlive()
            })
        },
        getDeadBuddies: function() {
            return _.filter(this.getAllBuddies(), function(e) {
                return e.isDead()
            })
        },
        getReraiseDeathBuddies: function() {
            return _.filter(this.getAllBuddies(), function(e) {
                return e.isInReraiseDeath()
            })
        },
        getAbilityPanelSelector: function() {
            var e = f.BattleInfo.getInstance();
            return e.isJustEnded() ? null : u && u.isReadyToSelectAbility() ? u : (u = this._findNextSelector(u), u)
        },
        notifySkipAbility: function(e) {
            u = this._findNextSelector(e)
        },
        _findNextSelector: function(e) {
            var t = f.BattleInfo.getInstance(),
                n = t.getSkipOrderCandidates();
            switch (t.getSkipOrder()) {
                case n.NO:
                    return this._findNextSelectorOrderByNo(e);
                case n.ATB:
                default:
                    return this._findNextSelectorOrderByAtb(e)
            }
        },
        _findNextSelectorOrderByAtb: function(e) {
            var t = this.getReadyToSelectAbilityBuddies();
            if (t.length === 0) return null;
            t.sort(function(e, t) {
                return e.getReadyToSelectAbilityAt() - t.getReadyToSelectAbilityAt() || e.get("no") - t.get("no")
            });
            var n = t[a];
            return n && e && n.equals(e) && a++, t.length <= a && (a = 0), t[a]
        },
        _findNextSelectorOrderByNo: function(e) {
            var t = this.getReadyToSelectAbilityBuddies();
            if (t.length === 0) return null;
            t.sort(function(e, t) {
                return e.get("no") - t.get("no")
            });
            var n = _.find(t, function(t) {
                return e && e.get("no") < t.get("no")
            });
            return n || (n = t[0]), n
        },
        getReadyToSelectAbilityBuddies: function() {
            var e = this.getAliveBuddies();
            return _.filter(e, function(e) {
                return e.isReadyToSelectAbility() && e.canSelectAbility()
            })
        },
        getAllEnemies: function() {
            return _.values(i)
        },
        getAliveEnemies: function() {
            return _.filter(this.getAllEnemies(), function(e) {
                return e.isAlive()
            })
        },
        getSupporter: function() {
            return _.first(_.values(r))
        },
        getByUid: function(e) {
            var t = n[e] || i[e] || r[e];
            if (!t) throw new Error("actor not found.uid=" + e);
            return t
        },
        getBuddyByPosId: function(e) {
            var t = _.filter(this.getAllBuddies(), function(t) {
                return t.get("posId") === e
            });
            return t.shift()
        },
        getEnemyByPosId: function(e) {
            var t = _.filter(this.getAllEnemies(), function(t) {
                return t.get("posId") === e
            });
            return t.shift()
        },
        clearEnemy: function() {
            i = {}, s = [], this.trigger("ActorMgr::clearEnemy")
        },
        getActiveTarget: function() {
            if (o) {
                var e = this.getByUid(o);
                if (e.isBuddy() || !e.isDead()) return e
            }
            return null
        },
        toggleActiveTarget: function(e) {
            var t = this.getByUid(e),
                n = void 0;
            t.isEnemy() ? n = t.isPossibleToTarget() && t.isAlive() : n = t.isPossibleToTarget(), o ? o !== e ? n && (o = e) : o = void 0 : n && (o = e)
        },
        clearActiveTarget: function() {
            o = void 0
        },
        getSubstituteTarget: function(e, n) {
            var r = _.filter(this.getAliveActors(), function(t) {
                return e.isColleague(t) ? !1 : t.canSubstitute(n)
            }, this);
            return r.length > 0 ? t.lot(r, function() {
                return 100
            }, {}) : void 0
        },
        resetBuddiesForContinue: function() {
            _.each(n, function(e) {
                e.resetForContinue()
            });
            var e = this.getSupporter();
            e && e.resetForContinue(), this.trigger("ActorMgr::resetBuddiesForContinue")
        },
        _startListening: function(e) {
            this.listenTo(e, "all", this._listen), e.container && this.listenTo(e.container, "all", this._listen)
        },
        _listen: function() {
            this.trigger.apply(this, arguments)
        }
    }, e)
}), define("scenes/battle/ActorParamHolder", ["util", "lib/ClassBase"], function(e, t) {
    var n = FF.ns.battle,
        r = {
            atk: {
                isBoostable: !0
            },
            def: {
                isBoostable: !0
            },
            matk: {
                isBoostable: !0
            },
            mdef: {
                isBoostable: !0
            },
            spd: {
                isBoostable: !0
            },
            mnd: {
                isBoostable: !0
            },
            acc: {
                isBoostable: !0
            },
            eva: {
                isBoostable: !0
            },
            critical: {
                isBoostable: !0
            },
            atkSsPointFactor: {
                init: 0,
                isBoostable: !0
            },
            defSsPointFactor: {
                init: 0,
                isBoostable: !0
            },
            looking: {
                init: n.Conf.ACTOR_LOOKING_DEFAULT
            },
            atkElement: {
                init: ""
            },
            atkStatusAilments: {
                init: {}
            },
            matkElementMap: {
                init: {}
            },
            defAttributeMap: {},
            atbCoef: {
                init: 1
            },
            atkType: {
                init: n.Conf.ATK_TYPE.DIRECT
            }
        };
    FF.ns.battle.ActorParamHolder = t.extend({
        initialize: function(e, n) {
            t.prototype.initialize.call(this), this._baseParam = n, this._actorUid = e.getUid(), this.resetAllParam(), this._holderId = 1, this._holders = {}
        },
        resetAllParam: function() {
            var t = this._baseParam;
            _.each(r, function(n, r) {
                var i = _.isUndefined(t[r]) ? n.init : t[r];
                if (_.isUndefined(i)) throw new Error("invalid param.key=" + r);
                _.isObject(i) && (i = e.cloneDeep(i)), this.set(r, i)
            }, this), this._holders = {}
        },
        updateVal: function(e) {
            var t = this._baseParam[e],
                n = t,
                r = _.filter(this._holders, function(t) {
                    return t.propName !== e ? !1 : _.isUndefined(t.boostValue) ? !1 : !0
                });
            if (r.length > 0) {
                var i = _.last(r);
                i.isAbsolute ? n = i.boostValue : _.each(r, function(e) {
                    if (e.isAbsolute === !0) return;
                    n += Math.floor(n * (e.boostValue / 100))
                })
            }
            n = _.max([n, 1]), this.set(e, n)
        },
        updateObjVal: function(t) {
            var n = this,
                r = this._baseParam[t],
                i = e.cloneDeep(r),
                s = _.filter(this._holders, function(e) {
                    return e.propName !== t ? !1 : _.isUndefined(e.boostValue) ? !1 : _.isObject(e.boostValue) ? !0 : !1
                });
            s.length > 0 && _.each(s, function(e) {
                _.each(e.boostValue, function(t, r) {
                    if (!t) throw new Error("ActorParamholder::updateObjVal, val is 0 or undefined");
                    if (e.boostType === "attachElement") {
                        var s = i[r] || 0;
                        i[r] = n._getAttachElementBoostNextVal(s, t)
                    } else i[r] = t
                })
            }), this.set(t, i)
        },
        _getAttachElementBoostNextVal: function(e, t) {
            var r;
            e === 1 ? r = t === 1 ? 0 : t : (r = e < 1 ? 1 : e, r += t);
            var i = n.Config.getInstance().get("DamageCalculator", "ELEMENT_ADVANTAGE"),
                s = _.max(_.map(_.keys(i), function(e) {
                    return +e
                }));
            return _.min([r, s])
        },
        changeParam: function(e, t, n) {
            var r = this._holderId++;
            return this._holders[r] = {
                propName: e,
                boostValue: t,
                isAbsolute: !!n
            }, this.updateVal(e), r
        },
        changeAttachElementParam: function(e, t, n) {
            var r = this._holderId++;
            return this._holders[r] = {
                propName: e,
                boostValue: t,
                boostType: n
            }, this.updateObjVal(e), r
        },
        isBoostableParam: function(e) {
            var t = r[e];
            return t && t.isBoostable === !0
        },
        changeBaseParam: function(e) {
            this._baseParam = e, this.recalc()
        },
        getBaseParam: function() {
            return this._baseParam
        },
        recalc: function() {
            _.each(r, function(e, t) {
                var n = this._baseParam[t];
                _.isObject(n) ? this.set(t, n) : this.updateVal(t)
            }, this)
        },
        resetParamById: function(e) {
            var t = this._holders[e];
            if (!t) throw new Error("not found such a holderId. " + e);
            var n = t.propName,
                r = t.boostValue;
            delete this._holders[e], _.isObject(r) ? this.updateObjVal(n) : this.updateVal(n)
        },
        toPlainObject: function() {
            return {
                holderId: this._holderId,
                holders: this._holders,
                attributes: this._attributes,
                baseParam: this._baseParam
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            _.extend(this._attributes, e.attributes), this._holderId = e.holderId || 1, this._holders = e.holders, this._baseParam = e.baseParam, this.recalc()
        }
    })
}), define("scenes/battle/ActorTimeMgr", ["lib/ClassBase"], function(e) {
    var t = FF.ns.battle,
        n = e.extend({
            initialize: function() {
                e.prototype.initialize.apply(this, arguments)
            },
            onPostHit: function(e) {
                var n = t.ActorMgr.getByUid(e.uid);
                n.resetAtb()
            },
            enable: function() {
                this._disabled = !1
            },
            disable: function() {
                this._disabled = !0
            },
            update: function() {
                var e = t.BattleInfo.getInstance();
                if (e.isJustEnded()) return;
                if (e.isBattleState("IN_ACTION") || e.isBattleState("RERAISE_RISE")) return;
                _.each(t.ActorMgr.getAliveActors(), function(e) {
                    this._updateAtb(e), this._updateCast(e), this._updateSa(e)
                }, this)
            },
            _updateAtb: function(e) {
                if (this._disabled) return;
                if (!e.isStateIdle() || e.isAtbFull()) return;
                if (!e.canDoAbility()) return;
                var t = e.get("elapsedAtbTime"),
                    n = FF.scene.elapsedBattleTime;
                n = Math.floor(n * e.getAtbTimeFactor() / 100), e.set("elapsedAtbTime", _.min([t + n, e.getAtbTime()])), e.isAtbFull() && e.notifyAtbFull()
            },
            _updateCast: function(e) {
                if (this._disabled) return;
                if (!e.isStateInCast() || e.isCastFull()) return;
                if (!e.canDoAbility()) return;
                var t = e.get("elapsedCastTime"),
                    n = FF.scene.elapsedBattleTime;
                n = Math.floor(n * e.getCastTimeFactor() / 100), e.set("elapsedCastTime", _.min([t + n, e.getCastTime()])), e.isCastFull() && e.notifyCastFull()
            },
            _updateSa: function(e) {
                var n = FF.scene.elapsedBattleTime;
                e.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.INVISIBLE) || e.statusAilments.update(n)
            }
        }),
        r = void 0;
    FF.ns.battle.ActorTimeMgr = {
        getInstance: function() {
            return r || (r = new n), r
        }
    }
}), define("scenes/battle/Api", ["util", "lib/api"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.Api = {
        _openLoading: function() {
            n.BattleViewController.getInstance().loadingView.open()
        },
        _closeLoading: function() {
            n.BattleViewController.getInstance().loadingView.close()
        },
        requestApiDeferred: function(t, n) {
            var r = this;
            return n = e.option({
                loading: !0,
                notifyNetworkError: !0,
                notifyMaintenance: !0
            }, n), this._callSafelyDeferred(t, n)
        },
        requestDeferred: function(e, n, r, i) {
            var s = function() {
                return t.requestDeferred(e, n, r)
            };
            return this.requestApiDeferred(s, i)
        },
        _callSafelyDeferred: function(t, r, i) {
            var s = this;
            r.loading && this._openLoading();
            var o = i || $.Deferred();
            return t().done(function() {
                r.loading && s._closeLoading(), o.resolve.apply(o, arguments)
            }).fail(function(i, u, a) {
                r.loading && s._closeLoading();
                if (i && i.status === 403 || a && a.error === "REQUIRE_LOGIN") {
                    n.BattleViewController.getInstance().showSystemWindow(n.Conf.SYSTEM_WINDOW.LOGIN);
                    return
                }
                if (a && a.error === "MAINTENANCE") {
                    var f = _.extend({
                        isMaintenance: !0
                    }, e.camelizeDeep(a.misc_data));
                    r.notifyMaintenance ? n.BattleViewController.getInstance().notifyMaintenance(function() {
                        s._callSafelyDeferred(t, r, o)
                    }, f) : o.reject(i, u, a, f);
                    return
                }
                r.notifyNetworkError ? n.BattleViewController.getInstance().notifyCheckingNetwork(function() {
                    s._callSafelyDeferred(t, r, o)
                }) : o.reject.apply(o, arguments)
            }), o.promise()
        },
        battleWinDeferred: function(e, t, r) {
            var i = n.BattleInfo.getInstance().getAppInitDataEndpointMap().win,
                s = {};
            return this.requestDeferred(i, {
                results: e
            }, _.extend({
                type: "POST",
                hashFunc: t
            }, r), s)
        },
        winTutorialBattleDeferred: function(e, t) {
            var r = n.BattleInfo.getInstance().getAppInitDataEndpointMap().lose,
                i = {};
            return this.requestDeferred(r, {
                results: e
            }, _.extend({
                type: "POST"
            }, t), i)
        },
        battleLoseDeferred: function(e, t, r) {
            var i = n.BattleInfo.getInstance().getAppInitDataEndpointMap().lose,
                s = {};
            return this.requestDeferred(i, {
                results: e
            }, _.extend({
                type: "POST",
                hashFunc: t
            }, r), s)
        },
        battleEscapeDeferred: function(e, t, r) {
            var i = n.BattleInfo.getInstance().getAppInitDataEndpointMap().escape,
                s = {};
            return this.requestDeferred(i, {
                results: e
            }, {
                type: "POST",
                hashFunc: t
            }, s)
        },
        getBattleInitDeferred: function() {
            var e = n.BattleInfo.getInstance().getAppInitDataEndpointMap().get_init_data,
                t = {
                    loading: !1,
                    notifyNetworkError: !1,
                    notifyMaintenance: !1
                };
            return this.requestDeferred(e, {}, {}, t)
        },
        getContinueInfoDeferred: function(e) {
            var t = {
                notifyNetworkError: !1,
                notifyMaintenance: !0
            };
            return this.requestDeferred("/dff/continue/get_info", {}, e, t)
        },
        startContinueDeferred: function(e, t, n, r) {
            var i = {
                notifyNetworkError: !1,
                notifyMaintenance: !0
            };
            return this.requestDeferred("/dff/continue/start", {
                type_id: e,
                session_key: t,
                token: n
            }, _.extend({
                type: "POST"
            }, r), i)
        },
        closeContinueDeferred: function(e, t, n, r, i) {
            var s = {
                notifyNetworkError: !1,
                notifyMaintenance: !0
            };
            return this.requestDeferred("/dff/continue/close", {
                continue_id: e,
                type_id: t,
                session_key: n,
                token: r
            }, _.extend({
                type: "POST"
            }, i), s)
        },
        inquireContinueStatusDeferred: function(e, t, n, r, i) {
            var s = {
                notifyNetworkError: !1,
                notifyMaintenance: !0
            };
            return this.requestDeferred("/dff/continue/inquire_status", {
                continue_id: e,
                type_id: t,
                session_key: n,
                token: r
            }, _.extend({
                type: "POST"
            }, i), s)
        },
        getBalanceDeferred: function() {
            var e = {
                    notifyNetworkError: !1,
                    notifyMaintenance: !0
                },
                n = function() {
                    var e = $.Deferred();
                    return t.getBalanceDeferred().done(function(t) {
                        e.resolve(t)
                    }).fail(function(t) {
                        e.reject(null, null, t)
                    }), e.promise()
                };
            return this.requestApiDeferred(n, e)
        },
        purchaseItemDeferred: function(e) {
            var n = {
                    notifyNetworkError: !1,
                    notifyMaintenance: !0
                },
                r = function() {
                    var n = $.Deferred();
                    return t.purchaseItemDeferred(e).done(function(e) {
                        n.resolve(e)
                    }).fail(function(e) {
                        n.reject(null, null, e)
                    }), n.promise()
                };
            return this.requestApiDeferred(r, n)
        },
        notificationGetDataDeferred: function(e) {
            var t = {
                notifyNetworkError: !1,
                notifyMaintenance: !1
            };
            return this.requestDeferred("/dff/notification/get_data", {}, e, t)
        },
        createExternalUserAuthHashDeffered: function(e, t) {
            var n = {};
            return this.requestDeferred("/dff/external_user_auth/create_hash_battle", {
                guest_id: e,
                callback_url: t
            }, {
                type: "POST"
            }, n)
        }
    }
}), define("scenes/battle/BattleEventMgr", ["lib/ClassBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.BattleEventMgr = e.extend({
        initialize: function() {
            this.eventFsm = this._createFsm(), this.battleProcessMgr = new t.BattleProcessMgr, this.eventFsm.setParent(this)
        },
        update: function() {
            this.eventFsm.update()
        },
        battleUpdate: function() {
            this.battleProcessMgr.update()
        },
        _createFsm: function() {
            return new t.EventFsm
        }
    })
}), define("scenes/battle/BattleFsm", ["lib/NameConventionFsm"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.BattleFsm = e.extend({
        initialize: function() {
            e.prototype.initialize.call(this), this.changeState("IDLE")
        },
        changeState: function(n) {
            e.prototype.changeState.apply(this, arguments), t.BattleInfo.getInstance().set("state", n)
        },
        processForStateIdleUpdate: function() {
            if (this._judgeDeathAndProcess()) return;
            _.each(t.ActorMgr.getAliveActors(), function(e) {
                e.update()
            }), _.each(t.ActorMgr.getAliveEnemyContainers(), function(e) {
                e.update()
            });
            if (this._judgeDeathAndProcess()) return;
            t.ActorTimeMgr.getInstance().update();
            var e = t.BattleInfo.getInstance(),
                n = t.AbilityMgr.getInstance().shiftInterrupter();
            if (n) {
                this._interruptedAbility = n, e.setCurrentAbility(n), this.changeState("IN_ACTION");
                return
            }
            var r = t.AbilityMgr.getInstance().shiftAbility();
            if (r) {
                this._activeAbility = r, e.setCurrentAbility(r), r.isResumed() || r.executer.changeState("IN_ACTION"), this.changeState("IN_ACTION");
                return
            }
        },
        processForStateInActionEntry: function() {
            var e = this._interruptedAbility || this._activeAbility;
            e.isResumed() || e.begin()
        },
        processForStateInActionUpdate: function() {
            var e = void 0,
                n = void 0;
            t.ActorTimeMgr.getInstance().update(), this._interruptedAbility ? (n = this._interruptedAbility, n.update(), e = n.isDone()) : this._activeAbility && (n = this._activeAbility, n.update(), e = n.isDone(), e && n.executer.notifyAbilityDone());
            var r = n.isSuspended();
            r && t.AbilityMgr.getInstance().pushSuspend(n);
            if (e || r) this.changeState("IDLE"), this._interruptedAbility = null, this._activeAbility = null, t.BattleInfo.getInstance().setCurrentAbility(null)
        },
        processForStateReraiseRiseEntry: function() {
            var e = t.ActorMgr.getReraiseDeathBuddies(),
                n = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.RERAISE_RISE, e[0]);
            this._interruptedAbility = n, t.BattleInfo.getInstance().setCurrentAbility(n), n.begin()
        },
        processForStateReraiseRiseUpdate: function() {
            t.ActorTimeMgr.getInstance().update();
            var e = this._interruptedAbility;
            e.update();
            var n = e.isDone();
            n && (this.changeState("IDLE"), this._interruptedAbility = null, t.BattleInfo.getInstance().setCurrentAbility(null))
        },
        processForStateDeathEntry: function() {
            var e = [];
            _.each(t.ActorMgr.getAliveBuddies(), function(t) {
                t.judgeDeath() && (t.die(), e.push(t))
            }), e.length === 0 && _.each(t.ActorMgr.getAliveEnemies(), function(t) {
                t.judgeDeath() && (t.die(), e.push(t))
            }), this._judge = this._judgeVictory(), this._judge && t.BattleInfo.getInstance().set("isJustEnded", !0), this._death = new t.DeathFsm({
                deadActors: e,
                judge: this._judge
            })
        },
        processForStateDeathUpdate: function() {
            t.ActorTimeMgr.getInstance().update(), this._death.update();
            if (!this._death.isState("END")) return;
            var e = t.BattleInfo.getInstance();
            this._judge ? (e.set("judge", this._judge), e.isVictory() && e.isFinalRound() && e.set("isClear", !0), this.changeState("CLEANING")) : 0 < t.ActorMgr.getReraiseDeathBuddies().length ? this.changeState("RERAISE_RISE") : this.changeState("IDLE")
        },
        processForStateDeathExit: function() {
            this._death = void 0, this._judge = void 0
        },
        processForStateCleaningEntry: function() {
            var e = t.AbilityMgr.getInstance().shiftSuspend();
            if (!e) {
                this.changeState("END");
                return
            }
            this._activeAbility = e, e.forceQuit()
        },
        processForStateCleaningUpdate: function() {
            var e = this._activeAbility;
            e.update(), e.isDone() && (e.executer.changeState("IDLE"), this._activeAbility = void 0, this.changeState("CLEANING"))
        },
        processForStateEndEntry: function() {
            var e = _.filter(t.ActorMgr.getAliveActors(), function(e) {
                if (e.isStateInAction()) throw new Error("invalid state. uid:" + e.getUid());
                return !e.isStateEnd()
            });
            _.each(e, function(e) {
                e.setEnd()
            })
        },
        _judgeDeathAndProcess: function() {
            if (this._judgeVictory()) return this.changeState("DEATH"), !0;
            if (_.any(t.ActorMgr.getAliveBuddies(), function(e) {
                    return e.judgeDeath()
                })) return this.changeState("DEATH"), !0;
            var e = _.map(t.ActorMgr.getAliveEnemyContainers(), function(e) {
                return this._judgeDeathEnemyContainer(e)
            }, this);
            return _.any(e) ? (this.changeState("DEATH"), !0) : !1
        },
        _judgeDeathEnemyContainer: function(e) {
            var t = [],
                n = [];
            return _.each(e.getAliveChildren(), function(e) {
                e.judgeDeath() && (t.push(e), n.push(e.notifyJudgedDeath()))
            }, this), t.length > 0 && n.push(e.notifyJudgedDeath(t)), n.length > 0 ? _.all(n) : !1
        },
        _judgeVictory: function() {
            if (0 < t.ActorMgr.getReraiseDeathBuddies().length) return;
            var e = _.filter(t.ActorMgr.getAllBuddies(), function(e) {
                return e.isContinuousBattle()
            });
            if (e.length <= 0) {
                var n = _.any(t.ActorMgr.getAllBuddies(), function(e) {
                    return e.isForceEscaped()
                });
                return n ? t.Conf.JUDGE.FORCE_ESCAPE : t.Conf.JUDGE.LOSE
            }
            var r = _.filter(t.ActorMgr.getAllEnemyContainers(), function(e) {
                return e.isContinuousBattle()
            });
            if (r.length <= 0) return t.Conf.JUDGE.VICTORY;
            return
        }
    })
}), define("scenes/battle/BattleInfo", ["lib/ClassBase", "lib/BattleConfig", "util"], function(e, t, n) {
    var r, i = FF.ns.battle,
        s = e.extend({
            load: function(e) {
                this._battleInitData = e, this.reset();
                var t = e.battle.buddy,
                    n = e.battle.supporter,
                    r = e.battle.rounds;
                this.set("roundNum", r.length), this.continueTxns = [], this._uid2actor = {};
                var i = 0,
                    s = 0;
                for (i = 0, s = t.length; i < s; i++) this._uid2actor[t[i].uid] = t[i];
                for (i = 0, s = n.length; i < s; i++) this._uid2actor[n[i].uid] = n[i];
                var o = [],
                    u = [];
                for (i = 0, s = r.length; i < s; i++) Array.prototype.push.apply(o, r[i].enemy);
                for (i = 0, s = o.length; i < s; i++) Array.prototype.push.apply(u, o[i].children);
                for (i = 0, s = u.length; i < s; i++) this._uid2actor[u[i].uid] = u[i];
                this._translate(t, n, u), this._enemies = u, this._enemyContainers = o, FF.logger.debug("buddies", t), FF.logger.debug("enemies", u)
            },
            _translate: function(e, t, n) {
                var r = [];
                Array.prototype.push.apply(r, e), Array.prototype.push.apply(r, t), Array.prototype.push.apply(r, n);
                var s = _.invert(i.Conf.STATUS_AILMENTS_TYPE),
                    o = _.invert(i.Conf.ELEMENT_TYPE);
                _.each(r, function(e) {
                    e.paramMap = {}, e.row = e.row || i.Conf.ROW_TYPE.FRONT, _.each(e.params, function(t) {
                        var n = void 0,
                            r = {};
                        _.each(t.atkAttributes, function(e) {
                            var t = e.attributeId;
                            o[t] && (n = t), s[t] && (r[t] = e.factor)
                        });
                        var i = {};
                        _.each(t.matkAttributes, function(e) {
                            var t = e.attributeId;
                            o[t] && (i[t] = e.factor)
                        });
                        var u = {};
                        _.each(t.defAttributes, function(e) {
                            u[e.attributeId] = e.factor
                        }), t.atkStatusAilments = r, t.matkElementMap = i, t.defAttributeMap = u, t.row = e.row, e.paramMap[t.id] = t
                    })
                })
            },
            toPlainObject: function() {
                var e = [];
                return _.each(this.continueTxns, function(t) {
                    e.push(t.toPlainObject())
                }, this), {
                    round: this.get("round"),
                    actionTime: this.get("actionTime"),
                    continueTxns: e,
                    roundRevertObject: this.get("roundRevertObject")
                }
            },
            applyPlainObject: function(e) {
                if (!e) return;
                this.set("round", e.round), this.set("actionTime", e.actionTime), this.set("roundRevertObject", e.roundRevertObject);
                var t = [];
                _.each(e.continueTxns, function(e) {
                    var n = new i.ContinueTxn;
                    n.applyPlainObject(e), t.push(n)
                }, this), this.continueTxns = t
            },
            reset: function() {
                _.extend(this._attributes, n.option({
                    judge: void 0,
                    resultInfo: void 0,
                    state: void 0,
                    isJustEnded: !1
                }))
            },
            getBattleInitData: function() {
                return this._battleInitData
            },
            getBattleParam: function(e) {
                return e = e || this.get("round"), this._battleInitData.battle.rounds[e - 1]
            },
            getActorParam: function(e) {
                return this._uid2actor[e]
            },
            getBuddyParams: function() {
                return this._battleInitData.battle.buddy
            },
            getSupporterParams: function() {
                return this._battleInitData.battle.supporter
            },
            getEnemyParams: function() {
                return this._enemies
            },
            getEnemyContainerParams: function() {
                return this._enemyContainers
            },
            getNextBattleParam: function() {
                var e = this.get("round") + 1;
                return this._battleInitData.battle.rounds[e - 1]
            },
            getDropItemList: function(e) {
                e = e || this.get("round");
                var t = this.getBattleParam(e);
                return t.dropItemList
            },
            getDropMaterias: function(e) {
                e = e || this.get("round");
                var t = this.getBattleParam(e);
                return t.dropMaterias
            },
            getBackgroundAnimationTime: function() {
                return this._battleInitData.battle.background.animationTime
            },
            isEnded: function() {
                return !!this.get("judge")
            },
            isJustEnded: function() {
                return this.get("isJustEnded")
            },
            isVictory: function() {
                return this.get("judge") === i.Conf.JUDGE.VICTORY
            },
            isLose: function() {
                return this.get("judge") === i.Conf.JUDGE.LOSE
            },
            isForceEscape: function() {
                return this.get("judge") === i.Conf.JUDGE.FORCE_ESCAPE
            },
            isBattleState: function(e) {
                return this.get("state") === e
            },
            isFinalRound: function(e) {
                return e = e || this.get("round"), e >= this.get("roundNum")
            },
            getAppInitData: function() {
                return FF.env.isNative() ? (r || (r = JSON.parse($("[data-app-init-data]").html())), r) : {}
            },
            getAppInitDataSessionKey: function() {
                return this.getAppInitData().session_key
            },
            getAppInitDataEndpointMap: function() {
                return this.getAppInitData().endpoint_map
            },
            getAppInitDataEventId: function() {
                var e = this.getAppInitData().event;
                return e ? e.event_id : void 0
            },
            addNewContinueTxn: function(e) {
                if (this._readLockForContinueTxn) throw new Error("transaction list has been locked for adding.");
                this._readLockForContinueTxn = !0;
                var t = _.any(this.continueTxns, function(t) {
                    return e.get("continueId") === t.get("continueId")
                }, this);
                if (t) throw new Error("continueId duplicated. id:" + e.get("continueId"));
                var n = this._getLastContinueTxn(),
                    r;
                if (n) {
                    if (n.chkNextTxnCreatedInDisallowTime(e)) throw r = {
                        lastTxn: n.toPlainObject(),
                        newTxn: e.toPlainObject()
                    }, new Error("txn generated within 1000ms. txns:" + JSON.stringify(r));
                    if (!n.isEnded()) throw r = {
                        lastTxn: n.toPlainObject(),
                        newTxn: e.toPlainObject()
                    }, new Error("last transaction has not been ended. txns:" + JSON.stringify(r))
                }
                this.continueTxns.push(e), this._readLockForContinueTxn = !1
            },
            getLastContinueTxn: function() {
                if (this._readLockForContinueTxn) throw new Error("transaction list has been locked for reading.");
                this._readLockForContinueTxn = !0;
                var e = this._getLastContinueTxn();
                return this._readLockForContinueTxn = !1, e
            },
            _getLastContinueTxn: function() {
                return _.first(this.continueTxns.sort(function(e, t) {
                    return e.get("continueId") < t.get("continueId") ? 1 : -1
                }))
            },
            getAllContinueTxns: function() {
                return this.continueTxns
            },
            setCurrentAbility: function(e) {
                return this.set("currentAbility", e)
            },
            getCurrentAbility: function() {
                return this.get("currentAbility")
            },
            getExpiredAt: function() {
                return this.getBattleInitData().battle.expiredAt
            },
            getBuddyBoostExpMap: function() {
                return this.getBattleInitData().battle.buddyBoostExpMap || {}
            },
            addActionTime: function(e) {
                var t = this.get("actionTime") || 0;
                this.set("actionTime", t + e)
            },
            isResultAlreadyEnded: function() {
                var e = this.get("resultInfo");
                return e && e.data && e.data.error && e.data.error === "BATTLE_ALREADY_ENDED" ? !0 : !1
            },
            isResultExpired: function() {
                var e = this.get("resultInfo");
                return e && e.data && e.data.error && e.data.error === "BATTLE_EXPIRE" ? !0 : !1
            },
            isResultError: function() {
                var e = this.get("resultInfo");
                return e && e.data && e.data.error ? !0 : !1
            },
            detectUrlFromResultInfo: function() {
                var e = this.get("resultInfo");
                if (!e) throw new Error("not found resultInfo");
                var t = this.isResultAlreadyEnded() ? "/dff/" : this.isResultExpired() ? "/dff/" : _.isString(e.data.url) ? e.data.url : "/dff/";
                return t
            },
            canOperateBattle: function() {
                return this.get("isPlaying") && this.get("isInBattle") && !this.isJustEnded()
            },
            setBattleConfig: function(e) {
                this.set("battleConfig", e)
            },
            getBattleConfig: function() {
                return this.get("battleConfig")
            },
            getBattleSpeedIndex: function() {
                return t.getBattleSpeedIndex(this.getBattleConfig().speed)
            },
            setBattleSpeedIndex: function(e) {
                var n = this.getBattleConfig(),
                    r = t.getBattleSpeedCandidates(),
                    i = r[e];
                if (!i) throw new Error("invalid battle speed" + i);
                n.speed = i, this.setBattleConfig(n)
            },
            getSkipOrder: function() {
                return this.getBattleConfig().skipOrder
            },
            getSkipOrderCandidates: function() {
                return t.getSkipOrderCandidates()
            },
            isAutoEnabledAtBattleStart: function() {
                return this.getBattleConfig().isAutoEnabledAtBattleStart
            }
        }),
        o = void 0;
    FF.ns.battle.BattleInfo = {
        getInstance: function() {
            return o || (o = new s), o
        }
    }
}), define("scenes/battle/BattleInitData", ["lib/ValidatorLite", "lib/ClassBase", "util"], function(e, t, n) {
    var r = {
            root: {
                assets: {
                    type: "object",
                    norecursive: !0
                },
                battle: {
                    type: "object"
                },
                success: {
                    type: "boolean"
                },
                initChkResult: {
                    type: "boolean"
                },
                resServerSnapshot: {
                    type: "string",
                    optional: !0
                },
                resClientSnapshot: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle": {
                battleId: {
                    type: "uint"
                },
                enemyAbilities: {
                    type: "array"
                },
                background: {
                    type: "object",
                    norecursive: !0
                },
                rounds: {
                    type: "array"
                },
                buddy: {
                    type: "array"
                },
                dungeon: {
                    type: "object",
                    norecursive: !0
                },
                supporter: {
                    type: "array"
                },
                score: {
                    type: "object"
                },
                messages: {
                    type: "array"
                },
                expiredAt: {
                    type: "uint"
                },
                version: {
                    type: "uint"
                },
                win_bgm: {
                    type: "string",
                    optional: !0
                },
                assets: {
                    type: "object",
                    norecursive: !0
                },
                buddyBoostExpMap: {
                    type: "object",
                    norecursive: !0,
                    optional: !0
                }
            },
            "root.battle.enemyAbilities": {
                abilityId: {
                    type: "uint"
                },
                actionId: {
                    type: "uint"
                },
                exerciseType: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object"
                },
                options: {
                    type: "object"
                }
            },
            "root.battle.enemyAbilities.animationInfo": {
                id: {
                    type: "uint"
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string"
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                shot: {
                    type: "string"
                },
                hit: {
                    type: "string"
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint"
                },
                shotType: {
                    type: "uint"
                },
                hitType: {
                    type: "uint"
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint"
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint"
                },
                reverseHit: {
                    type: "uint"
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                },
                launchSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                shotSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                hitSpriteNum: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.enemyAbilities.options": {
                name: {
                    type: "string"
                },
                abilityAnimationId: {
                    type: "string",
                    optional: !0
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                },
                arg6: {
                    type: "number",
                    optional: !0
                },
                arg7: {
                    type: "number",
                    optional: !0
                },
                arg8: {
                    type: "number",
                    optional: !0
                },
                arg9: {
                    type: "number",
                    optional: !0
                },
                arg10: {
                    type: "number",
                    optional: !0
                },
                targetRange: {
                    type: "uint",
                    optional: !0
                },
                targetSegment: {
                    type: "uint",
                    optional: !0
                },
                targetDeath: {
                    type: "uint",
                    optional: !0
                },
                targetMethod: {
                    type: "uint",
                    optional: !0
                },
                activeTargetMethod: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsId: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsFactor: {
                    type: "uint",
                    optional: !0
                },
                castTime: {
                    type: "uint",
                    optional: !0
                },
                counterEnable: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.rounds": {
                round: {
                    type: "uint"
                },
                dropItemList: {
                    type: "array"
                },
                enemy: {
                    type: "array"
                },
                bgm: {
                    type: "string"
                },
                backgroundChangeType: {
                    type: "uint"
                },
                buddyTransitType: {
                    type: "uint"
                },
                dropMaterias: {
                    type: "array"
                }
            },
            "root.battle.rounds.dropMaterias": {
                itemId: {
                    type: "uint"
                },
                name: {
                    type: "string"
                },
                description: {
                    type: "string"
                },
                buddyPos: {
                    type: "string"
                }
            },
            "root.battle.rounds.enemy": {
                deformAnimationInfo: {
                    type: "array",
                    optional: !0
                },
                aiId: {
                    type: "uint"
                },
                id: {
                    type: "uint"
                },
                children: {
                    type: "array"
                },
                isSpEnemy: {
                    type: "boolean"
                }
            },
            "root.battle.rounds.enemy.children": {
                aiId: {
                    type: "uint"
                },
                childPosId: {
                    type: "uint",
                    optional: !0
                },
                dropItemList: {
                    type: "array",
                    optional: !0
                },
                initHp: {
                    type: "uint"
                },
                maxHp: {
                    type: "uint"
                },
                no: {
                    type: "uint",
                    optional: !0
                },
                params: {
                    type: "array"
                },
                uid: {
                    type: "uint"
                }
            },
            "root.battle.rounds.enemy.children.params": {
                abilities: {
                    type: "array"
                },
                counters: {
                    type: "array"
                },
                acc: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object",
                    optional: !0
                },
                atk: {
                    type: "uint"
                },
                critical: {
                    type: "uint"
                },
                def: {
                    type: "uint"
                },
                defAttributes: {
                    type: "array"
                },
                dispName: {
                    type: "string"
                },
                eva: {
                    type: "uint"
                },
                id: {
                    type: "uint"
                },
                matk: {
                    type: "uint"
                },
                mdef: {
                    type: "uint"
                },
                mnd: {
                    type: "uint"
                },
                size: {
                    type: "string"
                },
                spd: {
                    type: "uint"
                },
                looking: {
                    type: "uint"
                },
                breedId: {
                    type: "uint"
                },
                lv: {
                    type: "uint"
                },
                castTimeType: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.rounds.enemy.children.params.defAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.rounds.enemy.deformAnimationInfo": {
                id: {
                    type: "uint"
                },
                deformTag: {
                    type: "string"
                },
                state: {
                    type: "array",
                    optional: !0,
                    norecursive: !0
                },
                isRandom: {
                    type: "boolean"
                }
            },
            "root.battle.rounds.enemy.children.params.animationInfo": {
                path: {
                    type: "string"
                },
                offsetX: {
                    type: "number"
                },
                offsetY: {
                    type: "number"
                },
                scale: {
                    type: "float"
                },
                usesFixPos: {
                    type: "boolean"
                },
                hpGaugeSize: {
                    type: "number",
                    optional: !0
                }
            },
            "root.battle.rounds.enemy.children.params.abilities": {
                abilityId: {
                    type: "uint"
                },
                weight: {
                    type: "uint"
                },
                unlockTurnNum: {
                    type: "uint"
                },
                tag: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle.rounds.enemy.children.params.counters": {
                abilityId: {
                    type: "uint"
                },
                conditionType: {
                    type: "uint"
                },
                conditionValue: {
                    type: "uint"
                },
                rate: {
                    type: "uint"
                }
            },
            "root.battle.rounds.dropItemList": {
                type: {
                    type: "uint"
                },
                rarity: {
                    type: "uint"
                }
            },
            "root.battle.rounds.enemy.children.dropItemList": {
                type: {
                    type: "uint"
                },
                rarity: {
                    type: "uint"
                },
                amount: {
                    type: "uint",
                    optional: !0
                },
                num: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.buddy": {
                id: {
                    type: "uint"
                },
                dressRecordId: {
                    type: "uint"
                },
                abilities: {
                    type: "array"
                },
                abilityPanels: {
                    type: "array"
                },
                animationInfo: {
                    type: "object"
                },
                initHp: {
                    type: "uint"
                },
                materias: {
                    type: "array"
                },
                maxHp: {
                    type: "uint"
                },
                no: {
                    type: "uint"
                },
                params: {
                    type: "array"
                },
                posId: {
                    type: "string"
                },
                row: {
                    type: "uint"
                },
                soulStrikes: {
                    type: "array"
                },
                soulStrikeGauge: {
                    type: "uint"
                },
                statusAilments: {
                    type: "array",
                    norecursive: !0
                },
                uid: {
                    type: "uint"
                },
                weapon: {
                    type: "object"
                },
                weaponEffect: {
                    type: "object"
                },
                armor: {
                    type: "object",
                    optional: !0,
                    norecursive: !0
                },
                statusBonusFlgOf: {
                    type: "object"
                },
                statusBonusTypeOf: {
                    type: "uint"
                },
                seriesIdMap: {
                    type: "object",
                    optional: !0
                },
                sparePanels: {
                    type: "array",
                    optional: !0
                }
            },
            "root.battle.buddy.materias": {
                slot: {
                    type: "number"
                },
                effectType: {
                    type: "number"
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                }
            },
            "root.battle.buddy.params": {
                acc: {
                    type: "uint"
                },
                atk: {
                    type: "uint"
                },
                atkType: {
                    type: "uint",
                    optional: !0
                },
                critical: {
                    type: "uint"
                },
                def: {
                    type: "uint"
                },
                atkAttributes: {
                    type: "array"
                },
                matkAttributes: {
                    type: "array"
                },
                defAttributes: {
                    type: "array"
                },
                dispName: {
                    type: "string"
                },
                handedness: {
                    type: "string"
                },
                eva: {
                    type: "uint"
                },
                id: {
                    type: "uint"
                },
                level: {
                    type: "uint"
                },
                matk: {
                    type: "uint"
                },
                mdef: {
                    type: "uint"
                },
                mnd: {
                    type: "uint"
                },
                spd: {
                    type: "uint"
                },
                atkSsPointFactor: {
                    type: "number"
                },
                defSsPointFactor: {
                    type: "number"
                }
            },
            "root.battle.buddy.params.atkAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.buddy.params.matkAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.buddy.params.defAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.buddy.animationInfo": {
                left1OffsetX: {
                    type: "number"
                },
                left1OffsetY: {
                    type: "number"
                },
                left2OffsetX: {
                    type: "number"
                },
                left2OffsetY: {
                    type: "number"
                },
                right1OffsetX: {
                    type: "number"
                },
                right1OffsetY: {
                    type: "number"
                },
                right2OffsetX: {
                    type: "number"
                },
                right2OffsetY: {
                    type: "number"
                }
            },
            "root.battle.buddy.weapon": {
                categoryId: {
                    type: "number"
                },
                animationInfo: {
                    type: "object"
                }
            },
            "root.battle.buddy.weapon.animationInfo": {
                id: {
                    type: "uint"
                },
                attackTag: {
                    type: "string"
                },
                equipType: {
                    type: "uint"
                },
                canMove: {
                    type: "uint"
                }
            },
            "root.battle.buddy.armor": {
                categoryId: {
                    type: "number"
                }
            },
            "root.battle.buddy.weaponEffect": {
                animationInfo: {
                    type: "object"
                }
            },
            "root.battle.buddy.weaponEffect.animationInfo": {
                id: {
                    type: "uint"
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string"
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                shot: {
                    type: "string"
                },
                hit: {
                    type: "string"
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint"
                },
                shotType: {
                    type: "uint"
                },
                hitType: {
                    type: "uint"
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint"
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint"
                },
                reverseHit: {
                    type: "uint"
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle.buddy.abilities": {
                abilityId: {
                    type: "uint"
                },
                actionId: {
                    type: "uint"
                },
                exerciseType: {
                    type: "uint"
                },
                categoryId: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object",
                    optional: !0
                },
                options: {
                    type: "object"
                }
            },
            "root.battle.buddy.abilities.animationInfo": {
                id: {
                    type: "uint",
                    optional: !0
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string",
                    optional: !0
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                shot: {
                    type: "string",
                    optional: !0
                },
                hit: {
                    type: "string",
                    optional: !0
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint",
                    optional: !0
                },
                shotType: {
                    type: "uint",
                    optional: !0
                },
                hitType: {
                    type: "uint",
                    optional: !0
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint",
                    optional: !0
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint",
                    optional: !0
                },
                reverseHit: {
                    type: "uint",
                    optional: !0
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                },
                launchSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                shotSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                hitSpriteNum: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.buddy.abilities.options": {
                name: {
                    type: "string"
                },
                aliasName: {
                    type: "string",
                    optional: !0
                },
                panelName: {
                    type: "string",
                    optional: !0
                },
                abilityAnimationId: {
                    type: "uint",
                    optional: !0
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                },
                arg6: {
                    type: "number",
                    optional: !0
                },
                arg7: {
                    type: "number",
                    optional: !0
                },
                arg8: {
                    type: "number",
                    optional: !0
                },
                arg9: {
                    type: "number",
                    optional: !0
                },
                arg10: {
                    type: "number",
                    optional: !0
                },
                targetRange: {
                    type: "uint",
                    optional: !0
                },
                targetSegment: {
                    type: "uint",
                    optional: !0
                },
                targetDeath: {
                    type: "uint",
                    optional: !0
                },
                targetMethod: {
                    type: "uint",
                    optional: !0
                },
                activeTargetMethod: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsId: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsFactor: {
                    type: "uint",
                    optional: !0
                },
                castTime: {
                    type: "uint",
                    optional: !0
                },
                counterEnable: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.buddy.abilityPanels": {
                panelNo: {
                    type: "uint"
                },
                abilityId: {
                    type: "uint"
                },
                num: {
                    type: "uint"
                },
                maxNum: {
                    type: "uint"
                },
                abilitySsPoint: {
                    type: "uint"
                },
                name: {
                    type: "string"
                }
            },
            "root.battle.buddy.sparePanels": {
                receptorId: {
                    type: "uint"
                },
                abilityId: {
                    type: "uint"
                },
                maxNum: {
                    type: "uint"
                },
                abilitySsPoint: {
                    type: "uint"
                },
                name: {
                    type: "string"
                }
            },
            "root.battle.buddy.soulStrikes": {
                abilityId: {
                    type: "uint"
                },
                actionId: {
                    type: "uint"
                },
                slot: {
                    type: "uint"
                },
                exerciseType: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object"
                },
                options: {
                    type: "object"
                }
            },
            "root.battle.buddy.soulStrikes.animationInfo": {
                id: {
                    type: "uint"
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string"
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                shot: {
                    type: "string"
                },
                hit: {
                    type: "string"
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint"
                },
                shotType: {
                    type: "uint"
                },
                hitType: {
                    type: "uint"
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint"
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint"
                },
                reverseHit: {
                    type: "uint"
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                },
                launchSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                shotSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                hitSpriteNum: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.buddy.soulStrikes.options": {
                name: {
                    type: "string"
                },
                aliasName: {
                    type: "string",
                    optional: !0
                },
                dispName: {
                    type: "string",
                    optional: !0
                },
                abilityAnimationId: {
                    type: "string",
                    optional: !0
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                },
                arg6: {
                    type: "number",
                    optional: !0
                },
                arg7: {
                    type: "number",
                    optional: !0
                },
                arg8: {
                    type: "number",
                    optional: !0
                },
                arg9: {
                    type: "number",
                    optional: !0
                },
                arg10: {
                    type: "number",
                    optional: !0
                },
                targetRange: {
                    type: "uint",
                    optional: !0
                },
                targetSegment: {
                    type: "uint",
                    optional: !0
                },
                targetDeath: {
                    type: "uint",
                    optional: !0
                },
                targetMethod: {
                    type: "uint",
                    optional: !0
                },
                activeTargetMethod: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsId: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsFactor: {
                    type: "uint",
                    optional: !0
                },
                castTime: {
                    type: "uint",
                    optional: !0
                },
                counterEnable: {
                    type: "uint",
                    optional: !0
                },
                hasParamBooster: {
                    type: "uint",
                    optional: !0
                },
                consumeSoulStrikePoint: {
                    type: "uint"
                }
            },
            "root.battle.buddy.statusBonusFlgOf": {
                buddy: {
                    type: "uint"
                },
                weapon: {
                    type: "uint"
                },
                armor: {
                    type: "uint"
                },
                accessory: {
                    type: "uint"
                }
            },
            "root.battle.supporter": {
                id: {
                    type: "uint"
                },
                abilities: {
                    type: "array"
                },
                animationInfo: {
                    type: "object"
                },
                maxHp: {
                    type: "uint"
                },
                params: {
                    type: "array"
                },
                soulStrikes: {
                    type: "array"
                },
                uid: {
                    type: "uint"
                },
                weapon: {
                    type: "object"
                },
                weaponEffect: {
                    type: "object"
                },
                statusBonusFlgOf: {
                    type: "object"
                },
                statusBonusTypeOf: {
                    type: "uint"
                },
                supporterSsGauge: {
                    type: "uint"
                },
                maxSupporterSsGauge: {
                    type: "uint"
                },
                sparePanels: {
                    type: "array",
                    optional: !0
                }
            },
            "root.battle.supporter.params": {
                acc: {
                    type: "uint"
                },
                atk: {
                    type: "uint"
                },
                atkType: {
                    type: "uint",
                    optional: !0
                },
                critical: {
                    type: "uint"
                },
                def: {
                    type: "uint"
                },
                atkAttributes: {
                    type: "array"
                },
                matkAttributes: {
                    type: "array"
                },
                defAttributes: {
                    type: "array"
                },
                dispName: {
                    type: "string"
                },
                handedness: {
                    type: "string"
                },
                eva: {
                    type: "uint"
                },
                id: {
                    type: "uint"
                },
                level: {
                    type: "uint"
                },
                matk: {
                    type: "uint"
                },
                mdef: {
                    type: "uint"
                },
                mnd: {
                    type: "uint"
                },
                spd: {
                    type: "uint"
                },
                atkSsPointFactor: {
                    type: "number"
                },
                defSsPointFactor: {
                    type: "number"
                }
            },
            "root.battle.supporter.params.atkAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.supporter.params.matkAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.supporter.params.defAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.supporter.sparePanels": {
                receptorId: {
                    type: "uint"
                },
                abilityId: {
                    type: "uint"
                },
                maxNum: {
                    type: "uint"
                },
                abilitySsPoint: {
                    type: "uint"
                },
                name: {
                    type: "string"
                }
            },
            "root.battle.supporter.animationInfo": {
                left1OffsetX: {
                    type: "number"
                },
                left1OffsetY: {
                    type: "number"
                },
                left2OffsetX: {
                    type: "number"
                },
                left2OffsetY: {
                    type: "number"
                },
                right1OffsetX: {
                    type: "number"
                },
                right1OffsetY: {
                    type: "number"
                },
                right2OffsetX: {
                    type: "number"
                },
                right2OffsetY: {
                    type: "number"
                }
            },
            "root.battle.supporter.weapon": {
                animationInfo: {
                    type: "object"
                }
            },
            "root.battle.supporter.weapon.animationInfo": {
                id: {
                    type: "uint"
                },
                attackTag: {
                    type: "string"
                },
                equipType: {
                    type: "uint"
                },
                canMove: {
                    type: "uint"
                }
            },
            "root.battle.supporter.weaponEffect": {
                animationInfo: {
                    type: "object"
                }
            },
            "root.battle.supporter.weaponEffect.animationInfo": {
                id: {
                    type: "uint"
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string"
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                shot: {
                    type: "string"
                },
                hit: {
                    type: "string"
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint"
                },
                shotType: {
                    type: "uint"
                },
                hitType: {
                    type: "uint"
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint"
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint"
                },
                reverseHit: {
                    type: "uint"
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle.supporter.abilities": {
                abilityId: {
                    type: "uint"
                },
                actionId: {
                    type: "uint"
                },
                exerciseType: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object",
                    optional: !0
                },
                options: {
                    type: "object"
                }
            },
            "root.battle.supporter.abilities.animationInfo": {
                id: {
                    type: "uint",
                    optional: !0
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string",
                    optional: !0
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                shot: {
                    type: "string",
                    optional: !0
                },
                hit: {
                    type: "string",
                    optional: !0
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint",
                    optional: !0
                },
                shotType: {
                    type: "uint",
                    optional: !0
                },
                hitType: {
                    type: "uint",
                    optional: !0
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint",
                    optional: !0
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint",
                    optional: !0
                },
                reverseHit: {
                    type: "uint",
                    optional: !0
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                },
                launchSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                shotSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                hitSpriteNum: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.supporter.abilities.options": {
                name: {
                    type: "string"
                },
                aliasName: {
                    type: "string",
                    optional: !0
                },
                panelName: {
                    type: "string",
                    optional: !0
                },
                abilityAnimationId: {
                    type: "uint",
                    optional: !0
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                },
                arg6: {
                    type: "number",
                    optional: !0
                },
                arg7: {
                    type: "number",
                    optional: !0
                },
                arg8: {
                    type: "number",
                    optional: !0
                },
                arg9: {
                    type: "number",
                    optional: !0
                },
                arg10: {
                    type: "number",
                    optional: !0
                },
                targetRange: {
                    type: "uint",
                    optional: !0
                },
                targetSegment: {
                    type: "uint",
                    optional: !0
                },
                targetDeath: {
                    type: "uint",
                    optional: !0
                },
                targetMethod: {
                    type: "uint",
                    optional: !0
                },
                activeTargetMethod: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsId: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsFactor: {
                    type: "uint",
                    optional: !0
                },
                castTime: {
                    type: "uint",
                    optional: !0
                },
                counterEnable: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.supporter.soulStrikes": {
                abilityId: {
                    type: "uint"
                },
                actionId: {
                    type: "uint"
                },
                exerciseType: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object"
                },
                options: {
                    type: "object"
                }
            },
            "root.battle.supporter.soulStrikes.animationInfo": {
                id: {
                    type: "uint"
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string"
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                shot: {
                    type: "string"
                },
                hit: {
                    type: "string"
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint"
                },
                shotType: {
                    type: "uint"
                },
                hitType: {
                    type: "uint"
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint"
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint"
                },
                reverseHit: {
                    type: "uint"
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                },
                launchSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                shotSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                hitSpriteNum: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.supporter.soulStrikes.options": {
                name: {
                    type: "string"
                },
                aliasName: {
                    type: "string",
                    optional: !0
                },
                dispName: {
                    type: "string",
                    optional: !0
                },
                abilityAnimationId: {
                    type: "string",
                    optional: !0
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                },
                arg6: {
                    type: "number",
                    optional: !0
                },
                arg7: {
                    type: "number",
                    optional: !0
                },
                arg8: {
                    type: "number",
                    optional: !0
                },
                arg9: {
                    type: "number",
                    optional: !0
                },
                arg10: {
                    type: "number",
                    optional: !0
                },
                targetRange: {
                    type: "uint",
                    optional: !0
                },
                targetSegment: {
                    type: "uint",
                    optional: !0
                },
                targetDeath: {
                    type: "uint",
                    optional: !0
                },
                targetMethod: {
                    type: "uint",
                    optional: !0
                },
                activeTargetMethod: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsId: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsFactor: {
                    type: "uint",
                    optional: !0
                },
                castTime: {
                    type: "uint",
                    optional: !0
                },
                counterEnable: {
                    type: "uint",
                    optional: !0
                },
                consumeSoulStrikePoint: {
                    type: "uint"
                }
            },
            "root.battle.supporter.statusBonusFlgOf": {
                buddy: {
                    type: "uint"
                },
                weapon: {
                    type: "uint"
                },
                armor: {
                    type: "uint"
                },
                accessory: {
                    type: "uint"
                }
            },
            "root.battle.buddy.seriesIdMap": {
                buddy: {
                    type: "uint"
                },
                weapon: {
                    type: "uint"
                },
                armor: {
                    type: "uint"
                },
                accessory: {
                    type: "uint"
                }
            },
            "root.battle.score": {
                general: {
                    type: "array"
                },
                specific: {
                    type: "array"
                }
            },
            "root.battle.score.general": {
                no: {
                    type: "uint"
                },
                type: {
                    type: "uint"
                },
                arg1: {
                    type: "string",
                    optional: !0
                },
                arg2: {
                    type: "string",
                    optional: !0
                },
                arg3: {
                    type: "string",
                    optional: !0
                },
                arg4: {
                    type: "string",
                    optional: !0
                },
                arg5: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle.score.specific": {
                no: {
                    type: "uint"
                },
                type: {
                    type: "uint"
                },
                arg1: {
                    type: "string",
                    optional: !0
                },
                arg2: {
                    type: "string",
                    optional: !0
                },
                arg3: {
                    type: "string",
                    optional: !0
                },
                arg4: {
                    type: "string",
                    optional: !0
                },
                arg5: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle.messages": {
                id: {
                    type: "uint"
                },
                message: {
                    type: "string"
                },
                type: {
                    type: "uint"
                },
                arg1: {
                    type: "uint",
                    optional: !0
                },
                arg2: {
                    type: "uint",
                    optional: !0
                },
                displayType: {
                    type: "uint"
                }
            }
        },
        i = {
            talks: {
                type: "object",
                norecursive: !0
            }
        };
    FF.ns.battle.BattleInitData = t.extend({
        initialize: function(e) {
            t.prototype.initialize.call(this), this._attributes = {
                original: e
            }, FF.env.isTutorial() && (r.root.tutorial = {
                type: "object"
            }, r["root.tutorial"] = i)
        },
        validate: function() {
            var e = this.get("original"),
                t = n.camelizeDeep(e);
            return t.assets = n.cloneDeep(e.assets), t.battle.assets = n.cloneDeep(e.battle.assets), this._validate("root", "root", t), t
        },
        _validate: function(t, n, i, s) {
            if (s && s.norecursive) return;
            if (!r[t]) throw new Error("invalid schema." + t);
            var o, u, a, f, l;
            if (s && s.type === "array") {
                f = i.splice(0, i.length);
                for (u = 0, a = f.length; u < a; u++) o = e(r[t], f[u], {
                    message: t + "." + u
                }), i.push(o.valid());
                l = i
            } else s && s.optional && !i ? i = {} : (o = e(r[t], i, {
                message: t
            }), _.extend(i, o.valid())), l = [i];
            _.each(r[t], function(e, n) {
                var r = t + "." + n;
                for (u = 0, a = l.length; u < a; u++)(e.type === "array" || e.type === "object") && this._validate(r, n, l[u][n], e)
            }, this)
        }
    })
}), define("scenes/battle/BattleLog", ["lib/EventBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = 1e4,
        i = e.extend({
            initialize: function(e) {
                this._results = {
                    action_num: 0,
                    supporter_ss_use_num: 0,
                    buddy_damage: 0,
                    enemy_damage: 0,
                    continue_infos: [],
                    fps: []
                }, this._elapsedTimeFps = 0, this.listenTo(t.ActorMgr, "ActorBase::addDamage", this._onDamage), this.listenTo(t.ActorMgr, "ActorBase::entryInAction", this._onEntryInAction), this.listenTo(t.ActorMgr, "ActorMgr::resetBuddiesForContinue", this._onContinue)
            },
            _onDamage: function(e, t) {
                var n = t.executer,
                    r = t.receiver,
                    i = t.actualDamage || 0;
                if (!n || !r) return;
                n.isBuddy() && r.isEnemy() && i > 0 ? this._results.buddy_damage += i : n.isEnemy() && r.isBuddy() && i > 0 && (this._results.enemy_damage += i)
            },
            _onEntryInAction: function(e) {
                e.isBuddy() && (this._results.action_num++, this._recordSupporterSsUseNum(e))
            },
            _recordSupporterSsUseNum: function(e) {
                var t = e.getAbility();
                t && t.get("isSupporterSoulStrike") && this._results.supporter_ss_use_num++
            },
            _onContinue: function() {
                var e = t.BattleInfo.getInstance().getLastContinueTxn();
                this._results.continue_infos.push(e.makeResultData())
            },
            _recordFps: function() {
                var e = this;
                if (!FF.env.isNative()) return;
                if (this._results.fps.length >= 20) return;
                kickmotor.nativefn.getFrameRate(function(t) {
                    e._results.fps.push(t.fps || 0)
                })
            },
            _makeFpsData: function() {
                var e = this._results.fps;
                if (e.length === 0) return 0;
                var t = 0;
                return _.each(e, function(e) {
                    t += e
                }), Math.floor(t / e.length)
            },
            makeResultData: function() {
                var e = t.BattleInfo.getInstance().get("actionTime"),
                    n = t.EnemyPartyMgr.getInstance().makeResultData();
                return _.extend({}, this._results, {
                    action_time: Math.floor(e / 1e3) || 0,
                    all_enemy_info: n.all,
                    enemy_info: n.current,
                    fps: this._makeFpsData()
                })
            },
            update: function() {
                this._elapsedTimeFps += FF.scene.elapsedTime, this._elapsedTimeFps >= r && (this._recordFps(), this._elapsedTimeFps = 0)
            },
            toPlainObject: function() {
                return this._results
            },
            applyPlainObject: function(e) {
                if (!e) return;
                _.extend(this._results, e)
            }
        }),
        s = void 0,
        o = void 0;
    FF.ns.battle.BattleLog = {
        load: function() {
            o = new i
        },
        toPlainObject: function() {
            return o.toPlainObject()
        },
        applyPlainObject: function(e) {
            return o.applyPlainObject(e)
        },
        makeResultData: function() {
            return o.makeResultData()
        },
        update: function() {
            if (o) return o.update()
        }
    }
}), define("scenes/battle/BattleProcessMgr", ["jquery", "util", "lib/Battle", "lib/BattleConfig", "lib/BattleStorage", "lib/Storage", "lib/NameConventionFsm"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle;
    FF.ns.battle.BattleProcessMgr = o.extend({
        initialize: function() {
            o.prototype.initialize.call(this);
            var e = this,
                t = u.BattleInfo.getInstance(),
                n = t.getBattleInitData();
            u.Score.load(n.battle.score), u.BattleLog.load(), t.set("round", 1), this.battleFsm = new u.BattleFsm, this.preBattleFsm = new u.PreBattleFsm, this.battleResultFsm = new u.BattleResultFsm, this.continueFsm = new u.ContinueFsm, this.continueFsm.setParent(this), this._isSetTouchEventOnceDone = !1, u.BuddyPartyMgr.getInstance().setParent(this), u.EnemyPartyMgr.getInstance().setParent(this), this.changeState("LOAD_BATTLE")
        },
        processForStateLoadBattleEntry: function() {
            var e = this,
                t = u.BattleInfo.getInstance(),
                n = u.BuddyPartyMgr.getInstance();
            this.setAuto(t.isAutoEnabledAtBattleStart()), u.EnemyPartyMgr.getInstance().load(t.getBattleInitData().battle), u.ActorMgr.registerBuddy(t.getBuddyParams()), u.ActorMgr.registerSupporter(t.getSupporterParams()), this.loadResumeData(), this.loadPersistentBattleDataDeferred().then(function() {
                e.changeState("SETUP")
            })
        },
        processForStateSetupEntry: function() {
            var e = this;
            this.setupNewBattle(), this._isDoneSave = !1, this.saveResumeDataDeferred().then(function() {
                return FF.scene.saveBattleConfigDeferred()
            }).then(function() {
                return e.savePersistentBattleDataDeferred()
            }).then(function() {
                e._isDoneSave = !0
            })
        },
        processForStateSetupUpdate: function() {
            this._isDoneSave && this.changeState("PRE_BATTLE")
        },
        processForStatePreBattleEntry: function() {
            this.preBattleFsm.changeState("APPEARANCE")
        },
        processForStatePreBattleUpdate: function() {
            this.preBattleFsm.isState("END") ? this.changeState("IN_BATTLE") : this.preBattleFsm.update()
        },
        setupNewBattle: function() {
            var e = u.BattleInfo.getInstance();
            e.reset(), this._setRoundRevertObjectIfNeed(), this._applyRoundRevertObject();
            var t = e.get("round");
            FF.logger.debug("\n--------- start round " + t + " ---------"), u.ActorMgr.clearEnemy(), u.ActorMgr.clearActiveTarget();
            var n = e.getBattleParam();
            u.ActorMgr.registerEnemy(n.enemy), _.each(u.ActorMgr.getAll(), function(e) {
                e.setupNewBattle(), e.materiaHolder.notify(u.Conf.MATERIA_NOTIFY_TYPE.SETUP_ROUND, {
                    round: t
                })
            }), this.fixEnemyPosId(u.ActorMgr.getAliveEnemyContainers()), u.AbilityMgr.getInstance().reset(), u.BattleViewController.getInstance().setupNewBattle(), this._setTouchEventBySetupNewBattle(), FF.SoundMgr.playMusic(n.bgm)
        },
        processForStateInBattleEntry: function() {
            u.BattleInfo.getInstance().set("isInBattle", !0)
        },
        processForStateInBattleUpdate: function() {
            if (this._checkIsExpired()) {
                this.changeState("EXPIRE");
                return
            }
            u.BattleInfo.getInstance().addActionTime(FF.scene.elapsedTime), u.BuddyPartyMgr.getInstance().update(), u.EnemyPartyMgr.getInstance().update(), this.battleFsm.update(), u.Debug.update(), this.battleFsm.isState("END") && (u.BattleInfo.getInstance().isLose() ? this.changeState("IN_CONTINUE") : this.changeState("IN_RESULT"))
        },
        processForStateInBattleExit: function() {
            u.BattleInfo.getInstance().set("isInBattle", !1)
        },
        processForStateInResultEntry: function() {
            this.battleResultFsm.begin()
        },
        processForStateInResultUpdate: function() {
            var e = u.BattleInfo.getInstance();
            this.battleResultFsm.update(), this.battleResultFsm.isState("END") && (u.EnemyPartyMgr.getInstance().activeTarget.resetSelected(), e.get("isClear") ? this.changeState("END") : e.isVictory() ? this.enterNextBattle() : this.changeState("END"))
        },
        processForStateInContinueEntry: function() {
            this.continueFsm.begin()
        },
        processForStateInContinueUpdate: function() {
            this.continueFsm.update(), this.continueFsm.isState("RETIRE") ? this.changeState("IN_RESULT") : this.continueFsm.isState("CONTINUE") ? this.enterSameBattleForContinue() : this.continueFsm.isState("EXPIRE") && this.changeState("EXPIRE")
        },
        processForStateEndEntry: function() {
            this.removeData(), FF.scene.saveBattleConfigDeferred(), u.BattleInfo.getInstance().set("isAllEnded", !0)
        },
        processForStateExpireEntry: function() {
            this.expireFsm = new u.ExpireFsm
        },
        processForStateExpireUpdate: function() {
            this.expireFsm.update()
        },
        enterNextBattle: function() {
            var e = u.BattleInfo.getInstance();
            e.set("round", 1 + e.get("round")), this.battleFsm.changeState("IDLE"), this.battleResultFsm.changeState("IDLE"), this.changeState("SETUP")
        },
        enterSameBattleForContinue: function() {
            this.battleFsm.changeState("IDLE"), this.battleResultFsm.changeState("IDLE"), this.continueFsm.changeState("IDLE"), u.AbilityMgr.getInstance().reset(), u.Message.reset();
            var e = u.BattleInfo.getInstance().get("roundRevertObject");
            e.isNeedToResetForContinue = !0, this.changeState("SETUP")
        },
        loadPersistentBattleDataDeferred: function() {
            var t = e.Deferred();
            return s.getItem("persistentBattle", function(e) {
                var n = e.result ? JSON.parse(e.value) : {};
                u.BuddyPartyMgr.getInstance().set("lastReceptorInfo", n.lastReceptorInfo || {}), t.resolve()
            }), t.promise()
        },
        savePersistentBattleDataDeferred: function() {
            var t = {
                    lastReceptorInfo: u.BuddyPartyMgr.getInstance().get("lastReceptorInfo")
                },
                n = e.Deferred(),
                r = JSON.stringify(t);
            return s.setItem("persistentBattle", r, function(e) {
                n.resolve()
            }), n.promise()
        },
        saveResumeDataDeferred: function() {
            var e = this.toPlainObject();
            return i.getInstance().setResumeData(e), i.getInstance().saveDeferred()
        },
        loadResumeData: function() {
            var e = i.getInstance().getResumeData();
            this.applyPlainObject(e)
        },
        removeData: function() {
            i.removeDataDeferred()
        },
        _setRoundRevertObjectIfNeed: function() {
            var e = u.BattleInfo.getInstance(),
                n = e.get("round"),
                r = e.get("roundRevertObject");
            if (r && r.round === n) return;
            var i = t.cloneDeep({
                buddyPartyMgr: u.BuddyPartyMgr.getInstance().toPlainObject(),
                score: u.Score.toPlainObject(),
                round: n
            });
            u.BattleInfo.getInstance().set("roundRevertObject", i)
        },
        _applyRoundRevertObject: function() {
            var e = u.BattleInfo.getInstance(),
                n = e.get("round"),
                r = u.BattleInfo.getInstance().get("roundRevertObject");
            if (!r) throw new Error("roundRevertObject not found");
            var i = r.round;
            if (n !== i) throw new Error("invalid round (current:%d, revert:%d)", n, i);
            var s = t.cloneDeep(e.get("roundRevertObject"));
            u.BuddyPartyMgr.getInstance().applyPlainObject(s.buddyPartyMgr), u.Score.applyPlainObject(s.score), !s.isNeedToResetForContinue || (u.Score.resetForContinue(), s.isNeedToResetForContinue = !1)
        },
        fixEnemyPosId: function(e) {
            var t = _.filter(e, function(e) {
                    return e.isSpEnemy()
                }),
                n = _.filter(e, function(e) {
                    return !e.isSpEnemy()
                });
            if (t.length > 1) throw new Error("invalid sp enemy num." + t.length);
            _.each(t, function(e) {
                e.set("posId", "5_03"), _.each(e.getChildren(), function(e) {
                    e.set("posId", "5_03")
                })
            });
            var r = {
                    1: ["1_01"],
                    2: ["2_01", "2_02"],
                    3: ["5_01", "5_05", "1_01"],
                    4: ["5_01", "5_02", "4_03", "4_04"],
                    5: ["5_01", "5_02", "5_03", "5_04", "5_05"]
                },
                i = _.sortBy(n, function(e) {
                    var t = e.getChildren();
                    return t[0].getSize()
                });
            _.each(i, function(e, t) {
                var n = e.getChildren(),
                    s = r[i.length][t];
                e.set("posId", s), _.each(e.getChildren(), function(e) {
                    e.set("posId", s), e.set("childPosId", 1)
                })
            })
        },
        setAuto: function(e) {
            var t = u.BattleViewController.getInstance();
            u.BattleInfo.getInstance().set("isInAutoBattle", e), t.showAutoButton(e), e && u.ActorMgr.clearActiveTarget()
        },
        _setTouchEventOnce: function() {
            var e = this,
                t = u.BattleViewController.getInstance();
            t.setAutoButtonTouch(function() {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                FF.SoundMgr.playChooseEffect(), e.setAuto(!u.BattleInfo.getInstance().get("isInAutoBattle"))
            }), t.setSkipButtonTouch(function(e) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                var n = u.ActorMgr.getAbilityPanelSelector();
                if (!n || !e) return;
                if (!n.equals(u.ActorMgr.getByUid(e))) return;
                var r = u.Conf.RECEPTOR.SKIP;
                u.BuddyPartyMgr.getInstance().reserveAbility(n, r) && (FF.SoundMgr.playChooseEffect(), u.ActorMgr.clearActiveTarget(), t.clearCursor(), t.hideAbilityPanel())
            }), t.setSoulStrikeTouch(function(e) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                var n = u.ActorMgr.getAbilityPanelSelector();
                if (!n || !e) return;
                if (!n.equals(u.ActorMgr.getByUid(e))) return;
                var r = u.Conf.RECEPTOR.SOUL_STRIKE;
                u.BuddyPartyMgr.getInstance().reserveAbility(n, r) && (FF.SoundMgr.playChooseEffect(), t.hideAbilityPanel())
            }), t.setSoulStrikePanelTouch(function(e, n) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                var r = u.ActorMgr.getAbilityPanelSelector();
                if (!r || !e) return;
                if (!r.equals(u.ActorMgr.getByUid(e))) return;
                var i = u.Config.getInstance().get("SoulStrikePanels", n);
                u.BuddyPartyMgr.getInstance().reserveAbility(r, i) ? (FF.SoundMgr.playChooseEffect(), t.hideAbilityPanel()) : t.cancelSoulStrikePanelTouch()
            }), t.setPanelTouch(function(e, n) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                var r = u.ActorMgr.getAbilityPanelSelector();
                if (!r || !e) return;
                if (!r.equals(u.ActorMgr.getByUid(e))) return;
                var i = r.getAbilityPanelReceptorByPanelNo(n);
                u.BuddyPartyMgr.getInstance().reserveAbility(r, i.get("receptorId")) && (FF.SoundMgr.playChooseEffect(), u.ActorMgr.clearActiveTarget(), t.clearCursor(), t.hideAbilityPanel())
            }), t.setBuddyTouch(function(e) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                if (u.BattleInfo.getInstance().get("isInAutoBattle")) return;
                var t = u.ActorMgr.getAbilityPanelSelector();
                if (!t) return;
                u.ActorMgr.toggleActiveTarget(e), u.BattleViewController.getInstance().updateActiveTarget()
            }), t.setSupporterButtonTouch(function() {
                var e = u.BuddyPartyMgr.getInstance();
                if (!e.canReceptSupporterSoulStrike()) return;
                e.reserveSupporterSoulStrike() && (FF.SoundMgr.playChooseEffect(), u.ActorMgr.clearActiveTarget(), t.clearCursor(), t.hideAbilityPanel())
            }), t.menuWindowView.setBattleSpeedTouch(function(e) {
                u.BattleInfo.getInstance().setBattleSpeedIndex(e)
            });
            var n = !1;
            t.setDebugTouch(function() {
                u.Debug.toggleInfo()
            }), t.setDebugTouchMoved(function() {
                u.Debug.increaseSsGauge()
            }), t.setDebugTouch1(function() {
                u.Debug.redirectDebugScene()
            }), t.setDebugTouch2(function() {
                u.Debug.killEnemies()
            })
        },
        _setTouchEventBySetupNewBattle: function() {
            var e = u.BattleViewController.getInstance();
            e.setEnemyTouch(function(e) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                if (u.BattleInfo.getInstance().get("isInAutoBattle")) return;
                var t = u.ActorMgr.getAbilityPanelSelector();
                if (!t) return;
                u.ActorMgr.toggleActiveTarget(e), u.BattleViewController.getInstance().updateActiveTarget()
            }), this._isSetTouchEventOnceDone || (this._setTouchEventOnce(), this._isSetTouchEventOnceDone = !0)
        },
        _checkIsExpired: function() {
            var e = u.BattleInfo.getInstance().getExpiredAt(),
                n = t.getTimeAsSec();
            return n += FF.scene._debugExpired || 0, n >= e
        },
        toPlainObject: function() {
            var e = u.BattleInfo.getInstance(),
                t = {};
            _.each(u.ActorMgr.getAllBuddies(), function(e) {
                t[e.getUid()] = e.toPlainObject()
            });
            var n = u.ActorMgr.getSupporter();
            return {
                battleInfo: e.toPlainObject(),
                buddies: t,
                supporter: n ? n.toPlainObject() : void 0,
                buddyPartyMgr: u.BuddyPartyMgr.getInstance().toPlainObject(),
                score: u.Score.toPlainObject(),
                log: u.BattleLog.toPlainObject()
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            u.BattleInfo.getInstance().applyPlainObject(e.battleInfo), u.BuddyPartyMgr.getInstance().applyPlainObject(e.buddyPartyMgr), u.Score.applyPlainObject(e.score), u.BattleLog.applyPlainObject(e.log), _.each(e.buddies, function(e, t) {
                var n = u.ActorMgr.getByUid(t);
                n.applyPlainObject(e)
            });
            if (!!e.supporter) {
                var t = u.ActorMgr.getSupporter();
                t.applyPlainObject(e.supporter)
            }
        }
    })
}), define("scenes/battle/BattleResultFsm", ["lib/BattleStorage", "lib/NameConventionFsm"], function(e, t) {
    var n = FF.ns.battle,
        r = 2e3;
    FF.ns.battle.BattleResultFsm = t.extend({
        initialize: function() {
            t.prototype.initialize.call(this), this.changeState("IDLE"), _.bindAll(this, "_onTransitionEnd")
        },
        begin: function() {
            var e = n.BattleInfo.getInstance();
            if (e.get("isClear")) this.changeState("CLEAR");
            else if (e.isVictory()) this.changeState("TRANSITION");
            else if (e.isLose()) this.changeState("LOSE");
            else {
                if (!e.isForceEscape()) throw new Error("invalid judge");
                this.changeState("ESCAPE")
            }
        },
        processForStateTransitionEntry: function() {
            this._isTransitionDone = !1;
            var e = n.BattleInfo.getInstance().getNextBattleParam(),
                t = n.BattleViewController.getInstance().createAnimation({
                    animationType: n.Conf.ANIMATION_TYPE.TRANSITION,
                    buddyTransitType: e.buddyTransitType,
                    backgroundChangeType: e.backgroundChangeType,
                    buddies: n.ActorMgr.getAllBuddies()
                });
            t.addCallbackOnce("end", this._onTransitionEnd), t.play()
        },
        _onTransitionEnd: function() {
            this._isTransitionDone = !0
        },
        processForStateTransitionUpdate: function() {
            this._isTransitionDone && this.changeState("END")
        },
        processForStateClearEntry: function() {
            var e = this,
                t = this._makeWinResult(),
                i = this.b(),
                s = this.c();
            if (!FF.env.isNative()) {
                this.changeState("END");
                return
            }
            n.BattleViewController.getInstance().startVictory();
            var o = this.d(),
                u = JSON.stringify(t),
                a = Chara.GOLBEZ.banish(u, o).toString(),
                f = function() {
                    return n.Api.battleWinDeferred(a, function(e) {
                        return Chara.ZEROMUS(e + i, s).toString()
                    }, {
                        retryCount: 1
                    })
                };
            n.RemoteLogger.logRemoteNotificationIfNeedDeferred();
            var l = $.when(f(), n.util.DelayCallback.registerDeferred(r)).then(function(t) {
                FF.logger.debug("BATTLE RESULT", t[0]), e.changeState("END"), n.BattleInfo.getInstance().set("resultInfo", {
                    isVictory: !0,
                    data: t[0]
                })
            })
        },
        processForStateLoseEntry: function() {
            var e = this,
                t = this._makeLoseResult(),
                i = this.b(),
                s = this.c();
            if (!FF.env.isNative()) {
                this.changeState("END");
                return
            }
            var o = this.d(),
                u = JSON.stringify(t),
                a = Chara.GOLBEZ.banish(u, o).toString(),
                f = function() {
                    return n.Api.battleLoseDeferred(a, function(e) {
                        return Chara.ZEROMUS(e + i, s).toString()
                    }, {
                        retryCount: 1
                    })
                };
            n.RemoteLogger.logRemoteNotificationIfNeedDeferred();
            var l = $.when(f(), n.util.DelayCallback.registerDeferred(r)).done(function(t) {
                e.changeState("END"), n.BattleInfo.getInstance().set("resultInfo", {
                    isVictory: !1,
                    data: t[0]
                })
            })
        },
        processForStateEscapeEntry: function() {
            var e = this,
                t = $.when(this.constructor.sendEscapeResultDeferred(), n.util.DelayCallback.registerDeferred(r)).done(function(t) {
                    e.changeState("END"), n.BattleInfo.getInstance().set("resultInfo", {
                        data: t[0]
                    })
                })
        },
        _makeWinResult: function() {
            var e = {};
            return _.extend(e, n.BuddyPartyMgr.getInstance().makeResultData()), e.score = n.Score.makeResultData(), e.log = n.BattleLog.makeResultData(), e.initChkResult = n.BattleInfo.getInstance().getBattleInitData().initChkResult ? 1 : 0, e.session_key = n.BattleInfo.getInstance().getAppInitDataSessionKey(), this._setParameterSnapshot(e), FF.logger.info("RESULT", JSON.stringify(e)), e
        },
        _makeLoseResult: function() {
            var e = {},
                t = n.ActorMgr.getAliveEnemyContainers();
            return e.enemy_ids = _.map(t, function(e) {
                return e.getId()
            }), e.log = n.BattleLog.makeResultData(), e.initChkResult = n.BattleInfo.getInstance().getBattleInitData().initChkResult ? 1 : 0, e.session_key = n.BattleInfo.getInstance().getAppInitDataSessionKey(), e
        },
        _setParameterSnapshot: function(e) {
            if (!FFEnv.chkParameter) return;
            e.cup = {
                srqc: n.ParameterEncoder.snapshotRequest(e)
            };
            if (e.initChkResult) return;
            e.cup.srsc = n.BattleInfo.getInstance().getBattleInitData().resClientSnapshot, e.cup.srss = n.BattleInfo.getInstance().getBattleInitData().battle.resServerSnapshot
        },
        b: function() {
            return this.constructor.b()
        },
        c: function() {
            return this.constructor.c()
        },
        d: function() {
            return this.constructor.d()
        }
    }, {
        sendEscapeResultDeferred: function() {
            var e = this,
                t = this._makeEscapeResult(),
                r = this.b(),
                i = this.c(),
                s = this.d(),
                o = JSON.stringify(t),
                u = Chara.GOLBEZ.banish(o, s).toString(),
                a = function() {
                    return n.Api.battleEscapeDeferred(u, function(e) {
                        return Chara.ZEROMUS(e + r, i).toString()
                    }, {
                        retryCount: 1
                    })
                };
            return n.RemoteLogger.logRemoteNotificationIfNeedDeferred(), a()
        },
        _makeEscapeResult: function() {
            var e = {};
            return _.extend(e, n.BuddyPartyMgr.getInstance().makeResultData()), e.log = n.BattleLog.makeResultData(), e.initChkResult = n.BattleInfo.getInstance().getBattleInitData().initChkResult ? 1 : 0, e.session_key = n.BattleInfo.getInstance().getAppInitDataSessionKey(), FF.logger.info("RESULT", JSON.stringify(e)), e
        },
        b: function() {
            return FF.env.b
        },
        c: function() {
            return FF.env.c
        },
        d: function() {
            return FF.env.f
        }
    })
}), define("scenes/battle/BattleViewController", ["jquery", "sprintf", "lib/ab/AssetsManager", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/Events", "lib/EventBase", "lib/BattleStorage", "components/Loading", "components/Overlay"], function(e, t, n, r, i, s, o, u, a, f) {
    var l = FF.ns.battle,
        c = {
            initialize: function() {
                o.prototype.initialize.call(this), this._isBuddyInitialized = !1, FF.logger.debug("BattleView: initialize"), this.overlay = new f({
                    el: e(".overlay")
                }), this.loading = new a({
                    el: e(".loading")
                }), this.overlay.registerChildren(this.loading), this.assetsManager = new n, this.battleLayer = null, this.rootNodes = [], this.ignoreSuspendLayers = [], this.messageView = void 0, this.soulStrikeView = void 0, this.backgroundView = void 0, this.commandView = void 0, this.buddyViews = {}, this.buddyCommonAssetId = "player_common", this.forceLayerName = "layer_bg-force_01", this.enemyContainers = {}, this.tutorialBattleView = void 0, this.isAnimating = !1, this._targetUid = void 0, this._fingerPosId = void 0, this._cursorPosInfo = {}, this._specialMessage = void 0, this._cbTouchAbscreen = void 0, this._setupAbscreenTouchEvent(), this._isTouchedPause = !1, this._canStartPause = !0, this._canStartPauseBySoulStrikeView = !0, this._canStartPauseBySoulStrikeSelector = !0, FF.env.isUsingWWBackKeyHandler() && this.listenTo(kickmotor.nativefn.onBackKeyHandler, "System::onBackKey", this._onBackKey)
            },
            _setupAbscreenTouchEvent: function() {
                var e = this,
                    t = "BattleViewController::ABScreen::ActionTouchEnded",
                    n = kickmotor.nativefn.registerCallback(function() {
                        e.trigger(t)
                    });
                kickmotor.animation.processAnimation([{
                    exec: "addCallback",
                    layer: "ABScreen",
                    callback: n,
                    event: "action_touch_ended",
                    autoDelete: !0
                }]), this.listenTo(this, t, this._onTouchAbscreen)
            },
            _onTouchAbscreen: function() {
                _.isFunction(this._cbTouchAbscreen) && this._cbTouchAbscreen()
            },
            loadDeferred: function(e) {
                var t = this,
                    n = e.battle.assets || {};
                return this.assetsManager.populateAssetsDeferred(e.assets, {
                    restriction: n,
                    isPreloadEffect: !0
                }).then(function() {
                    t.loadLayer(), t.setRootNodesVisible(!1), t.drawView(e)
                })
            },
            loadViewDeferred: function() {
                FF.logger.debug("BattleView: loadView");
                var t = this,
                    n = {
                        isDummy: !0,
                        battle: {
                            background: {
                                assetId: "bg-10001"
                            }
                        }
                    },
                    r = e.Deferred();
                return this.loadAssetsDeferred().then(function() {
                    t.loadLayer(), t.drawView(n), r.resolve()
                }), r.promise()
            },
            loadAssetsDeferred: function() {
                FF.logger.debug("BattleView: loadAssetsDeferred");
                var t = this,
                    n = e.Deferred(),
                    r = "../debug/get_battle_init_data";
                r += "?dungeon_id=1&battle_id=1";
                var i = e.ajax({
                    url: r,
                    dataType: "json"
                });
                return i.then(function(e) {
                    return FF.logger.debug(e), t.assetsManager.populateAssetsDeferred(e.assets)
                }).then(n.resolve), n.promise()
            },
            loadLayer: function() {
                FF.logger.debug("BattleView: loadLayer");
                var e = "battle_field",
                    t = this.assetsManager.getAssetInfo(e);
                this.battleLayer = new i({
                    layerName: t.layerName
                }), _.each(this.assetsManager.layerNames, function(e) {
                    var t = new r({
                        name: "AnimationBuilderRoot",
                        layer: e
                    });
                    this.rootNodes.push(t)
                }, this), this.battleLayer.activate()
            },
            activateNativeTouch: function() {
                kickmotor.nativefn.call("setIsEnableTouchEvent", {
                    isEnable: !0,
                    isEnableScreen: !0
                })
            },
            deactivateABScreen: function() {
                kickmotor.nativefn.call("setIsEnableTouchEvent", {
                    isEnableScreen: !1
                })
            },
            drawView: function(e) {
                FF.logger.debug("BattleView: drawView");
                var t = this;
                FF.env.isDevelop() && kickmotor.nativefn.call("showTouchArea", {
                    isShow: !1
                }), this.materiaDropView = new l.view.MateriaDropView({
                    battleViewController: this
                }), this.menuWindowView = new l.view.MenuWindowView({
                    battleViewController: this
                }), this.loadingView = new l.view.LoadingView({
                    battleViewController: this
                });
                var n = this.battleLayer.createNode("pause_btn_nul"),
                    r = n.createChildNode("pause_btn_visible_touch");
                r.addCallback("action_touch_began", function() {
                    if (l.DataConstructor.isAllEnded()) return;
                    t.startPause()
                }).process(), this.messageView = new l.view.MessageView({
                    battleViewController: this
                }), this.messageView.hide(), this.backgroundView = new l.view.BackgroundView({
                    battleViewController: this,
                    backgroundInfo: e.battle.background
                }), this.commandView = new l.view.CommandView({
                    battleViewController: this
                }), this.commandView.setSoulStrikeSelectorVisibleChangeHandler(_.bind(this._updateSupporterViewControllerVisible, this)), this.shakeBackgroundNode = this.battleLayer.createNode("shake_part_nul"), this.shakeAllNode = this.battleLayer.createNode("shake_all_nul"), this.flashNode = this.battleLayer.createNode("flash_nul"), this.specialMessageNode = this.battleLayer.createNode("special_name_nul"), this.blackOutNode = this.battleLayer.createNode("black_out_win"), this.shouldPlayForceEffect(e) && this.playForceEffect(), this.targetArrowView = new l.view.TargetArrowView({
                    battleViewController: this
                }), this.supporterViewController = new l.SupporterViewController({
                    battleViewController: this
                }), this._supporterViewCanBeVisible = !1, this._supporterViewShown = void 0, this._drawHeader(), this.loading.hide(), this.activateNativeTouch(), FF.logger.debug("BattleView: drawView")
            },
            shouldPlayForceEffect: function(e) {
                return e.battle.dungeon.isForce ? !0 : !1
            },
            _drawHeader: function() {
                this.setTreasureNum(0), this.setOrbNum(0), this.setGilNum(0), this.setEventItemImg(), this.setEventItemNum(0)
            },
            setupNewBattle: function() {
                FF.logger.debug("BattleView: setupNewBattle"), this.removeEnemyContainers(), this._isBuddyInitialized || (this.updateBuddy(), this._isBuddyInitialized = !0), this.updateEnemy(), this.setGilNum(l.DataConstructor.getGil()), this.setOrbNum(l.DataConstructor.getOrb()), this.setTreasureNum(l.DataConstructor.getTreasure()), this.setEventItemNum(l.DataConstructor.getEventItem()), this.updateBackgroundIdle(), this.setRootNodesVisible(!0)
            },
            setBuddyTouch: function(e) {
                _.each(this.buddyViews, function(t) {
                    t.setTouchBegan(e)
                })
            },
            setEnemyTouch: function(e) {
                _.each(this.enemyContainers, function(t) {
                    t.setTouchBegan(e)
                })
            },
            setSoulStrikeTouch: function(e) {
                this.commandView.setSpecialTouch(e)
            },
            setSoulStrikePanelTouch: function(e) {
                this.commandView.setSpecialPanelTouch(e)
            },
            setAutoButtonTouch: function(e) {
                this.commandView.setAutoTouch(e)
            },
            setSkipButtonTouch: function(e) {
                this.commandView.setSkipTouch(e)
            },
            setPanelTouch: function(e) {
                this.commandView.setTouch(e)
            },
            setSupporterButtonTouch: function(e) {
                this.supporterViewController.setButtonTouch(e)
            },
            setDebugTouch: function(e) {
                if (FF.env.isDevelop()) {
                    var t = this.battleLayer.createNode("dev_btn_nul");
                    t.addCallback("action_touch_ended", e).process();
                    var n = this.battleLayer.createNode("debug_nul");
                    n.setText("debug_txt", "").setVisible(!0).process()
                }
            },
            setDebugTouchMoved: function(e) {
                if (FF.env.isDevelop()) {
                    var t = this.battleLayer.createNode("dev_btn_nul");
                    t.addCallback("action_touch_moved", e).process()
                }
            },
            setDebugTouch1: function(e) {
                if (FF.env.isDevelop()) {
                    var t = this.battleLayer.createNode("dev_btn_nul_1");
                    t.addCallback("action_touch_ended", e).process()
                }
            },
            setDebugTouch2: function(e) {
                if (FF.env.isDevelop()) {
                    var t = this.battleLayer.createNode("dev_btn_nul_2");
                    t.addCallback("action_touch_ended", e).process()
                }
            },
            setDebugText: function(e) {
                if (FF.env.isDevelop()) {
                    if (this._debugText === e) return;
                    var t = this.battleLayer.createNode("debug_nul");
                    t.setText("debug_txt", e).process(), this._debugText = e
                }
            },
            updateAbilityPanel: function() {
                var e = l.DataConstructor.getCurrentAbility(),
                    t = l.DataConstructor.getSelectorAbilityPanelInfo(),
                    n = t ? t.selector : void 0,
                    r = e && e.isInLongAction;
                !n || this.commandView.isChangedSelector(n) || r ? (this.clearTargetActor(), this.clearCursor(), this.hideAbilityPanel(r)) : (this.commandView.commandInDeferred(n, {
                    panelInfoArray: t.abilityPanelInfo,
                    specialInfo: t.soulStrikeInfo,
                    canSkip: t.canSkipSelect
                }), this._supporterViewCanBeVisible = !0, this._updateSupporterViewControllerVisible()), this.commandView.setAutoButtonEnabled(l.DataConstructor.isAutoEnabled())
            },
            hideAbilityPanel: function(e) {
                this.commandView.commandOutDeferred({
                    keepCurrentMenu: e
                }), this.setCanStartPauseBySoulStrikeView(!0), this._supporterViewCanBeVisible = !1, this._updateSupporterViewControllerVisible()
            },
            cancelSoulStrikePanelTouch: function() {
                this.commandView.cancelSoulStrikePanelTouch()
            },
            _updateSupporterViewControllerVisible: function() {
                if (FF.env.isTutorial()) return;
                var e = this._supporterViewCanBeVisible && !this.commandView.isSoulStrikeSelectorMenuShown();
                this._supporterViewShown === e, this._supporterViewShown = e;
                if (this._supporterViewShown) {
                    var t = l.DataConstructor.getSupporterSoulStrikeInfo();
                    this.supporterViewController.supporterButtonInDeferred(t)
                } else this.supporterViewController.supporterButtonOutDeferred()
            },
            updateBuddy: function() {
                _.each(l.DataConstructor.loadBuddyDrawInfo(), function(e) {
                    this.showBuddy(e)
                }, this)
            },
            showBuddy: function(e) {
                var t = e.posId;
                this.buddyViews[t] || (this.buddyViews[t] = new l.view.BuddyView({
                    battleViewController: this,
                    buddyInfo: e
                })), this.buddyViews[t].setBuddyInfo(e)
            },
            updateEnemy: function() {
                _.each(l.DataConstructor.loadEnemyDrawInfo(), function(e) {
                    this.showEnemy(e)
                }, this)
            },
            showEnemy: function(e) {
                var t = e.posId;
                this.enemyContainers[t] || (this.enemyContainers[t] = new l.view.EnemyContainer({
                    battleViewController: this,
                    posId: t,
                    usesFixPos: !!e.usesFixPos
                })), this.isAnimating || this.enemyContainers[t].updateEnemyInfo(e)
            },
            updateEnemyContainerPosArray: function(e) {
                if (!this.enemyContainers[e]) throw new Error("undefined enemy container. posId:" + e);
                if (!this.isAnimating) {
                    var t = l.DataConstructor.getEnemyPosArrayByEnemyPosId(e);
                    this.enemyContainers[e].updatePosArray(t)
                }
            },
            getAllActorViews: function() {
                var e = [];
                return e = e.concat(_.values(this.buddyViews)), _.each(this.enemyContainers, function(t) {
                    e = e.concat(_.values(t.enemyViews))
                }), e
            },
            getActorView: function(e) {
                if (e.isEnemy) {
                    var t = this.enemyContainers[e.posId];
                    if (t) {
                        var n = t.enemyViews[e.childPosId];
                        if (n) return n
                    }
                    throw "target enemy view is not found : " + e.posId + " : " + e.childPosId
                }
                return this.buddyViews[e.posId]
            },
            getActorViewByActorInfo: function(e) {
                return this.getActorView(e.posInfo)
            },
            update: function() {
                this.updateBuddy(), this.updateEnemy(), this.updateActiveTarget(), this.updateAbilityPanel();
                if (this._isTouchedPause && this.canStartPause() && l.DataConstructor.judgePauseOrEscapeAvailable()) {
                    if (FF.env.isTutorial()) {
                        if (this.canNotPause) return;
                        this.tutorialBattleView.setVisible(!1), this.menuWindowView.prepareForTutorial()
                    }
                    this.menuWindowView.startPause(), this._isTouchedPause = !1
                }
            },
            setCanStartPause: function(e) {
                if (!_.isBoolean(e)) throw new Error("invalid argument");
                this._canStartPause = e
            },
            setCanStartPauseBySoulStrikeView: function(e) {
                this._canStartPauseBySoulStrikeView = e
            },
            setCanStartPauseBySoulStrikeSelector: function(e) {
                this._canStartPauseBySoulStrikeSelector = e
            },
            canStartPause: function() {
                return !this._canStartPause || !this._canStartPauseBySoulStrikeView || !this._canStartPauseBySoulStrikeSelector ? !1 : this.menuWindowView.isOpeningWindow() ? !1 : this.menuWindowView.isJustAnimatingWindow() ? !1 : !0
            },
            updateActiveTarget: function() {
                var e = l.DataConstructor.getCurrentAbility(),
                    t = l.DataConstructor.getActiveTarget(),
                    n = l.DataConstructor.getSelectorAbilityPanelInfo(),
                    r = n ? n.selector : void 0;
                !r || !t || e && e.isInLongAction ? this.clearTargetActor() : this.toggleTargetActor(t, r)
            },
            closeTargetArrowOnDeformStartingDeferred: function() {
                return this.targetArrowView.closeDeferred()
            },
            openTargetArrowOnDeformFinishing: function() {
                var e = l.DataConstructor.getActiveTarget(),
                    t = l.DataConstructor.getSelectorAbilityPanelInfo(),
                    n = t ? t.selector : void 0;
                if (!n || !e) return;
                var r = this.getActorViewByActorInfo(e),
                    i = this.getActorViewByActorInfo(n);
                this.targetArrowView.open(r, i)
            },
            setTreasureNum: function(e) {
                var t = this.battleLayer.createNode("treasure_nul");
                t.setText("treasure_num_txt", "" + e).process()
            },
            setOrbNum: function(e) {
                var t = this.battleLayer.createNode("orb_nul");
                t.setText("orb_num_txt", "" + e).process()
            },
            setToolsNum: function(e) {
                var t = this.battleLayer.createNode("tools_nul");
                t.setText("tools_num_txt", "" + e).process()
            },
            setGilNum: function(e) {
                var t = this.battleLayer.createNode("gil_nul");
                t.setText("gil_num_txt", "" + e).process()
            },
            setEventItemNum: function(e) {},
            setEventItemImg: function() {},
            showMessage: function(e) {
                this.messageView.show(e)
            },
            hideMessage: function() {
                this.messageView.hide()
            },
            updateSoulStrikeGauge: function() {
                var e = l.DataConstructor.getSoulStrikePoint();
                this.commandView.setSpecialGauge(e)
            },
            toggleCursor: function(e) {
                var t = l.DataConstructor.getActorInfoByUid(e);
                if (t.posInfo.posId === this._cursorPosInfo.posId) return;
                this.getActorView(t.posInfo).setCursorEnabled(!0), this._cursorPosInfo.posId && this.getActorView(this._cursorPosInfo).setCursorEnabled(!1), this._cursorPosInfo = t.posInfo
            },
            clearCursor: function() {
                _.each(this.buddyViews, function(e) {
                    e.setCursorEnabled(!1)
                }, this), this._cursorPosInfo = {}
            },
            toggleTargetActor: function(e, t) {
                var n = this,
                    r = e.uid;
                if (r === this._targetUid) return;
                var i = this.getActorViewByActorInfo(e),
                    s = this.getActorViewByActorInfo(t);
                if (this._targetUid) {
                    var o = l.DataConstructor.getActorInfoByUid(this._targetUid),
                        u = this.getActorViewByActorInfo(o);
                    u.setTargetEnabled(!1)
                }
                i.setTargetEnabled(!0), this.targetArrowView.open(i, s), this._targetUid = r
            },
            clearTargetActor: function() {
                var e = this.getAllActorViews();
                _.each(e, function(e) {
                    e.setTargetEnabled(!1)
                }), this.targetArrowView.close(), this._targetUid = void 0
            },
            getScreenPositionDeferred: function(t) {
                var n = e.Deferred();
                return t.getNodePos(function(e) {
                    if (e.err) n.reject(e);
                    else {
                        var t = _.first(e.pos);
                        n.resolve(t)
                    }
                }, {
                    isScreen: !0
                }), n.promise()
            },
            playBuddiesVictoryMotion: function(e) {
                _.each(l.DataConstructor.loadBuddyDrawInfo(), function(e) {
                    if (e.isDead) return;
                    this.getActorView(e.posInfo).handsUpMotion()
                }, this)
            },
            createAnimation: function(e) {
                return l.view.animation.AnimationFactory.create(e, this)
            },
            suspendAnime: function() {
                var e = [];
                _.each(this.rootNodes, function(t) {
                    if (_.contains(this.ignoreSuspendLayers, t.layer)) return;
                    t.suspendPlay({
                        descendant: !0
                    }).pauseParticle({
                        descendant: !0
                    }).suspendSpriteAnime({
                        descendant: !0
                    }), e.push(t)
                }, this), this.flush(e)
            },
            resumeAnime: function() {
                var e = [];
                _.each(this.rootNodes, function(t) {
                    if (_.contains(this.ignoreSuspendLayers, t.layer)) return;
                    t.resumePlay({
                        descendant: !0
                    }).continueParticle({
                        descendant: !0
                    }).resumeSpriteAnime({
                        descendant: !0
                    }), e.push(t)
                }, this), this.flush(e)
            },
            addIngoreSupendLayers: function(e) {
                var t = _.isArray(e) ? e : [e];
                _.each(t, function(e) {
                    this.ignoreSuspendLayers.push(e)
                }, this)
            },
            showBalanceErrorWindowDeferred: function(e, t) {
                if (FF.env.isWWRegion()) return this.menuWindowView.showBalanceErrorWindowDeferred(e, t);
                throw new Error("showBalanceErrorWindowDeferred is unimplemented in JP")
            },
            confirmWithUserDeferred: function(e, t) {
                if (FF.env.isWWRegion()) return this.menuWindowView.confirmWithUserDeferred(e, t);
                throw new Error("confirmWithUserDeferred is unimplemented in JP")
            },
            showContinueDoneWindow: function(e, t) {
                this.menuWindowView.showContinueDoneWindow(e, t)
            },
            closeMenuWindowDeferred: function() {
                return this.menuWindowView.closeWindowDeferred()
            },
            showFreeWindow: function(e) {
                this.menuWindowView.showFreeWindow(e)
            },
            showSystemWindow: function(e, n, r, i) {
                var s = this,
                    o = void 0,
                    u = l.TextMaster.getInstance(),
                    a = {
                        yes: u.get("yes"),
                        no: u.get("no"),
                        ok: u.get("ok")
                    };
                switch (e) {
                    case l.Conf.SYSTEM_WINDOW.NETWORK:
                        o = {
                            title: u.get("B15030"),
                            description: u.get("B15040"),
                            buttons: [{
                                title: a.ok,
                                callback: n
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.ERROR:
                        o = {
                            title: u.get("B15050"),
                            description: u.get("B15060"),
                            buttons: [{
                                title: a.ok,
                                callback: function() {
                                    FF.scene.redirectTop()
                                }
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.LOGIN:
                        o = {
                            title: u.get("B15070"),
                            description: u.get("B15080"),
                            buttons: [{
                                title: a.ok,
                                callback: function() {
                                    FF.scene.redirectTop()
                                }
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.BATTLE_RESULT:
                        o = {
                            title: u.get("B15090"),
                            description: u.get("B15100"),
                            buttons: [{
                                title: a.ok,
                                callback: n
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.EXPIRE:
                        o = {
                            title: u.get("B15110"),
                            description: u.get("B15120"),
                            buttons: [{
                                title: a.ok,
                                callback: n
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.CONFIRM_CONTINUE:
                        o = {
                            title: u.get("B15150"),
                            description: u.get("B15160"),
                            buttons: [{
                                title: a.yes,
                                callback: n
                            }, {
                                title: a.no,
                                callback: r
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.MAINTENANCE:
                        var f = new Date(i.closedAt * 1e3),
                            c = t(u.get("B15180"), f.getMonth() + 1, f.getDate(), f.getHours(), f.getMinutes());
                        o = {
                            title: u.get("B15170"),
                            description: c,
                            buttons: [{
                                title: a.ok,
                                callback: n
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.ALERT_ESCAPE:
                        o = {
                            title: u.get("B15190"),
                            description: u.get("B15200"),
                            buttons: [{
                                title: a.ok,
                                callback: n
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.OAUTH_TOKEN_REVOKED:
                        o = {
                            title: u.get("B15210"),
                            description: u.get("B15220"),
                            buttons: [{
                                title: a.ok,
                                callback: function() {
                                    FF.scene.redirect("/dff/login")
                                }
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.PAYMENT_NETWORK:
                        o = {
                            title: u.get("B15030"),
                            description: u.get("B15045"),
                            buttons: [{
                                title: a.ok,
                                callback: function() {
                                    FF.scene.redirectTop()
                                }
                            }]
                        };
                        break;
                    default:
                        throw new Error("unknown type: " + e)
                }
                this.menuWindowView.showFreeWindow(o)
            },
            showAutoButton: function(e) {
                this.commandView.showAutoButton(e)
            },
            removeEnemyContainers: function() {
                _.each(this.enemyContainers, function(e, t) {
                    e.dispose(), delete this.enemyContainers[t]
                }, this)
            },
            startShakeBackground: function() {
                this.shakeBackgroundNode.play("shake_part", {
                    isPlayChild: !1
                }).process()
            },
            stopShakeBackground: function() {
                this.shakeBackgroundNode.play("reset", {
                    isPlayChild: !1
                }).process()
            },
            startShakeField: function() {
                this.shakeAllNode.play("shake_all", {
                    isPlayChild: !1
                }).process()
            },
            stopShakeField: function() {
                this.shakeAllNode.play("reset", {
                    isPlayChild: !1
                }).process()
            },
            playFlash: function() {
                this.flashNode.setVisible(!0).play("flash").process()
            },
            playForceEffect: function() {
                var e = this.battleLayer.createNode("force_pos_nul"),
                    t = (new r({
                        name: "bg_effect_nul",
                        layer: this.forceLayerName,
                        visualParentTo: e.name,
                        visualParentToOptions: {
                            visualParentLayer: this.battleLayer.layerName
                        }
                    })).play("play").process()
            },
            showSpecialMessage: function(e) {
                if (e === this._specialMessage) return;
                this.specialMessageNode.setText("special_name_txt", e), this.specialMessageNode.setVisible(!0).play("special_name_in").process(), this._specialMessage = e
            },
            hideSpecialMessage: function() {
                if (!this._specialMessage) return;
                this.specialMessageNode.play("special_name_out").process(), this._specialMessage = void 0
            },
            resetSpecialMessage: function() {
                if (!this._specialMessage) return;
                var e = this.battleLayer.createNode("bg_color_win");
                e.play("reset").process(), this.specialMessageNode.play("special_name_out").process(), this._specialMessage = void 0
            },
            resetBgColor: function() {
                var e = this.battleLayer.createNode("bg_color_win");
                e.play("reset").process()
            },
            playFadeOutDeferred: function() {
                var e = this;
                return this.blackOutNode.setVisible(!0).play("black_in_all").processDeferred("action_stop").then(function() {
                    e.menuWindowView.setInvisible()
                })
            },
            updateBackgroundIdle: function() {
                if (this.isAnimating) return;
                this.backgroundView.playBackgroundIdle(l.DataConstructor.isChangedBackground())
            },
            playWipeDeferred: function() {
                var e = new r({
                    name: "wipe_nul",
                    layer: "layer_wipe_test"
                });
                return e.setStream({
                    exec: "setZOrder",
                    node: "AnimationBuilderRoot",
                    z: 1
                }), e.play("fade_in_black").processDeferred("action_stop").then(function() {
                    return e.play("fade_in_bg").processDeferred("action_stop")
                }).then(function() {
                    return e.play("play").processDeferred("action_stop")
                })
            },
            setUpdateTimeSpeed: function(e) {
                this.battleLayer.setUpdateTimeSpeed(e).process()
            },
            flush: function(e) {
                var t = [];
                _.each(e, function(e) {
                    t = t.concat(e.stream), e.stream = []
                }), t.length && kickmotor.animation.processAnimation(t)
            },
            startVictory: function() {
                this.isAnimating = !0, this.playBuddiesVictoryMotion(), this.playWinBgm()
            },
            playWinBgm: function() {
                FF.SoundMgr.playMusic(l.DataConstructor.getWinBgm())
            },
            startLose: function() {
                l.Message.showTextMaster("B10030"), this.playRequiem()
            },
            playRequiem: function() {
                FF.SoundMgr.playMusic(l.Conf.BGM_NAME.REQUIEM)
            },
            startPause: function() {
                FF.logger.debug("ä¸€æ™‚åœæ­¢");
                if (this.menuWindowView.isOpeningWindow()) return;
                this._isTouchedPause = !0
            },
            startOpeningWindow: function() {
                this.menuWindowView.setOpeningWindow(!0)
            },
            startContinueWizard: function(e, t, n, r) {
                this.menuWindowView.showGameOverWindow(e, t, n, r)
            },
            stopContinueWizardDeferred: function() {
                return this.closeMenuWindowDeferred()
            },
            notifyCheckingNetwork: function(e) {
                this.showSystemWindow(l.Conf.SYSTEM_WINDOW.NETWORK, e)
            },
            notifyMaintenance: function(e, t) {
                this.showSystemWindow(l.Conf.SYSTEM_WINDOW.MAINTENANCE, e, null, t)
            },
            setTouchVisible: function(e) {
                _.each(this.buddyViews, function(t) {
                    t.setTouchVisible(e)
                }, this), _.each(this.enemyContainers, function(t) {
                    _.each(t.enemyViews, function(t) {
                        t.setTouchVisible(e)
                    }, this)
                }, this), this.commandView.setTouchVisible(e)
            },
            setRootNodesVisible: function(e) {
                _.each(this.rootNodes, function(t) {
                    t.setVisible(e).process()
                }, this)
            },
            setAbscreenTouch: function(e) {
                this._cbTouchAbscreen = e
            },
            setupTutorialView: function(e) {
                this.tutorialBattleView = new l.view.TutorialBattleView({
                    battleViewController: this
                }), this.tutorialBattleView.setup(e), this.listenTo(this, "BattleViewController::specialCommand::touch", this._onTouchSpecialCommnadTutorial), this.listenTo(this, "BattleViewController::commandSet::touch", this._onTouchCommandSetTutorial)
            },
            _onTouchSpecialCommnadTutorial: function() {
                _.isFunction(this._cbTouchSpecialCommnadTutorial) && this._cbTouchSpecialCommnadTutorial()
            },
            setCbTouchSpecialCommnadTutorial: function(e) {
                this._cbTouchSpecialCommnadTutorial = e
            },
            _onTouchCommandSetTutorial: function(e) {
                _.isFunction(this._cbTouchCommandSetTutorial) && this._cbTouchCommandSetTutorial(e)
            },
            setCbTouchCommandSetTutorial: function(e) {
                this._cbTouchCommandSetTutorial = e
            },
            _onBackKey: function() {
                if (FF.env.isUsingWWBackKeyHandler())
                    if (_.isFunction(this._cbTouchAbscreen)) FF.ns.battle.BattleViewController && FF.ns.battle.BattleViewController.getInstance().trigger("BattleViewController::ABScreen::ActionTouchEnded");
                    else {
                        if (l.DataConstructor.isAllEnded() || l.DataConstructor.isJustEnded()) return;
                        var e = FF.ns.battle.BattleViewController.getInstance();
                        e.menuWindowView && e.menuWindowView.isOpeningWindow() ? e.menuWindowView.endPause() : e.startPause()
                    }
            },
            dispose: function() {
                this.commandView.dispose();
                var e = [];
                e.push(this.battleLayer.layerName), e.push(this.backgroundView.layerName), e.push(this.assetsManager.getAssetInfo(this.buddyCommonAssetId).layerName), e.push(this.forceLayerName), e.push(this.menuWindowView.layerName), e = e.concat(this.backgroundView.bgEffLayerNames), this.assetsManager.destroyLayersWithoutTargetLayers(e), this.assetsManager.dispose()
            }
        },
        h = o.extend(c),
        p = void 0;
    return FF.ns.battle.BattleViewController = {
        getInstance: function() {
            return p || (FF.env.isNative() || (_.each(c, function(e, t) {
                c[t] = function() {}
            }), c.createAnimation = function(e) {
                return _.extend({
                    addCallbackOnce: function(e, t) {
                        return this.once(e, t), this
                    },
                    play: function() {
                        return this.trigger("end"), this
                    }
                }, s)
            }, h = o.extend(c)), p = new h), p
        }
    }, h
}), define("scenes/battle/SupporterViewController", ["underscore", "jquery", "backbone", "sprintf", "lib/ClassBase", "lib/ab/ABNode"], function(e, t, n, r, i, s) {
    var o = FF.ns.battle;
    return FF.ns.battle.SupporterViewController = i.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.assetsManager = this.battleViewController.assetsManager, this.battleLayer = this.battleViewController.battleLayer, this.supporterButtonEnabled = !1, this._setupNodes()
        },
        _setupNodes: function() {
            this._setupBgNode(), this._setSupporterEffNodes(), this._setupButton()
        },
        _setupBgNode: function() {
            if (!this.socialBgNode) {
                var e = "bg_social",
                    t = this.assetsManager.getAssetInfo(e);
                this.socialBgNode = new s({
                    name: "bg_social_nul",
                    layer: t.layerName,
                    visualParentTo: "bg_social_pos_nul",
                    visualParentToOptions: {
                        visualParentLayer: this.battleLayer.layerName
                    }
                })
            }
            this.socialBgNode.process()
        },
        _setSupporterEffNodes: function() {
            if (!this.supporterFrontEffNode) {
                var e = "player_friend_front_eff",
                    t = this.assetsManager.getAssetInfo(e);
                this.supporterFrontEffNode = new s({
                    name: "player_friend_front_eff_nul",
                    layer: t.layerName
                })
            }
        },
        _setupButton: function() {
            var e = this;
            this.supporterButtonEnableNode || (this.supporterButtonEnableNode = this.battleLayer.createNode("friend_special_color_nul"), this.supporterButtonNode = this.supporterButtonEnableNode.createChildNode("friend_special_nul"), this.supporterButtonNode.setVisible(!1).play("command_change_out").process())
        },
        setButtonTouch: function(e) {
            var t = this;
            this.supporterButtonTouchNode || (this.supporterButtonTouchNode = this.supporterButtonNode.createChildNode("friend_visible_touch"), this.supporterButtonTouchNode.addCallback("action_touch_began", function() {
                if (!o.DataConstructor.canOperateBattle()) return;
                if (!t.supporterButtonEnabled) return;
                t.supporterButtonNode.play("command_tap_start").process()
            }), this.supporterButtonTouchNode.addCallback("action_touch_ended", function() {
                if (!o.DataConstructor.canOperateBattle()) return;
                if (!t.supporterButtonEnabled) return;
                t.supporterButtonEnabled = !1, t.supporterButtonNode.play("command_tap_end").processDeferred("action_stop").then(function() {
                    e()
                })
            }), this.supporterButtonTouchNode.addCallback("action_touch_enterd", function() {
                if (!o.DataConstructor.canOperateBattle()) return;
                if (!t.supporterButtonEnabled) return;
                t.supporterButtonNode.play("command_tap_start").process()
            }), this.supporterButtonTouchNode.addCallback("action_touch_exited", function() {
                if (!o.DataConstructor.canOperateBattle()) return;
                if (!t.supporterButtonEnabled) return;
                t.supporterButtonNode.play("command_tap_cancel").process()
            }), this.supporterButtonTouchNode.process())
        },
        supporterButtonInDeferred: function(e) {
            if (!e) return;
            if (this._isShownSupporterButton && this._isEnabled === e.enabled) return;
            return this._setSupporterButtonInfo(e), this._isShownSupporterButton = !0, this._isEnabled = e.enabled, this.supporterButtonNode.play("command_change_in").setVisible(!0).processDeferred("action_stop")
        },
        supporterButtonOutDeferred: function() {
            if (!this._isShownSupporterButton) return;
            return this._isShownSupporterButton = !1, this.supporterButtonNode.play("command_change_out").setVisible(!1).processDeferred("action_stop")
        },
        setSupporterButtonEnabled: function(e) {
            e ? (this.supporterButtonEnabled = !0, this.supporterButtonEnableNode.play("enabled", {
                isPlayChild: !1
            }).process()) : (this.supporterButtonEnabled = !1, this.supporterButtonEnableNode.play("disabled", {
                isPlayChild: !1
            }).process())
        },
        _setSupporterButtonInfo: function(e) {
            var t = e.enabled,
                n = e.restCount;
            if (this.buttonAssetId !== e.assetId) {
                var r = this.battleViewController.assetsManager.getAssetInfo(e.assetId);
                this.supporterButtonNode.loadBundle(r.bundle).setImage("friend_critical_btn_img", r.assetPath), this.buttonAssetId = e.assetId
            }
            this.buttonNum !== n && (this.supporterButtonNode.setText("friend_num_txt", n), this.buttonNum = n);
            if (this.charaAssetId !== e.charaAssetId) {
                var i = this.battleViewController.assetsManager.getAssetInfo(e.charaAssetId);
                this.supporterButtonNode.loadBundle(i.bundle).setSpriteAnimeByNode("friend_sprite", i.assetPath).setSpriteActionByNode("friend_sprite", "idle_cut"), this.charaAssetId = e.charaAssetId
            }
            n <= 0 || !t ? this.setSupporterButtonEnabled(!1) : this.setSupporterButtonEnabled(!0), this.supporterButtonNode.process()
        },
        showSupporterEffectDeferred: function(e) {
            var t = this,
                n = e.posId;
            return this.socialBgNode.addCallbackOnce("action_next", function() {
                var r = t.battleViewController.buddyViews[n];
                r.setVisibleForReplacingSupporter(!1), r.replaceBuddyInfo(e.supporterInfo), r.flush()
            }), this._changeSupporterPosId(n), this.supporterFrontEffNode.play("change_eff_bg").process(), this.socialBgNode.setVisible(!0).play("change_eff_bg").processDeferred("action_stop")
        },
        hideSupporterEffectDeferred: function(e) {
            var t = this,
                n = e.posId;
            return this.socialBgNode.addCallbackOnce("action_next", function() {
                var e = t.battleViewController.buddyViews[n];
                e.setVisibleForReplacingSupporter(!0), e.replaceBuddyInfo(e.buddyInfo), e.flush()
            }), this.supporterFrontEffNode.play("restore_eff_bg").process(), this.socialBgNode.play("restore_eff_bg").processDeferred("action_next")
        },
        _changeSupporterPosId: function(e) {
            this.supporterFrontEffNode.setVisualParent(this.battleLayer.layerName, r("player_friend_front_eff_%s", e)).process()
        }
    }), FF.ns.battle.SupporterViewController
}), define("scenes/battle/BuddyPartyMgr", ["lib/EventBase", "util"], function(e, t) {
    var n = FF.ns.battle,
        r = e.extend({
            initialize: function(t) {
                e.prototype.initialize.apply(this, arguments), this.activeTarget = new n.ActiveTarget, this.set("gil", 0), this.set("treasure", 0), this.set("orb", 0), this.set("eventItem", 0), this.set("lastReceptorInfo", {})
            },
            giveGil: function(e) {
                if (!e || e < 0) e = 0;
                this.set("gil", this.get("gil") + e)
            },
            giveTreasure: function(e) {
                if (!e || e < 0) e = 0;
                this.set("treasure", this.get("treasure") + e)
            },
            giveOrb: function(e) {
                if (!e || e < 0) e = 0;
                this.set("orb", this.get("orb") + e)
            },
            giveEventItem: function(e) {
                if (!e || e < 0) e = 0;
                this.set("eventItem", this.get("eventItem") + e)
            },
            setParent: function(e) {
                this.parent = e
            },
            update: function() {
                this.execReservedAbilitys()
            },
            reserveAbility: function(e, t) {
                var n = e.getUid(),
                    r = e.getReceptorById(t);
                return !r || !r.canRecept(e) ? !1 : this.hasReservedAbility(n) ? !1 : (this._reservedAbilitys[n] = r.makeCommandFunc(e), this.setLastReceptorId(e, t), !0)
            },
            reserveSupporterSoulStrike: function() {
                var e = n.ActorMgr.getAbilityPanelSelector(),
                    t = e.getUid(),
                    r = n.ActorMgr.getSupporter().getSupporterSoulStrike();
                return !r || !r.canRecept(e) ? !1 : this.hasReservedAbility(t) ? !1 : (this._reservedAbilitys[t] = r.makeCommandFunc(e), !0)
            },
            canReceptSupporterSoulStrike: function() {
                var e = n.ActorMgr.getAbilityPanelSelector(),
                    t = n.ActorMgr.getSupporter();
                return !e || !t ? !1 : t.getSupporterSoulStrike().canRecept(e)
            },
            isDuringSupporterSoulStrike: function() {
                return _.any(n.ActorMgr.getAliveBuddies(), function(e) {
                    return e.isStateInCast() || e.isStateInAction() ? !!e.getAbility().get("isSupporterSoulStrike") : !1
                }, this)
            },
            reserveAbilityForPositiveIncontrollable: function(e) {
                this.reserveAbility(e, n.Conf.RECEPTOR.POSITIVE_INCONTROLLABLE)
            },
            reserveAbilityForAutoBattle: function(e) {
                var t = 1,
                    n = e.getAbilityPanelReceptorByPanelNo(t);
                this.reserveAbility(e, n.get("receptorId"))
            },
            setLastReceptorId: function(e, t) {
                this.get("lastReceptorInfo")[e.get("no")] = {
                    id: e.getId(),
                    receptorId: t
                }
            },
            getLastReceptorId: function(e) {
                var t = this.get("lastReceptorInfo")[e.get("no")];
                if (t && t.id === e.getId()) return t.receptorId;
                return
            },
            hasReservedAbility: function(e) {
                return this._reservedAbilitys[e] ? !0 : !1
            },
            execReservedAbilitys: function() {
                _.each(this._reservedAbilitys, function(e, t) {
                    _.isFunction(e) && n.ActorMgr.getByUid(t).isReadyToSelectAbility() && e()
                }), this._reservedAbilitys = {}
            },
            makeResultData: function() {
                var e = {};
                _.each(n.ActorMgr.getAllBuddies(), function(t) {
                    var r = n.BattleInfo.getInstance().getActorParam(t.getUid()),
                        i = {
                            hp: _.min([t.get("hp"), r.maxHp]),
                            sa: t.statusAilments.getContinuanceIds()
                        };
                    _.each(n.Config.getInstance().get("DefaultAbilityPanels"), function(e, n) {
                        var r = t.getReceptorById(e);
                        if (!r || !r.isCommandPanel()) return;
                        i["panel" + n] = r.isInfinity() ? null : _.min([r.get("remainNum"), r.get("defaultMaxNum")])
                    }, this), i.ss_gauge = t.getSoulStrike().get("point"), e[t.get("no")] = i
                }, this);
                var t = {
                        supporter_ss_gauge: 0
                    },
                    r = n.ActorMgr.getSupporter();
                if (r) {
                    var i = r.getSupporterSoulStrike().get("restCount");
                    t.supporter_ss_gauge = i
                }
                return {
                    buddy: e,
                    supporter: t
                }
            },
            toPlainObject: function() {
                return {
                    attributes: this._attributes
                }
            },
            applyPlainObject: function(e) {
                if (!e) return;
                _.extend(this._attributes, e.attributes)
            },
            getMaxPartyNum: function() {
                return n.Config.getInstance().get("MaxPartyNum")
            }
        }),
        i = void 0;
    FF.ns.battle.BuddyPartyMgr = {
        getInstance: function() {
            return i || (i = new r), i
        }
    }
}), define("scenes/battle/Commander", ["util", "lib/ClassBase"], function(e, t) {
    var n = FF.ns.battle,
        r = t.extend({
            createAbility: function(e, t, r) {
                var i = n.AbilityFactory.create(e, t, r);
                return r && r.activeTarget && i.set("activeTarget", r.activeTarget), i
            },
            register: function(t, r, i, s) {
                s = e.option({
                    interruptBoss: !1,
                    interruptBeforeCounter: !1,
                    interruptCounter: !1,
                    interruptStatusAilments: !1
                }, s), FF.logger.debug("CMD_REG:" + t, i, s);
                var o = this.createAbility(t, r, i);
                if (s.interruptBoss) return n.AbilityMgr.getInstance().interruptBoss(o), o;
                if (s.interruptBeforeCounter) return n.AbilityMgr.getInstance().interruptBeforeCounter(o), o;
                if (s.interruptCounter) return n.AbilityMgr.getInstance().interruptCounter(o), o;
                if (s.interruptStatusAilments) return n.AbilityMgr.getInstance().interruptStatusAilments(o), o;
                if (!r.isReadyToSelectAbility()) throw new Error(["executer is not ready ability", r.getId(), r.getUid(), r.get("state")]);
                return r.setAbility(o), o
            }
        }),
        i = void 0;
    FF.ns.battle.Commander = {
        getInstance: function() {
            return i || (i = new r), i
        }
    }
}), define("scenes/battle/Config", ["util", "lib/ClassBase", "./Conf"], function(e, t, n) {
    var r = {};
    r.HpGaugeVisibleEventIds = [506, 26, 27, 902, 28], r.DamageCalculator = {}, r.DamageCalculator.DAMAGE = {
        minDamage: 5,
        basePower: 1.3,
        magicBasePower: 1.15,
        ratioDefence: 1.2,
        ratioMagicDefence: 1.2,
        maxBasic: 2e3,
        maxBasicForPhysicalAndReceiverEnemy: 4e3,
        defBufAtkConvertPower: .18,
        maxDefBufRatio: 1.8,
        ratioPower: .5,
        ratioPowerDefence: .7,
        ratioCoefficient: 1,
        summonRatioPower: .05,
        summonRatioCoefficient: 1,
        maxRatio: 1e3,
        defenseCoefficient: {
            "default": 10,
            defense: 5
        },
        criticalCoefficient: 15,
        randCoeffiecient: 3,
        damageThreshold: 9999
    }, r.DamageCalculator.ROW = {}, r.DamageCalculator.ROW.DEFAULT = 10, r.DamageCalculator.ROW[n.ROW_TYPE.FRONT] = {}, r.DamageCalculator.ROW[n.ROW_TYPE.FRONT][n.ROW_TYPE.FRONT] = 10, r.DamageCalculator.ROW[n.ROW_TYPE.FRONT][n.ROW_TYPE.BACK] = 5, r.DamageCalculator.ROW[n.ROW_TYPE.BACK] = {}, r.DamageCalculator.ROW[n.ROW_TYPE.BACK][n.ROW_TYPE.FRONT] = 5, r.DamageCalculator.ROW[n.ROW_TYPE.BACK][n.ROW_TYPE.BACK] = 3, r.DamageCalculator.HEAL = {
        a: 5,
        b: 100,
        c: 3
    }, r.DamageCalculator.ACC = {
        a: 8,
        b: 6,
        c: 35,
        d: 90,
        e: 100,
        f: 20,
        blinded: 25
    }, r.DamageCalculator.DROP_ITEM = {}, r.DamageCalculator.DROP_ITEM[n.DROP_ITEM_TYPE.POTION] = 10, r.DamageCalculator.DROP_ITEM[n.DROP_ITEM_TYPE.HI_POTION] = 25, r.DamageCalculator.DROP_ITEM[n.DROP_ITEM_TYPE.X_POTION] = 50, r.DamageCalculator.DROP_ITEM[n.DROP_ITEM_TYPE.ETHER] = 20, r.DamageCalculator.DROP_ITEM[n.DROP_ITEM_TYPE.TURBO_ETHER] = 33, r.DamageCalculator.STATUS_AILMENTS = {
        a: 3,
        b: 3
    }, r.DamageCalculator.ELEMENT_ADVANTAGE = {
        0: [n.ADVANTAGE.NONE, 10],
        1: [n.ADVANTAGE.WEAK, 20],
        2: [n.ADVANTAGE.HALF, 9],
        3: [n.ADVANTAGE.HALF, 8],
        4: [n.ADVANTAGE.HALF, 7],
        5: [n.ADVANTAGE.HALF, 6],
        6: [n.ADVANTAGE.HALF, 5],
        7: [n.ADVANTAGE.HALF, 4],
        8: [n.ADVANTAGE.HALF, 3],
        9: [n.ADVANTAGE.HALF, 2],
        10: [n.ADVANTAGE.HALF, 1],
        11: [n.ADVANTAGE.VOID, 0],
        12: [n.ADVANTAGE.ABSORPTION, -1],
        13: [n.ADVANTAGE.ABSORPTION, -2],
        14: [n.ADVANTAGE.ABSORPTION, -3],
        15: [n.ADVANTAGE.ABSORPTION, -4],
        16: [n.ADVANTAGE.ABSORPTION, -5],
        17: [n.ADVANTAGE.ABSORPTION, -6],
        18: [n.ADVANTAGE.ABSORPTION, -7],
        19: [n.ADVANTAGE.ABSORPTION, -8],
        20: [n.ADVANTAGE.ABSORPTION, -9],
        21: [n.ADVANTAGE.ABSORPTION, -10]
    }, r.DamageCalculator.ELEMENT_ADVANTAGE_DEFAULT = [n.ADVANTAGE.NONE, 10], r.ATB = {
        a: 4500,
        b: .15
    }, r.SoulStrike = {
        maxSsPoint: 1500,
        damagedSsPoint: 50,
        c: 150
    }, r.BuiltinAbilities = [{
        abilityId: n.ABILITY_ID_OF.DEFORM,
        actionId: n.ACTION_ID_OF.DEFORM,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.DEFORM_MULTI,
        actionId: n.ACTION_ID_OF.DEFORM_MULTI,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.POISON,
        actionId: n.ACTION_ID_OF.POISON,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.REGEN,
        actionId: n.ACTION_ID_OF.REGEN,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.DEFENSE,
        actionId: n.ACTION_ID_OF.DEFENSE,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.DO_NOTHING,
        actionId: n.ACTION_ID_OF.DO_NOTHING,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.HEAL_DEATH,
        actionId: n.ACTION_ID_OF.HEAL_DEATH,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.BUILTIN_INFLICT_SA,
        actionId: n.ACTION_ID_OF.BUILTIN_INFLICT_SA,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.INCREASE_MP,
        actionId: n.ACTION_ID_OF.INCREASE_MP,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.RERAISE_RISE,
        actionId: n.ACTION_ID_OF.RERAISE_RISE,
        options: {
            castTime: 0
        }
    }], r.DefaultAbilityPanels = {
        1: n.RECEPTOR.PANEL_ATTACK,
        2: n.RECEPTOR.PANEL_FLEXIBLE_1,
        3: n.RECEPTOR.PANEL_FLEXIBLE_2,
        4: n.RECEPTOR.PANEL_DEFENSE
    }, r.SoulStrikePanels = {
        1: n.RECEPTOR.SOUL_STRIKE_FLEXIBLE_1,
        2: n.RECEPTOR.SOUL_STRIKE_FLEXIBLE_2,
        3: n.RECEPTOR.SOUL_STRIKE_FLEXIBLE_3,
        4: n.RECEPTOR.SOUL_STRIKE_FLEXIBLE_4
    }, r.PanelNoToPosId = {
        1: "01",
        2: "03",
        3: "04",
        4: "02"
    }, r.PosIdToPanelNo = _.invert(r.PanelNoToPosId), r.FlexibleAbilities = [n.RECEPTOR.PANEL_FLEXIBLE_1, n.RECEPTOR.PANEL_FLEXIBLE_2], r.SparePanelReceptors = [n.RECEPTOR.SPARE_PANEL_TRANCE_CLOUD_1, n.RECEPTOR.SPARE_PANEL_TRANCE_CLOUD_2, n.RECEPTOR.SPARE_PANEL_TRANCE_TINA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_TINA_2], r.BuiltinPanels = [{
        receptorId: n.RECEPTOR.PANEL_DEFENSE,
        panelType: n.PANEL_TYPE.DEFENSE,
        abilityId: n.ABILITY_ID_OF.DEFENSE
    }], r.BuddyTagPriority = {
        dead: 1,
        stone: 2,
        chant_wait: 3,
        ready: 3,
        fatal: 4,
        idle: 5
    }, r.StatusAilments = {}, r.StatusAilments.GRAPHIC_TAG = {}, r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.DEATH] = "dead", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.RERAISE_DEATH] = "dead", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.CHARGE] = "ready", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.COUNTER_AIMING] = "ready", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.DEFENSE] = "ready", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.PARALYSIS] = "fatal", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.STOCK_BREAK] = "fatal", r.ExerciseTypeToCastTag = {}, r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.PHYSICAL] = "ready", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.BLACK_MAGIC] = "chant_wait", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.WHITE_MAGIC] = "chant_wait", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.BLUE_MAGIC] = "chant_wait", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.SUMMON] = "chant_wait", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.INBORN] = "ready", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.NINJA] = "ready";
    var i = [{
        bonusId: n.CONTINUE_BONUS.ATTACK,
        giveFuncName: "giveBonusAttack",
        boostFactor: 10,
        cardImageId: "continue_bonus_1",
        descTextId: "B10110",
        colorTag: "color_1"
    }, {
        bonusId: n.CONTINUE_BONUS.DEFENSE,
        giveFuncName: "giveBonusDefense",
        boostFactor: 10,
        cardImageId: "continue_bonus_2",
        descTextId: "B10120",
        colorTag: "color_2"
    }, {
        bonusId: n.CONTINUE_BONUS.ABILITY,
        giveFuncName: "giveBonusAbility",
        boostFactor: 2,
        cardImageId: "continue_bonus_3",
        descTextId: "B10130",
        colorTag: "color_3"
    }, {
        bonusId: n.CONTINUE_BONUS.HP,
        giveFuncName: "giveBonusHp",
        boostFactor: 10,
        cardImageId: "continue_bonus_4",
        descTextId: "B10140",
        colorTag: "color_4"
    }];
    r.ContinueBonusIds = _.pluck(i, "bonusId"), r.ContinueBonus = _.indexBy(i, "bonusId"), r.MagicExerciseTypes = [n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLACK_MAGIC, n.EXERCISE_TYPE.BLUE_MAGIC, n.EXERCISE_TYPE.SUMMON], r.BasicMagicExerciseTypes = [n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLACK_MAGIC], r.ExerciseTypesWithoutPhysical = _.difference(_.values(n.EXERCISE_TYPE), [n.EXERCISE_TYPE.PHYSICAL, n.EXERCISE_TYPE.NINJA, n.EXERCISE_TYPE.NO_CLASSIFIED]), r.ReflectionExerciseTypes = [n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLACK_MAGIC], r.CounterAimingEffectedExerciseTypes = [n.EXERCISE_TYPE.PHYSICAL], r.MightyGuardEffectedCalcTypes = [n.CALC_TYPE.MAGIC, n.CALC_TYPE.FRACTION, n.CALC_TYPE.DAMAGED_HP], r.CounterAimingEffectedCalcTypes = _.without(_.values(n.CALC_TYPE), n.CALC_TYPE.HEAL, n.CALC_TYPE.STATUS_AILMENTS, n.CALC_TYPE.PHYSICAL_STATUS_AILMENTS), r.Tutorial = {
        heroId: 10000200,
        specialAbilityId: 30131091,
        specialRound: 3,
        specialAbilityPosId: "04"
    }, r.EnemyAblityTag = {
        NegativeIncontrollable: "_DEFAULT_"
    }, r.MateriaAllowableTypesConfig = {
        1: {
            exerciseTypes: [n.EXERCISE_TYPE.PHYSICAL, n.EXERCISE_TYPE.BLACK_MAGIC],
            calcTypes: [n.CALC_TYPE.ATTACK, n.CALC_TYPE.MAGIC]
        }
    }, r.MateriaParamConfig = {
        1511: [{
            paramName: "atk",
            rate: 5
        }],
        1512: [{
            paramName: "atk",
            rate: 10
        }],
        1513: [{
            paramName: "atk",
            rate: 15
        }],
        1514: [{
            paramName: "atk",
            rate: 20
        }],
        1521: [{
            paramName: "def",
            rate: 5
        }],
        1522: [{
            paramName: "def",
            rate: 10
        }],
        1531: [{
            paramName: "matk",
            rate: 5
        }],
        1532: [{
            paramName: "matk",
            rate: 2
        }],
        1533: [{
            paramName: "matk",
            rate: 10
        }],
        1534: [{
            paramName: "matk",
            rate: 15
        }],
        1535: [{
            paramName: "matk",
            rate: 20
        }],
        1541: [{
            paramName: "mdef",
            rate: 5
        }],
        1551: [{
            paramName: "mnd",
            rate: 10
        }],
        1552: [{
            paramName: "mnd",
            rate: 20
        }],
        2011: [{
            paramName: "atk",
            rate: 10
        }, {
            paramName: "def",
            rate: -10
        }],
        2021: [{
            paramName: "matk",
            rate: 10
        }, {
            paramName: "mdef",
            rate: -10
        }],
        2031: [{
            paramName: "matk",
            rate: 10
        }, {
            paramName: "atk",
            rate: -10
        }],
        2041: [{
            paramName: "def",
            rate: 10
        }, {
            paramName: "atk",
            rate: -10
        }],
        2051: [{
            paramName: "matk",
            rate: 20
        }, {
            paramName: "def",
            rate: -10
        }, {
            paramName: "mdef",
            rate: -10
        }],
        2052: [{
            paramName: "matk",
            rate: 40
        }, {
            paramName: "def",
            rate: -20
        }, {
            paramName: "mdef",
            rate: -20
        }],
        2061: [{
            paramName: "matk",
            rate: 10
        }, {
            paramName: "def",
            rate: -10
        }],
        2511: [{
            paramName: "atk",
            rate: 10
        }, {
            paramName: "def",
            rate: 10
        }],
        5511: [{
            paramName: "atk",
            rate: 10
        }, {
            paramName: "def",
            rate: 10
        }, {
            paramName: "matk",
            rate: 10
        }, {
            paramName: "mdef",
            rate: 10
        }, {
            paramName: "mnd",
            rate: 10
        }]
    }, r.DeadTag = {
        1: "dead",
        2: "dead_boss",
        3: "apparent_dead",
        4: "escape"
    }, r.CancelCastStatusAilmentsTypes = [n.STATUS_AILMENTS_TYPE.SILENCE, n.STATUS_AILMENTS_TYPE.MAGIC_SEAL], r.BrkDefConfig = {}, r.BrkDefConfig.PARAM_NAME = {}, r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.ATK] = "atk", r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.DEF] = "def", r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.MATK] = "matk", r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.MDEF] = "mdef", r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.MND] = "mnd", r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.SPD] = "spd", r.BrkDefConfig.ADVANTAGE = {
        6: [n.ADVANTAGE.HALF, -50],
        11: [n.ADVANTAGE.VOID, -100]
    }, r.EnemyCastTime = {}, r.EnemyCastTime[n.CAST_TIME_TYPE.NORMAL_1] = 1760, r.EnemyCastTime[n.CAST_TIME_TYPE.SLOW_1] = 3850, r.CounterCustomConfig = {}, r.CounterCustomConfig[n.COUNTER_CONDTION_CUSTOM_TYPE.BLACK_AND_WHITE_MAGIC_ATTACK] = {
        exercises: [n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLACK_MAGIC],
        damagedOnly: !0
    }, r.CounterCustomConfig[n.COUNTER_CONDTION_CUSTOM_TYPE.SKIP_IN_REFLECTION] = {
        exercises: [n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLACK_MAGIC],
        skipInReflection: !0
    }, r.CounterCustomConfig[n.COUNTER_CONDTION_CUSTOM_TYPE.COUNTER_AIMING] = {
        exercises: r.CounterAimingEffectedExerciseTypes,
        calcTypes: r.CounterAimingEffectedCalcTypes
    }, r.MaxPartyNum = 5;
    var s = t.extend({
            get: function() {
                var e = r;
                _.each(arguments, function(t) {
                    e = e[t]
                }, this);
                if (!e) throw new Error("config not found.");
                return e
            },
            set: function() {
                throw new Error("can not set config")
            }
        }),
        o = void 0;
    FF.ns.battle.Config = {
        getInstance: function() {
            return o || (o = new s), o
        }
    }
}), define("scenes/battle/ContinueBonus", ["lib/ClassBase", "util"], function(e, t) {
    var n = FF.ns.battle,
        r = e.extend({
            _boostParam: function(e, t, n) {
                e.setBoost(t, n)
            },
            giveBonusAttack: function(e, t) {
                var r = n.Conf.CONTINUE_BONUS.ATTACK,
                    i = this._getBoostFactor(r),
                    s = t * i;
                _.each(["atk", "matk", "mnd"], function(t) {
                    this._boostParam(e, t, s)
                }, this)
            },
            giveBonusHp: function(e, t) {
                var r = n.Conf.CONTINUE_BONUS.HP,
                    i = this._getBoostFactor(r),
                    s = t * i,
                    o = Math.floor(e.get("maxHp") * (1 + s / 100));
                e.set("maxHp", o), e.set("hp", o)
            },
            giveBonusDefense: function(e, t) {
                var r = n.Conf.CONTINUE_BONUS.DEFENSE,
                    i = this._getBoostFactor(r),
                    s = t * i;
                _.each(["def", "mdef"], function(t) {
                    this._boostParam(e, t, s)
                }, this)
            },
            giveBonusAbility: function(e, t) {
                var r = n.Conf.CONTINUE_BONUS.ABILITY,
                    i = this._getBoostFactor(r),
                    s = t * i;
                _.each(e.getAbilityPanels(), function(e) {
                    e.addConsumableNum(s)
                }, this)
            },
            _getBoostFactor: function(e) {
                return n.Config.getInstance().get("ContinueBonus", e, "boostFactor")
            },
            exists: function() {
                return this._getBonusIds().length > 0
            },
            give: function() {
                var e = this.amountByBonusId();
                _.each(n.ActorMgr.getAllBuddies(), function(t) {
                    this._giveEachBuddy(t, e)
                }, this)
            },
            amountByBonusId: function() {
                return _.countBy(this._getBonusIds(), function(e) {
                    return e
                })
            },
            _getBonusIds: function() {
                var e = [],
                    t = n.BattleInfo.getInstance(),
                    r = t.getAllContinueTxns();
                return _.each(r, function(t) {
                    if (!t.isStatOf("DONE")) return;
                    e.push(t.get("bonusId"))
                }, this), e
            },
            _giveEachBuddy: function(e, t) {
                _.each(t, function(t, r) {
                    var i = n.Config.getInstance().get("ContinueBonus", r, "giveFuncName");
                    this[i](e, t)
                }, this)
            }
        }),
        i = void 0;
    FF.ns.battle.ContinueBonus = {
        getInstance: function() {
            return i || (i = new r), i
        }
    }
}), define("scenes/battle/ContinueFsm", ["util", "lib/NameConventionFsm"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf;
    FF.ns.battle.ContinueFsm = t.extend({
        initialize: function() {
            t.prototype.initialize.call(this), this.changeState("IDLE")
        },
        begin: function() {
            n.BattleViewController.getInstance().startLose();
            var e = n.BattleInfo.getInstance().getLastContinueTxn();
            if (!e) {
                this.changeState("START");
                return
            }
            switch (e.get("stat")) {
                case r.CONTINUE_TXN_STAT.STARTED:
                    this.changeState("RECOVER");
                    break;
                case r.CONTINUE_TXN_STAT.CURED:
                    this.changeState("BONUS");
                    break;
                case r.CONTINUE_TXN_STAT.SELECTED:
                    this.changeState("PRE_CONTINUE");
                    break;
                case r.CONTINUE_TXN_STAT.DONE:
                    this.changeState("START");
                    break;
                case r.CONTINUE_TXN_STAT.CANCELED:
                    this.changeState("START");
                    break;
                default:
                    throw new Error("invalid judge")
            }
        },
        setParent: function(e) {
            this._parent = e
        },
        processForStateStartEntry: function() {
            var e = this;
            this._isDoneStart = !1, this._isRetryStart = !1, n.BattleViewController.getInstance().startOpeningWindow(), this._parent.saveResumeDataDeferred().then(function() {
                e._startContinueWizard()
            })
        },
        _startContinueWizard: function() {
            var t = this;
            t._isDoneStart = !1, t._isRetryStart = !1, $.when(n.Api.getContinueInfoDeferred({
                retryCount: 2
            }), n.Api.getBalanceDeferred(), n.util.DelayCallback.registerDeferred(1500)).done(function(i, s) {
                var o = e.camelizeDeep(_.first(i)),
                    u = o.info,
                    a = n.BattleInfo.getInstance().getExpiredAt() - o.currentTime;
                if (a <= 0) {
                    t.changeState("EXPIRE");
                    return
                }
                u.untilExpire = a;
                var f = s,
                    l = u[r.CONTINUE_TYPE.COIN].payCost,
                    c = f >= l;
                u[r.CONTINUE_TYPE.COIN].balance = f, u[r.CONTINUE_TYPE.COIN].canConsume = c;
                var h = t._makeCallbackOfSoulPiece(u),
                    p = t._makeCallbackOfCoin(u),
                    d = function() {
                        t.changeState("RETIRE")
                    };
                n.BattleViewController.getInstance().startContinueWizard(u, h, p, d)
            }).fail(function(e, n, r, i) {
                t._onFail(e, n, r, i)
            })
        },
        _onFail: function(e, t, r, i) {
            var s = this;
            if (r && r.isPurchasingCanceled) {
                s.changeState("RECOVER");
                return
            }
            if (r && r.error) switch (r.error) {
                case "OAUTH_TOKEN_REVOKED":
                    n.BattleViewController.getInstance().showSystemWindow(n.Conf.SYSTEM_WINDOW.OAUTH_TOKEN_REVOKED);
                    return;
                case "EXISTS_ACTIVE_PAYMENT":
                    n.BattleViewController.getInstance().showSystemWindow(n.Conf.SYSTEM_WINDOW.PAYMENT_NETWORK);
                    return;
                case "CLOSE_VALIDATION_SESSION_EXPIRED":
                    n.BattleViewController.getInstance().showSystemWindow(n.Conf.SYSTEM_WINDOW.EXPIRE, function() {
                        FF.scene.redirectTop()
                    });
                    return;
                case "UNKNOWN":
                    break;
                default:
                    n.BattleViewController.getInstance().showSystemWindow(n.Conf.SYSTEM_WINDOW.ERROR);
                    return
            }
            if (i && i.isMaintenance) {
                n.BattleViewController.getInstance().notifyMaintenance(function() {
                    s.changeState("RECOVER")
                }, i);
                return
            }
            n.BattleViewController.getInstance().notifyCheckingNetwork(function() {
                s.changeState("RECOVER")
            })
        },
        _processStartFinally: function(e) {
            e.isStatOf("CURED") ? this._isDoneStart = !0 : this._isRetryStart = !0
        },
        processForStateStartUpdate: function() {
            var e = this;
            this._isDoneStart && this.changeState("BONUS"), this._isRetryStart && n.BattleViewController.getInstance().stopContinueWizardDeferred().then(function() {
                e._startContinueWizard()
            })
        },
        _makeCallbackOfSoulPiece: function(e) {
            var t = this,
                i = r.CONTINUE_TYPE.SOUL_PIECE,
                s = n.BattleInfo.getInstance().getAppInitDataSessionKey(),
                o = !1;
            return function() {
                if (o) return;
                o = !0;
                var r = new n.ContinueTxn;
                r.setInfo(i, e[i]), t.startDeferred(r, s).then(function() {
                    return t.closeDeferred(r, s)
                }).then(function() {
                    return t.inquireAndUpdateStatusDeferred(r, s)
                }).then(function() {
                    t._processStartFinally(r)
                }).fail(function(e, n, r, i) {
                    t._onFail(e, n, r, i)
                })
            }
        },
        _makeCallbackOfCoin: function(e) {
            var t = this,
                i = r.CONTINUE_TYPE.COIN,
                s = n.BattleInfo.getInstance().getAppInitDataSessionKey(),
                o = !1;
            return function() {
                if (o) return;
                o = !0;
                var r = new n.ContinueTxn;
                r.setInfo(i, e[i]), FF.env.isWWRegion() ? t._checkBeforeUseCoin(e, r, s) : t._useCoinProcess(r, s)
            }
        },
        _checkBeforeUseCoin: function(e, t, n) {
            var i = this,
                s = r.CONTINUE_TYPE.COIN,
                o = e[s].balance ? e[s].balance : 0,
                u = e[s].payCost,
                a = function() {
                    i._isRetryStart = !0, i._onFail(null, null, {
                        isPurchasingCanceled: !0
                    }, null)
                };
            if (!t.canConsume()) {
                i.startDeferred(t, n).then(function() {
                    return i._showBalanceErrorWindowDeferred(o, u)
                }).always(function() {
                    a.call(i)
                });
                return
            }
            i._confirmWithUserDeferred(o, u).then(function() {
                i._useCoinProcess(t, n)
            }).fail(function() {
                a.call(i)
            })
        },
        _useCoinProcess: function(e, t) {
            var r = this;
            r.startDeferred(e, t).then(function() {
                var r = {
                    id: e.get("paymentProductId"),
                    quantity: 1,
                    payment_context: {
                        continue_id: e.get("continueId"),
                        session_key: t
                    }
                };
                return n.Api.purchaseItemDeferred(r)
            }).then(function() {
                return r.inquireAndUpdateStatusDeferred(e, t)
            }).then(function() {
                r._processStartFinally(e)
            }).fail(function(e, t, n, i) {
                r._onFail(e, t, n, i)
            })
        },
        startDeferred: function(t, r) {
            var i = this,
                s = e.randomString(8),
                o = this.a(),
                u = FF.env.userId;
            return n.Api.startContinueDeferred(t.get("typeId"), r, s).done(function(r) {
                var a = Chara.GOLBEZ.dispel(r.results, o).toString(Chara.enc.Utf8),
                    f = JSON.parse(a);
                return f = e.camelizeDeep(f), t.chkResult(f.digest, u, s), t.set("continueId", f.continueId), n.BattleInfo.getInstance().addNewContinueTxn(t), i._parent.saveResumeDataDeferred()
            }).fail(function(e, t, n, r) {
                return $.Deferred().reject(e, t, n).promise()
            })
        },
        closeDeferred: function(t, r) {
            var i = t.get("continueId"),
                s = t.get("typeId"),
                o = e.randomString(8),
                u = this.a(),
                a = FF.env.userId,
                f = $.Deferred();
            return n.Api.closeContinueDeferred(i, s, r, o).done(function(n) {
                var r = Chara.GOLBEZ.dispel(n.results, u).toString(Chara.enc.Utf8),
                    i = JSON.parse(r);
                i = e.camelizeDeep(i), t.chkResult(i.digest, a, o), f.resolve()
            }).fail(function(e, t, n, r) {
                f.reject(e, t, n)
            }), f.promise()
        },
        inquireAndUpdateStatusDeferred: function(t, r) {
            var i = this,
                s = t.get("continueId"),
                o = t.get("typeId"),
                u = e.randomString(8),
                a = this.a(),
                f = FF.env.userId;
            return n.Api.inquireContinueStatusDeferred(s, o, r, u).done(function(n) {
                var s = Chara.GOLBEZ.dispel(n.results, a).toString(Chara.enc.Utf8),
                    o = JSON.parse(s);
                return o = e.camelizeDeep(o), o.canContinue ? (t.chkResult(o.digest, f, u), t.chkInquireResult(o, r) ? t.changeStat("CURED") : t.changeStat("CANCELED")) : t.changeStat("CANCELED"), i._parent.saveResumeDataDeferred()
            }).fail(function(e, t, n, r) {
                i._onFail(e, t, n, r)
            })
        },
        processForStateRecoverEntry: function() {
            var e = this,
                t = n.BattleInfo.getInstance(),
                r = t.getLastContinueTxn(),
                i = t.getAppInitDataSessionKey();
            if (!r || r.isEnded()) {
                this.changeState("START");
                return
            }
            this.inquireAndUpdateStatusDeferred(r, i).then(function() {
                if (r.isStatOf("CURED")) e.changeState("BONUS");
                else {
                    if (!r.isStatOf("CANCELED")) throw new Error("invalid continue transaction stat in RECOVER. dump:" + r.makeDumpData());
                    e.changeState("START")
                }
            })
        },
        processForStateBonusEntry: function() {
            var e = this;
            kickmotor.platform.resetMobageDashboardListener();
            var t = function(t, r) {
                    var i = n.BattleInfo.getInstance().getLastContinueTxn();
                    i.fixBonusId(t), e._parent.saveResumeDataDeferred().then(function() {
                        r.resolve()
                    })
                },
                r = function() {
                    e.changeState("PRE_CONTINUE")
                };
            n.BattleViewController.getInstance().menuWindowView.showPowerUpWindow(t, r)
        },
        processForStatePreContinueEntry: function() {
            var e = this;
            this._isDonePreContinue = !1;
            var t = n.BattleInfo.getInstance().getLastContinueTxn();
            t.changeStat("DONE"), n.ActorMgr.resetBuddiesForContinue();
            var r = n.ContinueBonus.getInstance();
            r.exists() && r.give();
            var i = _.all(n.ActorMgr.getAllBuddies(), function(e) {
                return e.isAlive()
            });
            i || this._throwErrorOfCannotReviveAllBuddies(), this._parent.saveResumeDataDeferred().then(function() {
                var i = function() {
                        e._isDonePreContinue = !0
                    },
                    s = {
                        lastBonusId: t.get("bonusId"),
                        bonusAmount: r.amountByBonusId()
                    };
                n.BattleViewController.getInstance().showContinueDoneWindow(i, s)
            })
        },
        processForStatePreContinueUpdate: function() {
            this._isDonePreContinue && this.changeState("CONTINUE")
        },
        _throwErrorOfCannotReviveAllBuddies: function() {
            var e = n.ActorMgr.getDeadBuddies(),
                t = "deadNum:" + e.length;
            _.each(e, function(e) {
                t += ",pos:" + e.get("posId")
            });
            var r = n.BattleInfo.getInstance().toPlainObject().continueTxns;
            throw t += ",txns:" + JSON.stringify(r), new Error("cannot revive all buddies. " + t)
        },
        a: function() {
            return FF.env.f
        },
        _showBalanceErrorWindowDeferred: function(e, t) {
            return n.BattleViewController.getInstance().showBalanceErrorWindowDeferred(e, t)
        },
        _confirmWithUserDeferred: function(e, t) {
            return n.BattleViewController.getInstance().confirmWithUserDeferred(e, t)
        }
    })
}), define("scenes/battle/ContinueTxn", ["lib/ClassBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ContinueTxn = e.extend({
        initialize: function(t) {
            e.prototype.initialize.call(this), this.set("createdAt", (new Date).getTime())
        },
        setInfo: function(e, n) {
            _.extend(this._attributes, {
                continueId: void 0,
                typeId: e,
                name: n.name,
                stat: t.Conf.CONTINUE_TXN_STAT.STARTED,
                payTypeName: n.payTypeName,
                payCost: n.payCost,
                balance: n.balance ? n.balance : 0,
                bonusId: void 0,
                paymentTime: void 0,
                chkResults: []
            }), n.paymentProductId && this.set("paymentProductId", n.paymentProductId)
        },
        changeStat: function(e) {
            if (this.isEnded()) {
                var n = ["arg:", e, "stat", this.get("stat"), "resultData:", this.makeResultData()];
                throw new Error("this txn already has ended #" + JSON.stringify(n))
            }
            if (!_.has(t.Conf.CONTINUE_TXN_STAT, e)) throw new Error("unknown continueTxnStat." + e);
            var r = t.Conf.CONTINUE_TXN_STAT[e];
            this.set("stat", r);
            if (r === t.Conf.CONTINUE_TXN_STAT.CURED) {
                var i = t.BattleInfo.getInstance().get("actionTime");
                this.set("paymentTime", Math.floor(i / 1e3))
            }
        },
        isStatOf: function(e) {
            return this.get("stat") === t.Conf.CONTINUE_TXN_STAT[e]
        },
        isEnded: function() {
            return this.isStatOf("DONE") || this.isStatOf("CANCELED")
        },
        canConsume: function() {
            return this.get("balance") >= this.get("payCost")
        },
        fixBonusId: function(e) {
            if (!!this.get("bonusId") || !this.isStatOf("CURED")) {
                var n = ["arg:", e, "stat:", this.get("stat"), "resultData:", this.makeResultData(), "latestTransactionResults:"],
                    r = _.takeRight(t.BattleInfo.getInstance().getAllContinueTxns(), 10),
                    i = [];
                throw _.each(r, function(e) {
                    i.push(e.makeDumpData())
                }), n.push(i), new Error("this txn already fixed bonusId #" + JSON.stringify(n))
            }
            this.set("bonusId", e), this.changeStat("SELECTED")
        },
        chkResult: function(e, t, n) {
            var r = this.a(),
                i = this.b(),
                s = Chara.ZEROMUS(sprintf("%d:%s:%s", t, n, r), i).toString();
            this.get("chkResults").push(e === s)
        },
        chkInquireResult: function(e, t) {
            var n = _.all(["continueId", "typeId"], function(t) {
                return this.get(t) === +e[t]
            }, this);
            return n ? t !== e.sessionKey ? !1 : !0 : !1
        },
        chkNextTxnCreatedInDisallowTime: function(e) {
            var t = +this.get("createdAt") + 1e3;
            return e.get("createdAt") < t
        },
        a: function() {
            return FF.env.d
        },
        b: function() {
            return FF.env.e
        },
        makeResultData: function() {
            var e = this.get("chkResults"),
                n = e.length > 0 && _.all(e, function(e) {
                    return e
                });
            return {
                continue_id: this.get("continueId"),
                round_num: t.BattleInfo.getInstance().get("round"),
                enemy_info: t.EnemyPartyMgr.getInstance().makeResultData().current,
                continue_type: this.get("typeId"),
                bonus_type: this.get("bonusId"),
                action_time: this.get("paymentTime"),
                chk_result: n ? 1 : 0
            }
        },
        makeDumpData: function() {
            var e = this.makeResultData();
            return e.stat = this.get("stat"), e.createdAt = this.get("createdAt"), e
        },
        toPlainObject: function() {
            return {
                attributes: this._attributes
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            _.extend(this._attributes, e.attributes)
        }
    })
}), define("scenes/battle/Counters", ["util", "lib/ClassBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.Counters = t.extend({
        initialize: function(e) {
            t.prototype.initialize.call(this), this._actor = e, this._counterId = 1, this._counterInfos = {}
        },
        add: function(e, t, n, r) {
            var i = this._actor.get("paramId");
            return this.addWithParamId(i, e, t, n, r)
        },
        addWithParamId: function(e, t, n, r, i) {
            return this._counterInfos[this._counterId] = {
                paramId: e,
                abilityId: t,
                rate: _.isNumber(i) ? i : 100,
                condition: {
                    type: n,
                    value: r
                }
            }, this._counterId++
        },
        remove: function(e) {
            delete this._counterInfos[e]
        },
        evaluate: function(e) {
            var t = this;
            if (!n.util.DamageCalculator.isEnableCounter(e)) return;
            var r = _.any(this._getCurrentInfos(), function(t) {
                if (this._matches(t.condition, e) && this._lot(t.rate)) {
                    var r = t.abilityId,
                        i = this._actor,
                        s = {
                            isCounter: !0
                        };
                    return n.Commander.getInstance().register(r, i, s, {
                        interruptCounter: !0
                    }), !0
                }
                return !1
            }, this);
            return r
        },
        _getCurrentInfos: function() {
            var e = this._actor.get("paramId");
            return _.filter(this._counterInfos, function(t) {
                return t.paramId === e
            })
        },
        _matches: function(e, t) {
            var r = !1;
            switch (e.type) {
                case n.Conf.COUNTER_CONDTION_TYPE.ELEMENT:
                    e.value === t.element && (r = !0);
                    break;
                case n.Conf.COUNTER_CONDTION_TYPE.EXERCISE:
                    var i = t.ability.exerciseType();
                    e.value === i && (r = !0);
                    break;
                case n.Conf.COUNTER_CONDTION_TYPE.ALL:
                    r = !0;
                    break;
                case n.Conf.COUNTER_CONDTION_TYPE.CUSTOM:
                    r = this._matchesForCustom(e, t)
            }
            return r
        },
        _matchesForCustom: function(e, t) {
            var r = !0,
                i = n.Config.getInstance().get("CounterCustomConfig");
            i = i[e.value];
            if (!i) throw new Error("invalid counter custom config id. " + e.value);
            var s = i.exercises,
                o = i.elements,
                u = !!i.damagedOnly,
                a = !!i.skipInReflection,
                f = i.calcTypes;
            if (s) {
                var l = t.ability.exerciseType();
                _.include(s, l) || (r = !1)
            }
            o && (_.include(o, t.element) || (r = !1)), r && u && (t.damage && t.damage > 0 || (r = !1)), a && this._actor.isInReflection() && (r = !1);
            if (f) {
                var c = t.type;
                _.include(f, c) || (r = !1)
            }
            return r
        },
        _lot: function(t) {
            return e.lotByFraction(t)
        },
        toPlainObject: function() {
            return {
                counterId: this._counterId,
                counterInfos: this._counterInfos,
                attributes: this._attributes
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            _.extend(this._attributes, e.attributes), this._counterId = e.counterId || 1, this._counterInfos = e.counterInfos
        }
    })
}), define("scenes/battle/DataConstructor", [], function() {
    var e = FF.ns.battle;
    FF.ns.battle.DataConstructor = {
        getActorInfo: function(e) {
            var t = this;
            if (_.isArray(e)) return _.map(e, function(e) {
                return t.getActorInfo(e)
            });
            if (!e) throw new Error("actor not found");
            var n = this._getActorCommonInfo(e),
                r = e.get("animationInfo");
            e.isBuddy() && _.extend(n, {
                buddyAnimationInfo: r,
                weaponAnimationInfo: e.get("weapon").animationInfo,
                playTagList: this.getBuddyTagList(e),
                isSpecialReady: this.isSpecialReady(e),
                specialAuraType: this.getSpecialAuraType(e),
                isSupporterReady: this.isSupporterReady(e),
                handedness: e.get("handedness"),
                statusBonusFlgOf: e.getStatusBonusFlgOf(),
                statusBonusTypeOf: e.getStatusBonusTypeOf(),
                supporterInfo: this._getSupporterInfo(e)
            });
            if (e.isEnemy()) {
                n.isSpEnemy = e.container.isSpEnemy(), n.isFinalEnemy = e.container.isAllDead(), n.hpGaugeSize = r.hpGaugeSize, n.isInvisible = t._isInvisibleHpGauge(e);
                if (n.isSpEnemy) {
                    n.deadAnimateType = e.getDeadAnimateType();
                    var i = r.path.split("_");
                    _.extend(n, {
                        mainAssetId: sprintf("boss-%s_%s", i[0], 1),
                        subAssetId: sprintf("boss-%s_%s", i[0], i[1]),
                        usesFixPos: r.usesFixPos
                    })
                } else _.extend(n, {
                    childPosId: e.get("childPosId") || 1,
                    offset: [r.offsetX, r.offsetY],
                    scale: r.scale,
                    spriteAssetId: sprintf("enemy-%s", r.path)
                })
            }
            return n
        },
        _getActorCommonInfo: function(e) {
            var t = _.min([Math.floor(100 * e.get("elapsedAtbTime") / e.getAtbTime()), 100]),
                n = e.getAbility(),
                r = n ? _.min([Math.floor(100 * e.get("elapsedCastTime") / n.get("castTime")), 100]) : 0,
                i = e.getAttributes(["childPosId", "hp", "dispName", "maxHp", "row"]);
            return _.extend(i, {
                atbRate: t,
                castRate: r,
                count: e.getCount(),
                isCount: e.statusAilments.isCount(),
                hasDoom: e.statusAilments.hasDoom(),
                doomCount: e.getCount(),
                isBuddy: e.isBuddy(),
                isDead: e.isDead(),
                isForceEscaped: e.isForceEscaped(),
                isEnemy: e.isEnemy(),
                nodeNamePrefix: e.isBuddy() ? "player" : "enemy",
                posId: e.get("posId"),
                statusAilments: e.statusAilments.cloneIds(),
                uid: e.getUid(),
                posInfo: {
                    isEnemy: e.isEnemy(),
                    posId: e.get("posId"),
                    childPosId: e.get("childPosId") || 1
                }
            })
        },
        _getSupporterInfo: function(t) {
            if (t.isPossessedBySupporter()) {
                var n = e.ActorMgr.getSupporter();
                return {
                    buddyAnimationInfo: n.get("animationInfo"),
                    weaponAnimationInfo: n.get("weapon").animationInfo,
                    handedness: n.get("handedness"),
                    statusBonusFlgOf: n.getStatusBonusFlgOf(),
                    statusBonusTypeOf: n.getStatusBonusTypeOf()
                }
            }
            return void 0
        },
        getActorInfoByUid: function(t) {
            var n = e.ActorMgr.getByUid(t);
            return this.getActorInfo(n)
        },
        loadBuddyDrawInfo: function() {
            var t = e.ActorMgr.getAllBuddies();
            return this.getActorInfo(t)
        },
        loadEnemyDrawInfo: function() {
            var t = e.ActorMgr.getAliveEnemies();
            return this.getActorInfo(t)
        },
        getEnemyPosArrayByEnemyPosId: function(t) {
            var n = _.filter(e.ActorMgr.getAliveEnemies(), function(e) {
                return e.get("posId") === t
            });
            return _.map(n, function(e) {
                return "" + e.get("childPosId")
            })
        },
        getAbilityPanelInfo: function(t) {
            return _.map(t, function(t) {
                var n = !e.BattleInfo.getInstance().isEnded(),
                    r = t.isInfinity() ? e.TextMaster.getInstance().get("B10020") : "" + t.get("remainNum"),
                    i = sprintf("command_icon_%s", t.isDefensePanel() ? "defense" : t.get("abilityId")),
                    s = t.get("name");
                return {
                    posId: this.convPanelNoToPosId(t.get("panelNo")),
                    iconAssetId: i,
                    num: r,
                    name: s,
                    enabled: t.canRecept() && n,
                    visible: t.get("visible"),
                    highlighted: !!t.get("highlight")
                }
            }, this)
        },
        getSelectorAbilityPanelInfo: function() {
            var t = e.ActorMgr.getAbilityPanelSelector();
            if (!t) return;
            return {
                abilityPanelInfo: this.getAbilityPanelInfo(t.getAbilityPanels()),
                selector: this.getActorInfo(t),
                soulStrikeInfo: this.getSoulStrikeInfo(t),
                canSkipSelect: t.getSkip().canRecept()
            }
        },
        getSupporterSoulStrikeInfo: function() {
            var t = e.ActorMgr.getSupporter();
            if (!t) return;
            var n = t.get("animationInfo"),
                r = t.getSupporterSoulStrike(),
                i = e.BuddyPartyMgr.getInstance().canReceptSupporterSoulStrike(),
                s = e.BuddyPartyMgr.getInstance().isDuringSupporterSoulStrike();
            return {
                charaAssetId: "buddy-" + n.path,
                assetId: "command_icon_" + r.get("abilityId"),
                soulStrikeName: r.get("name"),
                enabled: i && !s,
                restCount: r.get("restCount")
            }
        },
        convPanelNoToPosId: function(t) {
            return e.Config.getInstance().get("PanelNoToPosId", t)
        },
        convPosIdToPanelNo: function(t) {
            return e.Config.getInstance().get("PosIdToPanelNo", t)
        },
        getAllPanelPosIds: function() {
            return _.keys(e.Config.getInstance().get("PosIdToPanelNo"))
        },
        getActionResultInfo: function(e) {
            var t = e.executer,
                n = e.ability,
                r = e.damageObjects;
            return {
                executerInfo: this.getActorInfo(t),
                abilityInfo: n ? this.getAbilityInfo(n) : {},
                receiverInfo: this.getDamageObjectInfo(r)
            }
        },
        getDamageObjectInfo: function(e) {
            var t = this;
            if (_.isArray(e)) return _.map(e, function(e) {
                return t.getDamageObjectInfo(e)
            });
            var n = e,
                r = _.extend(this.getActorInfo(n.receiver), {
                    advantage: n.advantage,
                    canHit: n.canHit,
                    damage: n.damage,
                    isNoeffect: n.isNoeffect,
                    isCritical: n.isCritical,
                    isRecovery: n.damage >= 0,
                    isAbilityPanel: !!n.isAbilityPanel,
                    currHp: n.curr || n.currHp,
                    prevHp: n.prev || n.prevHp,
                    maxHp: n.max || n.maxHp,
                    reflector: n.reflector ? this.getActorInfo(n.reflector) : void 0,
                    absorber: n.absorber ? this.getActorInfo(n.absorber) : void 0,
                    absorbHp: n.absorbHp,
                    fakeDamage: n.fakeDamage,
                    isNotShownHitMotion: n.isNotShownHitMotion,
                    isNotShownDamageMotion: n.isNotShownDamageMotion
                });
            return n.appendedStatusAilments && n.appendedStatusAilments.hasAtkStatusAilments && (r.appendedStatusAilments = {
                isNoeffect: n.appendedStatusAilments.isNoeffect,
                canHit: n.appendedStatusAilments.canHit
            }), r
        },
        getAbilityInfo: function(e) {
            var t = e.get("animationInfo") || {};
            return {
                abilityAnimationId: "" + t.id,
                atkMotion: t.atkMotion,
                launchType: t.launchType,
                shotType: t.shotType,
                hitType: t.hitType,
                hitArg: t.hitArg,
                missHit: t.missHit,
                launchBack: t.launchBack,
                returnType: t.returnType,
                returnShot: t.returnShot,
                returnHit: t.returnHit,
                reverseShot: t.reverseShot,
                reverseHit: t.reverseHit,
                charaOutTag: t.charaOut,
                charaInTag: t.charaIn,
                otherOutTag: t.otherOut,
                otherInTag: t.otherIn,
                damageTag: t.damageTag,
                recoveryTag: t.recoveryTag,
                launchNextTag: t.launchNextTag,
                shotNextTag: t.shotNextTag,
                hitNextTag: t.hitNextTag,
                hasHitTiming: t.hasHitTiming ? !0 : !1,
                launchSpriteNum: t.launchSpriteNum,
                shotSpriteNum: t.shotSpriteNum,
                hitSpriteNum: t.hitSpriteNum,
                launchParticleJson: t.launchParticleJson,
                shotParticleJson: t.shotParticleJson,
                hitParticleJson: t.hitParticleJson,
                dispName: e.get("name"),
                aliasName: e.get("aliasName"),
                isSoulStrike: e.get("isSoulStrike") ? !0 : !1,
                isInLongAction: this._checkLongActionAbility(e)
            }
        },
        _checkLongActionAbility: function(t) {
            return t.get("isSoulStrike") || t.get("isSupporterSoulStrike") ? !0 : t.get("exerciseType") === e.Conf.EXERCISE_TYPE.SUMMON ? !0 : !1
        },
        getCurrentAbility: function() {
            var t = e.BattleInfo.getInstance().getCurrentAbility();
            return t ? this.getAbilityInfo(t) : void 0
        },
        getSoulStrikeInfo: function(e) {
            var t = e.get("animationInfo"),
                n = e.getSoulStrike(),
                r = e.getSoulStrikePanels();
            return _.map(r, function(r) {
                return {
                    charaAssetId: "buddy-" + t.path,
                    assetId: "command_icon_" + r.get("abilityId"),
                    charaName: e.get("dispName"),
                    soulStrikeName: r.get("name"),
                    soulStrikeDispName: r.get("dispName"),
                    enabled: r.canRecept(),
                    point: n.get("point"),
                    consumePoint: r.get("consumeSoulStrikePoint"),
                    slot: r.get("slot")
                }
            })
        },
        getActiveTarget: function() {
            var t = e.ActorMgr.getActiveTarget();
            return t ? this.getActorInfo(t) : void 0
        },
        getSoulStrikePoint: function() {
            var t = e.ActorMgr.getAbilityPanelSelector();
            return t ? t.getSoulStrike().get("point") : 0
        },
        getBuddyTagList: function(t) {
            var n = ["idle"];
            if (t.isPossessedBySupporter()) return n;
            var r = t.statusAilments.cloneIds(),
                i = e.Config.getInstance().get("StatusAilments", "GRAPHIC_TAG"),
                s = _.filter(r, function(e) {
                    return i[e]
                }),
                o = _.map(s, function(e) {
                    return i[e]
                });
            t.isFatal() && n.push("fatal");
            if (t.isStateInCast()) {
                var u = t.getAbility().get("exerciseType"),
                    a = e.Config.getInstance().get("ExerciseTypeToCastTag"),
                    f = a[u];
                f && n.push(f)
            }
            return n = _.union(n, o), n
        },
        getSpecialAuraType: function(t) {
            return t.isAlive() && t.isStateInCast() ? t.getAbility().get("hasParamBooster") ? e.Conf.SPECIAL_AURA_TYPE.HAS_PARAM_BOOSTER : e.Conf.SPECIAL_AURA_TYPE.NORMAL : e.Conf.SPECIAL_AURA_TYPE.NONE
        },
        isSpecialReady: function(e) {
            return e.isAlive() && e.isStateInCast() && e.getAbility().get("isSoulStrike") ? !0 : !1
        },
        isSupporterReady: function(e) {
            return e.isStateInCast() && e.getAbility().get("isSupporterSoulStrike") ? !0 : !1
        },
        getDeformInfoByAnimationInfo: function(e) {
            var t = e.animationInfo.deformTag;
            if (t) {
                var n = e.enemyContainer,
                    r = n.get("deformAnimationInfo"),
                    i = _.find(r, function(e) {
                        return e.deformTag === t
                    });
                if (!i) throw new Error("deform info not found.tag=" + t);
                return this._getDeformInfo(e, i)
            }
            var s = e.animationInfo.animationId;
            return this.getDeformInfo(_.extend(e, {
                animationId: s
            }))
        },
        getDeformInfo: function(e) {
            var t = e.enemyContainer,
                n = e.animationId,
                r = t.get("deformAnimationInfo"),
                i = _.find(r, function(e) {
                    return +e.id === +n
                });
            if (!i) throw new Error("deform info not found.id=" + n);
            return this._getDeformInfo(e, i)
        },
        _getDeformInfo: function(e, t) {
            var n = this,
                r = e.enemyContainer,
                i = _.map(t.state, function(e) {
                    return "" + e
                }),
                s = r.getChildren(),
                o = [],
                u = [];
            return _.each(s, function(e) {
                e.isDead() && o.push("" + e.get("childPosId")), n._isInvisibleHpGauge(e) && u.push("" + e.get("childPosId"))
            }), i = _.difference(i, o), {
                posId: "5_03",
                deformTag: t.deformTag,
                posArray: i,
                isRandom: t.isRandom,
                shouldDeformAllNodes: e.shouldDeformAllNodes,
                invisibleHpGaugePosArray: u,
                skipEnemyName: e.skipEnemyName
            }
        },
        getDropItemInfo: function(e) {
            return _.map(e, function(e) {
                return {
                    executerInfo: this.getActorInfo(e.executer),
                    receiverInfo: this.getDropItemObjectInfo(e.dropItemObjects),
                    item: this.getDropItemItemInfo(e.item)
                }
            }, this)
        },
        getDropItemObjectInfo: function(t) {
            var n = this;
            if (_.isArray(t)) return _.map(t, function(e) {
                return n.getDropItemObjectInfo(e)
            });
            var r = void 0;
            switch (t.item.type) {
                case e.Conf.DROP_ITEM_TYPE.POTION:
                case e.Conf.DROP_ITEM_TYPE.HI_POTION:
                case e.Conf.DROP_ITEM_TYPE.X_POTION:
                    r = this.getDamageObjectInfo(t);
                    break;
                case e.Conf.DROP_ITEM_TYPE.ETHER:
                case e.Conf.DROP_ITEM_TYPE.TURBO_ETHER:
                    r = _.extend({
                        damageNum: t.damage
                    }, this.getActorInfo(t.receiver));
                    break;
                default:
                    r = t
            }
            return r
        },
        getDropItemItemInfo: function(e) {
            return {
                assetId: sprintf("drop_item_%s_%s", e.type, e.rarity),
                type: e.type,
                rarity: e.rarity
            }
        },
        getDropMateriaInfo: function(e) {
            return {
                itemId: e.itemId,
                buddyPos: e.buddyPos,
                name: e.name
            }
        },
        getGil: function() {
            return e.BuddyPartyMgr.getInstance().get("gil")
        },
        getOrb: function() {
            return e.BuddyPartyMgr.getInstance().get("orb")
        },
        getTreasure: function() {
            return e.BuddyPartyMgr.getInstance().get("treasure")
        },
        getEventItem: function() {
            return e.BuddyPartyMgr.getInstance().get("eventItem")
        },
        getBattleBgm: function() {
            var t = e.BattleInfo.getInstance().getBattleParam();
            return t.bgm
        },
        getWinBgm: function() {
            return e.BattleInfo.getInstance().getBattleInitData().battle.winBgm || e.Conf.BGM_NAME.VICTORY
        },
        canOperateBattle: function() {
            var t = e.BattleInfo.getInstance();
            return t.canOperateBattle()
        },
        isJustEnded: function() {
            var t = e.BattleInfo.getInstance();
            return !!t.isJustEnded()
        },
        isAllEnded: function() {
            var t = e.BattleInfo.getInstance();
            return !!t.get("isAllEnded")
        },
        isAutoEnabled: function() {
            var t = e.BattleInfo.getInstance();
            return t.get("isClear") ? !1 : t.isEnded() && !t.isVictory() ? !1 : !0
        },
        isChangedBackground: function() {
            var t = e.BattleInfo.getInstance();
            for (var n = 1; n <= t.get("round"); n++) {
                var r = t.getBattleParam(n);
                if (r.backgroundChangeType === e.Conf.BACKGROUND_CHANGE_TYPE.WALK || r.backgroundChangeType === e.Conf.BACKGROUND_CHANGE_TYPE.STOP) return !0
            }
            return !1
        },
        judgePauseOrEscapeAvailable: function() {
            var t = _.filter(e.ActorMgr.getAllBuddies(), function(e) {
                return e.judgeDeath() ? !1 : e.isContinuousBattle() ? !0 : !1
            });
            return t.length > 0
        },
        getBattleSpeedIndex: function() {
            return e.BattleInfo.getInstance().getBattleSpeedIndex()
        },
        _isInvisibleHpGauge: function(e) {
            return e.isInvisible() || e.isDead() || e.isInvincible()
        }
    }
}), define("scenes/battle/DeathFsm", ["jquery", "lib/NameConventionFsm"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf;
    FF.ns.battle.DeathFsm = t.extend({
        initialize: function(e) {
            t.prototype.initialize.apply(this, arguments), this._isDone = !1, this.data = e, this.changeState("IDLE")
        },
        processForStateIdleEntry: function() {
            var t = this;
            e.Deferred().resolve().promise().then(function() {
                return t._playDeadDeferred()
            }).then(function() {
                return t._playDropItemDeferred()
            }).then(function() {
                return t._playMateriaCutinDeferred()
            }).then(function() {
                t._isDone = !0
            })
        },
        processForStateIdleUpdate: function() {
            if (!this._isDone) return;
            this.changeState("END")
        },
        _playDeadDeferred: function() {
            var t = e.Deferred(),
                i = this.data.deadActors,
                s = this.data.judge,
                o = n.BattleViewController.getInstance().createAnimation({
                    animationType: r.ANIMATION_TYPE.DEAD,
                    actorInfo: i
                });
            return o.addCallbackOnce("end", function() {
                t.resolve()
            }), o.play(), t.promise()
        },
        _playDropItemDeferred: function() {
            var t = this.data.deadActors,
                i = this.data.judge,
                s = _.filter(t, function(e) {
                    return e.isEnemy()
                }),
                o = n.util.DropItem.give(s, i),
                u = e.Deferred(),
                a = n.BattleViewController.getInstance().createAnimation({
                    animationType: r.ANIMATION_TYPE.DROP_ITEM,
                    dropItemInfo: o
                });
            return a.addCallbackOnce("end", function() {
                n.util.DropItem.applyResult(o), u.resolve()
            }), a.play(), u.promise()
        },
        _playMateriaCutinDeferred: function() {
            if (this.data.judge !== n.Conf.JUDGE.VICTORY) return e.Deferred().resolve().promise();
            var t = n.BattleInfo.getInstance().getDropMaterias();
            if (t.length === 0) return e.Deferred().resolve().promise();
            FF.logger.debug("DROP_MATERIAS", t);
            var r = n.BattleViewController.getInstance().materiaDropView,
                i = e.Deferred().resolve();
            return _.each(t, function(e) {
                i = i.then(function() {
                    return r.showDeferred(n.DataConstructor.getDropMateriaInfo(e))
                })
            }), i.promise()
        }
    })
}), define("scenes/battle/Debug", ["util"], function(e) {
    var t = FF.ns.battle,
        n = {
            _toggleDebugInfo: function() {
                this._debugNo = this._debugNo || 0, this._debugNo++, this._showDebugInfo() || (this._debugNo = 0)
            },
            _showDebugInfo: function() {
                var e = this._debugNo || 0;
                if (e === 0) return !1;
                var n = "";
                if (e === 1) n += "native info. fps:" + FF.scene.fps, this._showDebugNativeInfo(!0);
                else if (e === 2) this._showDebugNativeInfo(!1), _.each(t.ActorMgr.getAll(), function(e) {
                    n += this._getDebugBaseText(e)
                }, this);
                else {
                    var r = 3;
                    n === "" && (n = this._makeActorInfo(r)), n === "" && (r += Math.ceil(t.ActorMgr.getAll().length / 3), n = this._makeScoreInfo(r))
                }
                return t.BattleViewController.getInstance().setDebugText(n), n !== ""
            },
            _makeActorInfo: function(e) {
                var n = this._debugNo || 0,
                    r = "",
                    i = t.ActorMgr.getAll(),
                    s = (n - e) * 3;
                return i = i.slice(s, s + 3), _.each(i, function(e) {
                    r += this._getDebugDetailText(e)
                }, this), this._debugNoForActor = n + 1, r === "" && (this._debugNoForActora = 0), r
            },
            _makeScoreInfo: function(e) {
                var n = this._debugNo || 0,
                    r = "",
                    i = t.BattleInfo.getInstance().getBattleInitData().battle.score,
                    s = [].concat(_.values(i.general), _.values(i.specific)),
                    o = n - e,
                    u = _.first(s.slice(o, o + 1));
                if (u) {
                    var a = t.Score.toPlainObject(),
                        f = void 0;
                    f || (f = a.general[u.no]), f || (f = a.specific[u.no]), r += JSON.stringify(_.extend({
                        type: u.type
                    }, f))
                }
                return this._debugNoForScore = n + 1, r === "" && (this._debugNoForScore = 0), r
            },
            _showDebugNativeInfo: function(e) {
                kickmotor.nativefn.call("showNativeInfo", {
                    isShow: e,
                    x: 4,
                    y: 20
                })
            },
            _getDebugBaseText: function(e) {
                if (!FF.env.isDevelop()) return;
                var t = "";
                if (e.isBuddy()) {
                    var n = e.getSoulStrike();
                    t += sprintf("  [%s]:HP:%d/%d ATB:%d%% SS:%d{n}", e.get("dispName"), e.get("hp"), e.get("maxHp"), _.min([Math.floor(100 * e.get("elapsedAtbTime") / e.getAtbTime()), 100]), n ? n.get("point") : 0)
                } else t += sprintf("  [%s%d_%d]:HP:%d/%d ATB:%d%% SA:%s{n}", e.get("dispName"), e.get("no"), e.getId(), e.get("hp"), e.get("maxHp"), _.min([Math.floor(100 * e.get("elapsedAtbTime") / e.getAtbTime()), 100]), e.statusAilments.getRefs().join("_"));
                return t
            },
            _getDebugDetailText: function(e) {
                var t = "";
                return e.isBuddy() ? t += sprintf("  [%s]:", e.get("dispName")) : t += sprintf("  [%s%d_%d]:", e.get("dispName"), e.get("no"), e.getId()), _.each(["atk", "def", "matk", "mdef", "mnd", "acc", "spd", "eva", "critical"], function(n) {
                    t += sprintf("%s:%s ", n, e.get(n))
                }), t += sprintf("atkEl:%s ", e.get("atkElement")), t += sprintf("atkSa:%s ", this._objectToString(e.get("atkStatusAilments"))), t += sprintf("matkEl:%s ", this._objectToString(e.get("matkElementMap"))), t += sprintf("defAttr:%s ", this._objectToString(e.get("defAttributeMap"))), t += "{n}", t
            },
            _objectToString: function(e) {
                return _.map(e, function(e, t) {
                    return t + ":" + e
                }).join(" ")
            },
            increaseSsGauge: function() {
                var e = t.ActorMgr.getAbilityPanelSelector();
                if (!e) return;
                var n = e.getSoulStrike(),
                    r = n.get("point");
                n.set("point", _.min([r + 50, 1500]))
            },
            redirectDebugScene: function() {
                var e = location.pathname || "/dff/debug/";
                e.match("debug") || (e = "/dff/debug/"), FF.scene.redirect(e)
            },
            killEnemies: function() {
                _.each(t.ActorMgr.getAliveEnemies(), function(e) {
                    e.set("hp", 0)
                })
            },
            _isProcessed: !1,
            _processOnce: function() {
                if (this._isProcessed) return;
                this._enableBattleDebugContinue(), this._isProcessed = !0
            },
            _enableBattleDebugContinue: function() {
                var n = t.BattleInfo.getInstance().getAppInitDataSessionKey();
                if (n === "debug") {
                    var r = FF.scene.battleEventMgr.battleProcessMgr.continueFsm;
                    r._makeCallbackOfSoulPiece = function(n) {
                        return function() {
                            var i = new t.ContinueTxn,
                                s = t.Conf.CONTINUE_TYPE.SOUL_PIECE;
                            i.setInfo(s, n[s]), i.set("continueId", e.getTime()), i.changeStat("CURED"), t.BattleInfo.getInstance().addNewContinueTxn(i), r._processStartFinally(i)
                        }
                    }
                }
            }
        };
    FF.ns.battle.Debug = {
        toggleInfo: function() {
            if (!FF.env.isDevelop()) return;
            n._toggleDebugInfo()
        },
        update: function() {
            if (!FF.env.isDevelop()) return;
            n._processOnce(), n._showDebugInfo()
        },
        increaseSsGauge: function() {
            if (!FF.env.isDevelop()) return;
            n.increaseSsGauge()
        },
        redirectDebugScene: function() {
            if (!FF.env.isDevelop()) return;
            n.redirectDebugScene()
        },
        killEnemies: function() {
            if (!FF.env.isDevelop()) return;
            n.killEnemies()
        }
    }
}), define("scenes/battle/EnemyContainer", ["lib/EventBase"], function(e) {
    var t = FF.ns.battle,
        n = 1;
    FF.ns.battle.EnemyContainer = e.extend({
        initialize: function(r, i) {
            e.prototype.initialize.apply(this, arguments), _.extend(this._attributes, r), this._children = i || {}, this._dropItemList = [], _.each(i, function(e) {
                e.container = this, this._dropItemList = this._dropItemList.concat(e.get("dropItemList"))
            }, this), this._shouldDeformAllNodesInAppearing = !1;
            var s = r.aiId;
            s && (this.stateMap = t.ai.StateMapBuilder.createById(s, this)), this.containerUid = n++
        },
        update: function() {
            this.stateMap && this.stateMap.update()
        },
        addChild: function(e) {
            var t = e.get("no");
            this._children[t] = e
        },
        getChild: function(e) {
            var t = this._children[e];
            if (!t) throw new Error("sp enemy child(enemy) not found.no=" + e);
            return t
        },
        getChildren: function() {
            return _.values(this._children)
        },
        getAliveChildren: function() {
            return _.filter(this.getChildren(), function(e) {
                return e.isAlive()
            })
        },
        getId: function() {
            return this.get("id") || 0
        },
        isSpEnemy: function() {
            return this.get("isSpEnemy")
        },
        isAllDead: function() {
            return _.all(this.getChildren(), function(e) {
                return e.isDead()
            })
        },
        getNos: function() {
            return _.keys(this._children)
        },
        getAppearanceAnimationId: function() {
            var e = _.find(this.get("deformAnimationInfo"), function(e) {
                return e.deformTag === "in"
            });
            return e ? e.id : void 0
        },
        getDropItemList: function() {
            return this._dropItemList
        },
        notifyJudgedDeath: function(e) {
            return this.stateMap ? this.stateMap.notifyJudgedDeath(e) : !0
        },
        isContinuousBattle: function() {
            return _.any(this.getChildren(), function(e) {
                return e.isContinuousBattle()
            })
        },
        isBuddy: function() {
            return !1
        },
        isEnemy: function() {
            return !0
        },
        isContainer: function() {
            return !0
        },
        setEnabledShouldDeformAllNodesInAppearing: function() {
            this._shouldDeformAllNodesInAppearing = !0
        },
        shouldDeformAllNodesInAppearing: function() {
            return this._shouldDeformAllNodesInAppearing
        }
    })
}), define("scenes/battle/EnemyParty", ["lib/ClassBase"], function(e) {
    FF.ns.battle.EnemyParty = e.extend({
        initialize: function() {}
    })
}), define("scenes/battle/EnemyPartyMgr", ["lib/ClassBase"], function(e) {
    var t = FF.ns.battle,
        n = e.extend({
            initialize: function(e) {
                this.activeTarget = new t.ActiveTarget
            },
            setParent: function(e) {
                this.parent = e
            },
            load: function(e) {},
            update: function() {},
            makeResultData: function() {
                return this._allEnemyCsv || (this._allEnemyCsv = this._makeAllEnemyLogInfo()), {
                    current: _.map(t.ActorMgr.getAllEnemies(), function(e) {
                        return [t.BattleInfo.getInstance().get("round"), e.getId(), e.get("no"), e.getBaseParam().lv, Math.floor(e.get("hp") / e.get("maxHp") * 100)]
                    }, this),
                    all: this._allEnemyCsv
                }
            },
            _makeAllEnemyLogInfo: function() {
                var e = [],
                    n = function(t, r, i) {
                        var s = r.shift(),
                            o = t[s];
                        for (var u = 0, a = o.length; u < a; u++) {
                            s === "rounds" && _.extend(i, {
                                round: o[u].round
                            }), s === "enemy" && _.extend(i, {
                                id: o[u].id
                            }), s === "children" && _.extend(i, {
                                no: o[u].no
                            });
                            if (r.length > 0) {
                                var f = [].concat(r);
                                n(o[u], f, i)
                            } else e.push([i.round, i.id, i.no, o[u].params[0].lv])
                        }
                    };
                return n(t.BattleInfo.getInstance().getBattleInitData().battle, ["rounds", "enemy", "children"], {}), e
            }
        }),
        r = void 0;
    FF.ns.battle.EnemyPartyMgr = {
        getInstance: function() {
            return r || (r = new n), r
        }
    }
}), define("scenes/battle/EventFsm", ["lib/ClassBase"], function(e) {
    FF.ns.battle.EventFsm = e.extend({
        initialize: function() {},
        update: function() {
            this.parent.battleUpdate()
        },
        setParent: function(e) {
            this.parent = e
        }
    })
}), define("scenes/battle/ExpireFsm", ["lib/NameConventionFsm"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    FF.ns.battle.ExpireFsm = e.extend({
        initialize: function() {
            e.prototype.initialize.call(this), this.changeState("IDLE")
        },
        processForStateIdleEntry: function() {
            t.BattleViewController.getInstance().showSystemWindow(t.Conf.SYSTEM_WINDOW.EXPIRE, function() {
                t.BattleInfo.getInstance().set("isExpired", !0)
            })
        }
    })
}), define("scenes/battle/ExternalFunc", [], function() {
    var e = FF.ns.battle;
    FF.ns.battle.ExternalFunc = {
        openLoading: function() {
            e.BattleViewController.getInstance().loadingView.open()
        },
        closeLoading: function() {
            e.BattleViewController.getInstance().loadingView.close()
        }
    }
}), define("scenes/battle/ExternalUserAuth", ["jquery", "underscore", "lib/ExternalUserAuth"], function(e, t, n) {
    var r = FF.ns.battle;
    r.ExternalUserAuth = t.extend({}, n, {
        _callCreateHashApiDeferred: function(t) {
            var n = e.Deferred(),
                i = t.guestId,
                s = t.callbackUrl;
            return !i || !s ? n.reject().promise() : (r.Api.createExternalUserAuthHashDeffered(i, s).done(function(e) {
                t.inviteId = e.invite_id, t.hash = e.hash, n.resolve(t)
            }).fail(function() {
                n.reject()
            }), n.promise())
        }
    })
}), define("scenes/battle/LotteryBox", ["util", "lib/ClassBase"], function(e, t) {
    FF.ns.battle.LotteryBox = t.extend({
        initialize: function(t, n) {
            this._params = {
                lottery: e.cloneDeep(t)
            }, this.changeBox(n), this.resetBox()
        },
        lot: function() {
            var t = this._box,
                n = e.lot(t, function(e) {
                    return +e
                }, {
                    returnIndex: !0
                });
            return t[n] --, this._isBlank() && this.resetBox(), this._params.lottery[n]
        },
        lotWithout: function(e) {
            if (e.length === 0) return this.lot();
            var t = function(t) {
                    var n = e.indexOf(t) < 0;
                    return n
                },
                n = this._params.lottery,
                r = [];
            _.each(n, function(e, n) {
                if (!t(e)) return;
                r.push(n)
            }, this);
            if (r.length === 0) return FF.ns.battle.Conf.ABILITY_ID_OF.DO_NOTHING;
            var i = _.all(r, function(e) {
                var t = this._box[e];
                return +t <= 0
            }, this);
            i && this.resetBox();
            for (var s = 0; s < 20; s++) {
                var o = this.lot();
                if (!o) throw new Error("invalid box");
                if (t(o)) return o
            }
            var u = -1,
                a = 0,
                f = 0;
            _.each(r, function(e) {
                var t = this._box[e];
                a < t && (u = e, a = t, f = n[e])
            }, this);
            if (f === 0) throw new Error("enable ability is not found");
            return this._box[u] --, this._isBlank() && this.resetBox(), f
        },
        changeBox: function(e) {
            if (_.isEmpty(e) || !_.isArray(e)) throw new Error("invalid box data");
            this._params.box = e, this.resetBox()
        },
        resetBox: function() {
            this._box = e.cloneDeep(this._params.box)
        },
        getCandidates: function() {
            return this._params.lottery
        },
        _isBlank: function() {
            return _.all(this._box, function(e) {
                return +e <= 0
            })
        }
    })
}), define("scenes/battle/MateriaFactory", ["./Conf"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.MateriaFactory = {
        getInfo: function(e) {
            var t = _.find(this.typeMap, function(t) {
                return t.type === e
            }, this);
            if (!t) throw new Error("Materia Info not found.type=" + e);
            return t
        },
        createMateriaHolder: function(e, n) {
            var r = [];
            _.each(n, function(t) {
                var n = this.create(e, t);
                r.push(n)
            }, this);
            var i = new t.MateriaHolder(e, r);
            return i
        },
        create: function(e, n) {
            var r = n.effectType,
                i = this.getInfo(r),
                s = t.materia[i.className];
            if (!s) throw new Error("MateriaInfo not found.type=" + r);
            var o = new s(e, n);
            return o
        },
        typeMap: [{
            type: 1,
            className: "FirstAttackMateria"
        }, {
            type: 2,
            className: "PanelNumMateria"
        }, {
            type: 3,
            className: "ParamMateria"
        }, {
            type: 4,
            className: "ParamAndInflictSaMateria"
        }, {
            type: 5,
            className: "InflictSaMateria"
        }, {
            type: 6,
            className: "InflictSaWhenHpFallsMateria"
        }, {
            type: 7,
            className: "DamageBoostWhenWeaknessMateria"
        }, {
            type: 8,
            className: "DamageBoostByWeaponMateria"
        }, {
            type: 9,
            className: "DamageBoostAbilityMateria"
        }, {
            type: 10,
            className: "DamageBoostElementMateria"
        }, {
            type: 11,
            className: "HealBoostMateria"
        }, {
            type: 12,
            className: "CounterMateria"
        }, {
            type: 13,
            className: "PanelSwapMateria"
        }, {
            type: 14,
            className: "ParamBoostInBuddyDeadMateria"
        }, {
            type: 16,
            className: "ParamBoostInHpDecreaseMateria"
        }, {
            type: 17,
            className: "PanelRandomSwapMateria"
        }, {
            type: 18,
            className: "BlackMagicDamageBoostByWeaponMateria"
        }, {
            type: 19,
            className: "PanelNumMateriaByCategory"
        }, {
            type: 20,
            className: "MateriaBase"
        }, {
            type: 21,
            className: "DamageBoostByWeaponWithAllowableTypesMateria"
        }, {
            type: 22,
            className: "ParamBoostByArmorMateria"
        }, {
            type: 23,
            className: "SoulStrikePointFactorBoostMateria"
        }, {
            type: 24,
            className: "PanelNumMateriaByMultiCategory"
        }, {
            type: 25,
            className: "ParamBoostByWeaponMateria"
        }, {
            type: 26,
            className: "SeqActionByCategoryMateria"
        }, {
            type: 27,
            className: "MateriaBase"
        }]
    }
}), define("scenes/battle/MateriaHolder", ["util", "lib/NameConventionFsm"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.MateriaHolder = t.extend({
        initialize: function(e, n) {
            t.prototype.initialize.call(this), this._actor = e, this._materias = {}, _.each(n, function(e) {
                this._materias[e.getSlot()] = e
            }, this)
        },
        update: function() {
            _.each(this._materias, function(e) {
                e.update()
            })
        },
        notify: function() {
            var e = arguments;
            _.each(this._materias, function(t) {
                t.notify.apply(t, e)
            })
        },
        toPlainObject: function() {
            var e = {};
            return _.each(this._materias, function(t, n) {
                e[n] = t.toPlainObject()
            }), {
                materias: e
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            _.each(this._materias, function(t, n) {
                var r = e.materias[n];
                !r, t.applyPlainObject(r)
            })
        }
    })
}), define("scenes/battle/Message", ["util", "lib/Events", "lib/ClassBase"], function(e, t, n) {
    var r = FF.ns.battle,
        i = r.Conf,
        s = {},
        o = void 0,
        u = 1500,
        a = function(e) {
            var t = e.type,
                n = s[t];
            if (!n) throw new Error("invalid message type.t=" + t);
            return new n(e)
        },
        f = "{N}",
        l = FF.ns.battle.Message = _.extend({
            load: function(e) {
                o = {}, _.each(e, function(e) {
                    o[e.id] = a(e)
                }, this), this._queue = [], this._showingMsgInfo = void 0
            },
            reset: function() {
                _.each(o, function(e) {
                    e.reset()
                })
            },
            show: function(t) {
                t = e.option({
                    message: "",
                    duration: u,
                    callback: void 0,
                    id: 0
                }, t);
                if (t.message.indexOf(f) >= 0) {
                    var n = t.message.split(f),
                        r = t.callback;
                    for (var i = 0, s = n.length; i < s; i++) {
                        var o = i === s - 1 ? r : void 0;
                        this.show(_.extend(t, {
                            message: n[i]
                        }, {
                            callback: o
                        }))
                    }
                    return
                }
                this._showingMsgInfo ? this._queue.push(t) : this._show(t)
            },
            showTextMaster: function(e) {
                var t = r.TextMaster.getInstance().get(e);
                this.show({
                    message: t
                })
            },
            showByMessageId: function(e, t) {
                var n = o[e];
                n && n._show(t)
            },
            update: function() {
                var e = this._showingMsgInfo;
                e && (e.duration -= FF.scene.elapsedTime, e.duration <= 0 && (r.BattleViewController.getInstance().hideMessage(), e.callback && e.callback(), this.trigger("Message::hide", e), this._showingMsgInfo = void 0)), !this._showingMsgInfo && this._queue.length > 0 && this._show(this._queue.shift())
            },
            _show: function(e) {
                r.BattleViewController.getInstance().showMessage(e.message), this._showingMsgInfo = e, FF.logger.debug("MSG:" + e.message)
            }
        }, t),
        c = n.extend(_.extend({
            initialize: function(e) {
                this._initData = e, this._init(e), this._displayNum = 0
            },
            reset: function() {
                this._displayNum = 0
            },
            _show: function(t) {
                t = e.option({
                    callback: void 0,
                    duration: u
                }, t);
                if (!this._shouldShow()) {
                    t.callback && t.callback();
                    return
                }
                this._displayNum++, l.show({
                    id: this._initData.id,
                    message: this._initData.message,
                    callback: t.callback,
                    duration: t.duration
                })
            },
            _shouldShow: function() {
                var e = this._initData.displayType;
                switch (e) {
                    case i.MESSAGE_DISPLAY_TYPE.ONCE:
                        return this._displayNum <= 0;
                    case i.MESSAGE_DISPLAY_TYPE.REPEAT:
                        return !0;
                    default:
                        throw new Error("invalid message display type." + e)
                }
            },
            _init: function() {}
        }, t));
    s[i.MESSAGE_TYPE.ACTOR_APPEARED] = c.extend({
        _init: function(e) {
            this.listenTo(r.ActorMgr, "ActorMgr::registerBuddy", this._onRegister), this.listenTo(r.ActorMgr, "ActorMgr::registerEnemy", this._onRegister), this._condActorId = e.arg1
        },
        _onRegister: function(e) {
            this._condActorId === +e.getId() && this._show()
        }
    }), s[i.MESSAGE_TYPE.ACTOR_DEAD] = c.extend({
        _init: function(e) {
            this.listenTo(r.ActorMgr, "ActorBase::die", this._onDead), this._condActorId = e.arg1
        },
        _onDead: function(e) {
            this._condActorId === +e.getId() && this._show()
        }
    }), s[i.MESSAGE_TYPE.ACTOR_ABILITY] = c.extend({
        _init: function(e) {
            this.listenTo(r.ActorMgr, "ActorBase::changeState", this._onChangeState), this._condActorId = e.arg1, this._condAbilityId = e.arg2
        },
        _onChangeState: function(e, t, n) {
            var r = e.getAbility();
            t === "IN_ACTION" && this._condActorId === +e.getId() && this._condAbilityId === r.get("abilityId") && this._show()
        }
    }), s[i.MESSAGE_TYPE.ACTOR_HP_DECREASED] = c.extend({
        _init: function(e) {
            this.listenTo(r.ActorMgr, "ActorBase::addDamage", this._onDamaged), this._condActorId = e.arg1, this._condHp = e.arg2
        },
        _onDamaged: function(e, t) {
            if (this._condActorId !== +e.getId()) return;
            var n = Math.round(e.get("hp") / e.get("maxHp") * 100);
            n < this._condHp && this._show()
        }
    }), s[i.MESSAGE_TYPE.ACTOR_LOOKING_CHANGED] = c.extend({
        _init: function(e) {
            this.listenTo(r.ActorMgr, "ActorBase::changeLooking", this._onChangeLooking), this._condLooking = e.arg1
        },
        _onChangeLooking: function(e, t, n) {
            t === this._condLooking && this._show()
        }
    }), s[i.MESSAGE_TYPE.MESSAGE] = c.extend({
        _init: function(e) {
            this.listenTo(l, "Message::hide", this._onHide), this._condMessageId = e.arg1
        },
        _onHide: function(e) {
            e.id === this._condMessageId && this._show()
        }
    }), s[i.MESSAGE_TYPE.PROGRAM] = c.extend({})
}), define("scenes/battle/PreBattleFsm", ["lib/NameConventionFsm"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.PreBattleFsm = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), _.bindAll(this, "_onAppearanceAnimEnd")
        },
        processForStateAppearanceEntry: function() {
            var e = t.BattleInfo.getInstance(),
                n = [];
            _.each(t.ActorMgr.getAliveEnemyContainers(), function(e) {
                var t = e.getAppearanceAnimationId();
                t && n.push({
                    enemyContainer: e,
                    animationId: t,
                    shouldDeformAllNodes: e.shouldDeformAllNodesInAppearing()
                })
            });
            var r = e.get("round"),
                i = e.getBuddyBoostExpMap(),
                s = [];
            r === 1 && _.each(i, function(e, n) {
                if (e) {
                    var r = t.ActorMgr.getByUid(n);
                    if (r.isDead()) return;
                    s.push(r)
                }
            });
            var o = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.APPEARANCE,
                deformInfo: n,
                round: r,
                roundNum: e.get("roundNum"),
                materiaExpBoostBuddies: t.DataConstructor.getActorInfo(s)
            });
            o.addCallbackOnce("end", this._onAppearanceAnimEnd), o.play()
        },
        _onAppearanceAnimEnd: function() {
            this.changeState("END")
        }
    })
}), define("scenes/battle/RemoteLogger", ["lib/RemoteLogger"], function(e) {
    FF.ns.battle.RemoteLogger = e
}), define("scenes/battle/Score", ["lib/EventBase", "lib/Events"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf,
        i = e.extend({
            initialize: function(t) {
                e.prototype.initialize.apply(this, arguments), this._initData = t, this._results = {
                    no: this.getNo(),
                    val1: 0,
                    val2: 0,
                    val3: 0,
                    val4: 0,
                    val5: 0
                }, this._init(t)
            },
            _init: function() {},
            getNo: function() {
                return this._initData.no
            },
            getType: function() {
                return this._initData.type
            },
            makeResultData: function() {
                return this._results
            },
            toPlainObject: function() {
                return {
                    attributes: this._attributes,
                    results: this._results
                }
            },
            applyPlainObject: function(e) {
                _.extend(this._attributes, e.attributes), this._results = e.results
            }
        }),
        s = {};
    s[r.SCORE_TYPE.ACTION_NUM] = i.extend({
        _init: function() {
            this.listenTo(n.ActorMgr, "ActorBase::entryInAction", this._onEntryInAction)
        },
        _onEntryInAction: function(e) {
            if (!e.isBuddy()) return;
            this._results.val1++
        }
    }), s[r.SCORE_TYPE.DAMAGED_RATE] = i.extend({
        _init: function() {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this.listenTo(n.ActorMgr, "ActorMgr::registerBuddy", this._onRegisterBuddy)
        },
        _onRegisterBuddy: function(e) {
            this._results.val2 += e.get("hp")
        },
        _onDamage: function(e, t) {
            var n = t.actualDamage,
                r = t.receiver;
            if (!r || !r.isBuddy()) return;
            if (t.isRecovery) return;
            if (n <= 0) return;
            if (t.ignoreCalcDamagedRateScore) return;
            this._results.val1 += n
        }
    }), s[r.SCORE_TYPE.DROP_NUM] = i.extend(), s[r.SCORE_TYPE.DEFEAT_NUM] = i.extend({
        _init: function() {
            this.set("defeated", this.get("defeated") || {}), this.listenTo(n.ActorMgr, "ActorBase::die", this._onDie), this.listenTo(n.ActorMgr, "ActorBase::rise", this._onRise)
        },
        _onDie: function(e) {
            if (!e.isBuddy()) return;
            var t = this.get("defeated");
            t[e.getUid()] = !0, this._results.val1 = this._calcDefeatedNum()
        },
        _onRise: function(e) {
            if (!e.isBuddy()) return;
            var t = this.get("defeated");
            t[e.getUid()] = !1, this._results.val1 = this._calcDefeatedNum()
        },
        _calcDefeatedNum: function() {
            var e = 0,
                t = this.get("defeated");
            return _.each(t, function(t) {
                t && e++
            }), e
        }
    }), s[r.SCORE_TYPE.ENEMY_ABILITY] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyId = +e.arg1, this._condElement = +e.arg2
        },
        _onDamage: function(e, t) {
            var n = t.receiver;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (t.element !== this._condElement) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.ENEMY_ABILITY_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyId = +e.arg1, this._condElement = +e.arg2, this._condLooking = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.receiver;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (t.element !== this._condElement) return;
            if (n.get("looking") !== this._condLooking) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.NOT_ENEMY_ABILITY] = i.extend({
        _init: function(e) {
            e = _.extend({}, e), e.type = r.SCORE_TYPE.ENEMY_ABILITY, this._score = o(e)
        },
        makeResultData: function() {
            return this._results.val1 = this._score._results.val1 ? 0 : 1, this._results
        }
    }), s[r.SCORE_TYPE.NOT_ENEMY_ABILITY_TIMING] = i.extend({
        _init: function(e) {
            e = _.extend({}, e), e.type = r.SCORE_TYPE.ENEMY_ABILITY_TIMING, this._score = o(e)
        },
        makeResultData: function() {
            return this._results.val1 = this._score._results.val1 ? 0 : 1, this._results
        }
    }), s[r.SCORE_TYPE.DAMAGE_REDUCED] = i.extend({
        _init: function(e) {
            this._condEnemyId = +e.arg1, this._condAbilityId = +e.arg2, this._condHalf = +e.arg3, this._condAbsorption = +e.arg4, this._condVoid = +e.arg5, this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage)
        },
        _onDamage: function(e, t) {
            var n = t.executer,
                i = t.receiver,
                s = t.ability,
                o = t.advantage;
            if (!i || !i.isBuddy()) return;
            if (!n || !n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!s || s.get("abilityId") !== this._condAbilityId) return;
            this._condHalf && o === r.ADVANTAGE.HALF && (this._results.val1 = 1), this._condAbsorption && o === r.ADVANTAGE.ABSORPTION && (this._results.val1 = 1), this._condVoid && o === r.ADVANTAGE.VOID && (this._results.val1 = 1)
        }
    }), s[r.SCORE_TYPE.WITHOUT_SPECIAL_EQUIPMENT] = i.extend({}), s[r.SCORE_TYPE.DEFEAT_BEFORE_ABILITY] = i.extend({
        _init: function(e) {
            this._results.val1 = 1, this._condEnemyId = +e.arg1, this._condAbilityId = +e.arg2, this._condNum = +e.arg3 || 1, this.set("num", this.get("num") || 0), this.listenTo(n.ActorMgr, "ActorBase::notifyAbilityBegun", this._onEntryInAction)
        },
        _onEntryInAction: function(e, t) {
            var n = t.executer;
            if (!n || !n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!t || t.get("abilityId") !== this._condAbilityId) return;
            this.set("num", this.get("num") + 1);
            if (this.get("num") < this._condNum) return;
            this._results.val1 = 0
        }
    }), s[r.SCORE_TYPE.DEFEAT_BEFORE_LOOKING] = i.extend({
        _init: function(e) {
            this._results.val1 = 1, this._condEnemyId = +e.arg1, this._condLooking = +e.arg2, this.listenTo(n.ActorMgr, "ActorBase::changeBaseParam", this._onChangeParam), this.listenTo(n.ActorMgr, "ActorBase::set", this._onSet)
        },
        _onChangeParam: function(e, t, n) {
            if (!e.isEnemy()) return;
            if (e.getId() !== this._condEnemyId) return;
            if (e.get("looking") !== this._condLooking) return;
            this._results.val1 = 0
        },
        _onSet: function(e, t, n, r) {
            if (t !== "looking") return;
            if (!e.isEnemy()) return;
            if (e.getId() !== this._condEnemyId) return;
            if (e.get("looking") !== this._condLooking) return;
            this._results.val1 = 0
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_ABILITY] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage), this._condEnemyId = +e.arg1, this._condAbilityId = +e.arg2, this._condSuccess = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!r || r.get("abilityId") !== this._condAbilityId) return;
            if (this._condSuccess && !t.canHit) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_ABILITY_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage), this._condEnemyId = +e.arg1, this._condAbilityId = +e.arg2, this._condLooking = +e.arg3, this._condSuccess = +e.arg4
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!r || r.get("abilityId") !== this._condAbilityId) return;
            if (n.get("looking") !== this._condLooking) return;
            if (this._condSuccess && !t.canHit) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_JUMP_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage), this._condEnemyId = +e.arg1, this._condLooking = +e.arg2, this._condSuccess = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (n.get("looking") !== this._condLooking) return;
            if (this._condSuccess && !t.canHit) return;
            if (!t.isFlightAttack) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_STATUS_AILMENTS] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addStatusAilments", this._onStatusAilments), this._condEnemyId = +e.arg1, this._condSaId = +e.arg2, this._condSaId2 = +e.arg3 || 0, this._condSaId3 = +e.arg4 || 0
        },
        _onStatusAilments: function(e, t) {
            var n = t.receiver,
                r = !1;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            var r = _.some([this._condSaId, this._condSaId2, this._condSaId3], function(e) {
                return this._match(e, t.statusAilments)
            }, this);
            r && (this._results.val1 = 1)
        },
        _match: function(e, t) {
            return e ? _.some(t, function(t) {
                return +t === e
            }) : !1
        }
    }), s[r.SCORE_TYPE.SUCCESS_STATUS_AILMENTS_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addStatusAilments", this._onStatusAilments), this._condEnemyId = +e.arg1, this._condSaId = +e.arg2, this._condLooking = +e.arg3
        },
        _onStatusAilments: function(e, t) {
            var n = t.receiver,
                r = !1;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (n.get("looking") !== this._condLooking) return;
            _.each(t.statusAilments, function(e) {
                if (+e === this._condSaId) return r = !0, !1
            }, this), r && (this._results.val1 = 1)
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_EXERCISE] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyId = +e.arg1, this._condExerciseType = +e.arg2, this._condSuccess = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!r || r.get("exerciseType") !== this._condExerciseType) return;
            if (this._condSuccess && !t.canHit) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_EXERCISE_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyId = +e.arg1, this._condExerciseType = +e.arg2, this._condLooking = +e.arg3, this._condSuccess = +e.arg4
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!r || r.get("exerciseType") !== this._condExerciseType) return;
            if (n.get("looking") !== this._condLooking) return;
            if (this._condSuccess && !t.canHit) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.NOT_ENEMY_EXERCISE] = i.extend({
        _init: function(e) {
            e = _.extend({}, e), e.type = r.SCORE_TYPE.SUCCESS_ENEMY_EXERCISE, this._score = o(e)
        },
        makeResultData: function() {
            return this._results.val1 = this._score._results.val1 ? 0 : 1, this._results
        }
    }), s[r.SCORE_TYPE.NOT_ENEMY_EXERCISE_TIMING] = i.extend({
        _init: function(e) {
            e = _.extend({}, e), e.type = r.SCORE_TYPE.SUCCESS_ENEMY_EXERCISE_TIMING, this._score = o(e)
        },
        makeResultData: function() {
            return this._results.val1 = this._score._results.val1 ? 0 : 1, this._results
        }
    }), s[r.SCORE_TYPE.NOT_DEFEAT] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyId = +e.arg1, this._results.val1 = 1
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.executer;
            if (!r.isEnemy()) return;
            if (r.getId() !== this._condEnemyId) return;
            if (!n || !n.isBuddy()) return;
            if (n.hasReraise()) return;
            t.prevHp > 0 && t.currHp <= 0 && (this._results.val1 = 0)
        }
    }), s[r.SCORE_TYPE.NOT_DEFEAT_IN_ROUND] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::die", this._onDie), this._condRound = +e.arg1, this._results.val1 = 1
        },
        _onDie: function(e) {
            if (n.BattleInfo.getInstance().get("round") !== this._condRound) return;
            if (e.isEnemy()) return;
            this._results.val1 = 0
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_DAMAGED_BY_ENEMY] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyExecuterId = +e.arg1, this._condEnemyReceiverId = +e.arg2
        },
        _onDamage: function(e, t) {
            var n = t.executer,
                r = t.receiver,
                i = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyExecuterId) return;
            if (!r.isEnemy()) return;
            if (r.getId() !== this._condEnemyReceiverId) return;
            if (i.get("isEffectOfStatusAilements")) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_ABILITY_BY_ENEMY] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyExecuterId = +e.arg1, this._condEnemyReceiverId = +e.arg2, this._condAbilityId = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.executer,
                r = t.receiver,
                i = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyExecuterId) return;
            if (!r.isEnemy()) return;
            if (r.getId() !== this._condEnemyReceiverId) return;
            if (!i || i.get("abilityId") !== this._condAbilityId) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_STATUS_AILMENTS_BY_ENEMY] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addStatusAilments", this._onStatusAilments), this._condEnemyExecuterId = +e.arg1, this._condEnemyReceiverId = +e.arg2, this._condSaId = +e.arg3
        },
        _onStatusAilments: function(e, t) {
            var n = t.executer,
                r = t.receiver,
                i = !1;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyExecuterId) return;
            if (!r.isEnemy()) return;
            if (r.getId() !== this._condEnemyReceiverId) return;
            _.each(t.statusAilments, function(e) {
                +e === this._condSaId && (i = !0)
            }, this), i && (this._results.val1 = 1)
        }
    }), s[r.SCORE_TYPE.DEFEAT_ENEMY_NUM] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::die", this._onDie), this._condEnemyId = +e.arg1, this._condLooking = +e.arg2, this._condDefeatNum = +e.arg3, this._results.val1 = 0
        },
        _onDie: function(e) {
            if (e.isBuddy()) return;
            if (e.getId() !== this._condEnemyId) return;
            if (e.get("looking") !== this._condLooking) return;
            this._results.val1 += 1
        }
    }), s[r.SCORE_TYPE.HAS_BUDDY] = i.extend();
    var o = function(e) {
            var t = e.type,
                n = s[t];
            if (!n) throw new Error("invalid score type.t=" + t);
            return new n(e)
        },
        u = void 0;
    FF.ns.battle.Score = _.extend({
        TYPE: r.SCORE_TYPE,
        load: function(e) {
            var t = 0,
                n = 0;
            u = {}, _.each(["general", "specific"], function(r) {
                var i = e[r];
                u[r] = {};
                if (!i) return;
                for (t = 0, n = i.length; t < n; t++) u[r][i[t].no] = o(i[t])
            })
        },
        makeResultData: function() {
            var e = 0,
                t = 0,
                n = {};
            return _.each(u, function(e, t) {
                n[t] = [], _.each(e, function(e, r) {
                    n[t].push(e.makeResultData())
                })
            }), n
        },
        _getInstance: function(e, t) {
            return u[e][t]
        },
        resetForContinue: function() {
            this.trigger("Score::resetForContinue")
        },
        toPlainObject: function() {
            var e = {},
                t = 0,
                n = 0;
            return _.each(u, function(t, n) {
                e[n] || (e[n] = {}), _.each(t, function(t, r) {
                    e[n][r] = t.toPlainObject()
                })
            }), e
        },
        applyPlainObject: function(e) {
            if (!e) return;
            var t = 0,
                n = 0;
            _.each(u, function(t, n) {
                _.each(t, function(t, r) {
                    if (!e[n] || !e[n][r]) throw new Error("invalid plain object data");
                    t.applyPlainObject(e[n][r])
                })
            })
        }
    }, t)
}), define("scenes/battle/StatusAilments", ["util", "lib/EventBase"], function(e, t) {
    function s(e, t) {
        for (var n = 0, r = e.length; n < r; ++n) {
            var i = e[n];
            if (t.indexOf(i) >= 0) return !0
        }
        return !1
    }

    function o(e, t, r, s) {
        var o = n.StatusAilmentsConfig.getParam(t);
        if (!o.funcMap) return;
        var u = o.funcMap[r];
        if (!u) return;
        var a = i[u];
        if (!a) throw new Error("sa func not found.name=" + u);
        return a.call(e, t, e._infoMap[t], o, s)
    }

    function u(e, t, n, r) {
        var i = n.get("mnd"),
            s = r.get("mnd"),
            o = t.a,
            u = t.b,
            a = t.c,
            f = Math.floor(i * o + s * u + a);
        return FF.logger.info("SA_DURATION", f, "emnd", i, "emnd", s, "a", o, "b", u, "c", a), f
    }

    function a(e, t, r) {
        var i = n.Config.getInstance(),
            s = n.Conf;
        switch (r) {
            case "ALL":
                return !0;
            case "PHYSICAL":
                return e === n.Conf.EXERCISE_TYPE.PHYSICAL;
            case "MAGIC":
                return _.contains(i.get("MagicExerciseTypes"), e);
            case "BASIC_MAGIC":
                return _.contains(i.get("BasicMagicExerciseTypes"), e);
            case "SA_MIGHTY_GUARD":
                return _.contains(i.get("ExerciseTypesWithoutPhysical"), e) && _.contains(i.get("MightyGuardEffectedCalcTypes"), t);
            case "COUNTER_AIMING":
                return _.contains(i.get("CounterAimingEffectedExerciseTypes"), e) && _.contains(i.get("CounterAimingEffectedCalcTypes"), t);
            case "SA_MIRAGE":
                return _.any([{
                    exerciseTypes: [s.EXERCISE_TYPE.PHYSICAL],
                    calcTypes: [s.CALC_TYPE.ATTACK, s.CALC_TYPE.DAMAGED_HP]
                }, {
                    exerciseTypes: [s.EXERCISE_TYPE.INBORN],
                    calcTypes: [s.CALC_TYPE.ATTACK]
                }], function(n) {
                    return _.contains(n.exerciseTypes, e) && _.contains(n.calcTypes, t)
                })
        }
        return !1
    }
    var n = FF.ns.battle,
        r = n.Conf,
        i = {};
    i.updateTimerDefault = function(e, t, n, r) {
        t.timer += r.dt, t.timer >= t.duration && this.unset(e)
    }, i.updateTimerPoison = function(e, t, i, s) {
        t.timer += s.dt, t.intervalTimer += s.dt, t.duration && t.timer >= t.duration ? this.unset(e) : t.intervalTimer >= i.interval && (n.Commander.getInstance().register(r.ABILITY_ID_OF.POISON, this._actor, {
            damageFactor: i.damageFactor
        }, {
            interruptStatusAilments: !0
        }), t.intervalTimer = 0)
    }, i.updateTimerDoom = function(e, t, n, r) {
        t.timer += r.dt, t.timer >= n.interval && (t.count--, FF.logger.debug("DOOM", t.count), t.timer = 0)
    }, i.updateTimerMagicalMine = function(e, t, n, r) {
        i.updateTimerDoom.apply(this, arguments), t.count < 0 && this._actor.isInDefense() && this.unset(e)
    }, i.entryRage = function(e, t, n, r) {
        t.abilityIds = r.abilityIds.concat()
    }, i.exitActionRage = function(e, t, n, r) {
        var i = this._actor.getLastAbility();
        if (!i.get("isPositiveIncontrollable")) return;
        var s = t.abilityIds;
        s.shift(), 0 === s.length && this.unset(e)
    }, i.entryCastAbilityUseCount = function(e, t, n, r) {
        t.changeCastTimeFlag = !0
    }, i.exitActionAbilityUseCount = function(e, t, n, r) {
        t.changeCastTimeFlag && t.validAbilityUseCount--, t.changeCastTimeFlag = !1, t.validAbilityUseCount <= 0 && this.unset(e)
    }, i.updateTimerRegen = function(e, t, i, s) {
        t.timer += s.dt, t.intervalTimer += s.dt, t.timer >= t.duration ? this.unset(e) : t.intervalTimer >= i.interval && (n.Commander.getInstance().register(r.ABILITY_ID_OF.REGEN, this._actor, {
            damageFactor: i.damageFactor
        }, {
            interruptStatusAilments: !0
        }), t.intervalTimer = 0)
    }, i.end = function(e, t) {
        this.unset(e)
    }, i.damagedForSleep = function(e, t, r, i) {
        var s = i.damageObj.ability;
        s && s.get("exerciseType") === n.Conf.EXERCISE_TYPE.PHYSICAL && this.unset(e)
    }, i.damagedForConfusion = function(e, t, r, i) {
        var s = i.damageObj.ability;
        s && s.get("exerciseType") === n.Conf.EXERCISE_TYPE.PHYSICAL && this.unset(e)
    }, i.entryParamBooster = function(e, t, n, r) {
        this.startBoost(t, n, r)
    }, i.entryTrance = function(t, n, r, i) {
        var s = e.cloneDeep(r.boosts);
        for (var o = 0, u = s.length; o < u; o++) {
            var a = i && i.boosts && i.boosts[o] && i.boosts[o].rate;
            if (!(_.isNumber(a) && a > 0)) throw new Error("unexpected rate. idx:" + o + " rate:" + JSON.stringify(a));
            s[o].rate = a
        }
        r = _.extend({}, r, {
            boosts: s
        }), this.startBoost(n, r, i), this.swapSparePanel(n, r, i)
    }, i.updateTimerTrance = function(e, t, n, r) {
        t.timer += r.dt
    }, i.exitActionTrance = function(e, t, n, r) {
        t.timer >= t.duration && this.unset(e)
    }, i.exitTrance = function(e, t, n, r) {
        this.finishBoost(t), this.rewindSparePanel(t)
    }, i.updateTimerParamBooster = function(e, t, n, r) {
        t.timer += r.dt, t.timer >= t.duration && this.unset(e)
    }, i.exitParamBooster = function(e, t, n, r) {
        this.finishBoost(t)
    }, i.procChargeActionEntry = function(e, t, n, r) {
        this.startBoost(t, n, r), t.isBoost = !0
    }, i.procChargeActionExit = function(e, t, n) {
        t.isBoost && (this.finishBoost(t), this.unset(e))
    }, i.entryCounter = function(e, t, n, r) {
        var i = [],
            s = this._actor.counters;
        _.each(n.counters, function(e) {
            var t = s.add(e.abilityId, e.conditionType, e.conditionValue, e.rate);
            i.push(t)
        }, this), t.counterIds = i
    }, i.exitCounter = function(e, t, n) {
        if (!t.counterIds) return;
        var r = this._actor.counters;
        _.each(t.counterIds, function(e) {
            r.remove(e)
        }, this)
    }, i.entryLimit = function(e, t) {
        t.count = 0
    }, i.damageCalculateHookForCanNotHitWithDamaged = function(e, t, n, r) {
        var i = r.damageObj,
            s = i.ability.get("exerciseType");
        if (!i) throw new Error("damage object required.");
        !i.canHit && a(s, i.type, n.canNotHit) && (t.count++, t.count >= n.limit && this.unset(e))
    }, FF.ns.battle.StatusAilments = t.extend({
        initialize: function(e) {
            this._actor = e, this._statusAilments = [], this._infoMap = {}
        },
        toPlainObject: function() {
            return {
                statusAilments: this._statusAilments,
                infoMap: this._infoMap
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            this._statusAilments = e.statusAilments, this._infoMap = e.infoMap
        },
        set: function(e, t, i) {
            i = i || {}, e = +e;
            if (!n.StatusAilmentsConfig.isDefinedStatus(e)) throw new Error("status ailments not found.id=" + e);
            if (!t) throw new Error("executer required.");
            e === r.STATUS_AILMENTS_TYPE.PETRIFACTION && this._actor.isEnemy() && (e = r.STATUS_AILMENTS_TYPE.INSTANT_DEATH), e === r.STATUS_AILMENTS_TYPE.DEATH && this.hasReraise() && (e = r.STATUS_AILMENTS_TYPE.RERAISE_DEATH, i = {
                infoMap: {
                    hpRate: this.getHpRateFromParam(this.havingReraiseId())
                }
            });
            var s = this._statusAilments,
                a = 0,
                f = void 0,
                l = n.StatusAilmentsConfig.getParam(e);
            if (l.canNotOverwrite && this.has(e)) return !1;
            if (this._actor.isEnemy() && l.canNotSetToEnemy) return !1;
            var c = [];
            for (a = 0; a < s.length; ++a) {
                f = s[a];
                var h = n.StatusAilmentsConfig.judgeExclusive(e, f);
                switch (h) {
                    case r.STATUS_AILMENTS_EXCLUSIVE.TOGETHER:
                        break;
                    case r.STATUS_AILMENTS_EXCLUSIVE.BLOCK:
                        return c = [], !1;
                    case r.STATUS_AILMENTS_EXCLUSIVE.EXTRUDE:
                        c.push(f);
                        break;
                    default:
                        throw new Error("unknown exclusive judge")
                }
            }
            for (a = 0; a < c.length; ++a) this.unset(c[a]);
            l.resetActorWhenSet && (FF.logger.info("reset actor. inflicted sa." + e), this._actor.reset()), this.isCancelCast(e) && this._actor.isStateInCast() && this._actor.getAbility().isMagic() && (FF.logger.info("reset actor. inflicted silence in cast."), this._actor.reset()), e === r.STATUS_AILMENTS_TYPE.FORCE_ESCAPE && this._actor.reset();
            var p = {
                timer: 0,
                intervalTimer: 0
            };
            if (l.duration) p.duration = u(e, l.duration, t, this._actor);
            else if (l.durationForSide) {
                var d;
                this._actor.isBuddy() ? d = l.durationForSide.buddy : this._actor.isEnemy() && (d = l.durationForSide.enemy);
                if (!d) throw new Error("missing duration setting");
                p.duration = u(e, d, t, this._actor)
            }
            return l.count > 0 && (p.count = l.count), l.substitutes && (p.substitutes = l.substitutes), i.infoMap && _.extend(p, i.infoMap), FF.logger.debug("SA_SET", e, p), this._infoMap[e] = p, this._statusAilments.push(e), o(this, e, "entry", i), this.trigger("StatusAilments::set", e), !0
        },
        unset: function(e) {
            e = +e;
            if (!e) throw new Error("sa id required");
            var t = this._statusAilments.indexOf(e);
            if (t < 0) return;
            var r = n.StatusAilmentsConfig.getParam(e);
            r.resetActorWhenUnset && (FF.logger.info("reset actor. inflicted sa." + e), this._actor.reset()), o(this, e, "exit"), this._statusAilments.splice(t, 1), delete this._infoMap[e], this.trigger("StatusAilments::unset", e)
        },
        has: function(e) {
            return this._statusAilments.indexOf(+e) >= 0
        },
        cloneIds: function() {
            return e.cloneDeep(this._statusAilments)
        },
        getRefs: function() {
            return this._statusAilments
        },
        getContinuanceIds: function() {
            var e = _.filter(this._statusAilments, function(e) {
                return n.StatusAilmentsConfig.isContinuanceStatus(e)
            });
            return this.has(r.STATUS_AILMENTS_TYPE.RERAISE_DEATH) && e.push(r.STATUS_AILMENTS_TYPE.DEATH), e
        },
        isHittable: function(e, t) {
            var r = void 0;
            for (var i = 0, s = this._statusAilments.length; i < s; i++) {
                r = n.StatusAilmentsConfig.getParam(this._statusAilments[i]);
                if (a(e, t, r.canNotHit)) return !1
            }
            return !0
        },
        isPossibleToTarget: function() {
            var e = [r.STATUS_AILMENTS_TYPE.INVISIBLE, r.STATUS_AILMENTS_TYPE.FORCE_ESCAPE, r.STATUS_AILMENTS_TYPE.ARM_CATCH];
            return !s(this._statusAilments, e)
        },
        canUseAllMagic: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                e = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (e.canNotUseAllMagic) return !1
            }
            return !0
        },
        canDoAbility: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                e = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (e.canNotDoAbility) return !1
            }
            return !0
        },
        canSelectAbility: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                e = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (e.canNotSelectAbility) return !1
            }
            return this.canDoAbility()
        },
        getRefsOfAttachElementInfoMap: function() {
            var t = this.getAttachElementId();
            return t ? e.cloneDeep(this._infoMap[t]) : void 0
        },
        getAtbTimeFactor: function() {
            var e = 100,
                t = void 0;
            for (var r = 0, i = this._statusAilments.length; r < i; r++) {
                t = n.StatusAilmentsConfig.getParam(this._statusAilments[r]);
                if (_.isNumber(t.atbTimeFactor)) {
                    e = t.atbTimeFactor;
                    break
                }
            }
            return e
        },
        getCastTimeFactor: function(t) {
            var r = e.option({
                    abilityCategoryId: void 0
                }, t),
                i = 100,
                s;
            for (var o = 0, u = this._statusAilments.length; o < u; o++) {
                s = n.StatusAilmentsConfig.getParam(this._statusAilments[o]);
                if (_.isNumber(s.castTimeFactor)) {
                    var a = this._infoMap[this._statusAilments[o]];
                    if (a.changeCastTimeFlag && a.abilityCategoryId === r.abilityCategoryId) {
                        i = a.castTimeFactor;
                        break
                    }
                    i = s.castTimeFactor;
                    break
                }
            }
            return i
        },
        isContinuousBattle: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                e = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (e.isNotContinuousBattle) return !1
            }
            return !0
        },
        isDead: function(t) {
            var n = e.option({
                    pureDeath: !1
                }, t),
                i = n.pureDeath ? [r.STATUS_AILMENTS_TYPE.DEATH, r.STATUS_AILMENTS_TYPE.RERAISE_DEATH, r.STATUS_AILMENTS_TYPE.DISABLE, r.STATUS_AILMENTS_TYPE.FORCE_ESCAPE] : [r.STATUS_AILMENTS_TYPE.PETRIFACTION, r.STATUS_AILMENTS_TYPE.DEATH, r.STATUS_AILMENTS_TYPE.RERAISE_DEATH, r.STATUS_AILMENTS_TYPE.DISABLE, r.STATUS_AILMENTS_TYPE.FORCE_ESCAPE];
            return s(this._statusAilments, i)
        },
        judgeDeathByDoom: function() {
            var e = this.havingDoomId();
            return this.has(e) ? this._infoMap[e].count < 0 : !1
        },
        judgeTimeLimit: function() {
            var e = this.havingCountId();
            return this.has(e) ? this._infoMap[e].count < 0 : !1
        },
        getCount: function() {
            var e = this.havingCountId();
            return e ? this._infoMap[e].count : 0
        },
        havingDoomId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.doomIds, function(t) {
                return e.has(t)
            })
        },
        hasDoom: function() {
            return !!this.havingDoomId()
        },
        havingReraiseId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.reraiseIds, function(t) {
                return e.has(t)
            })
        },
        hasReraise: function() {
            return !!this.havingReraiseId()
        },
        havingCountId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.countIds, function(t) {
                return e.has(t)
            })
        },
        isCount: function() {
            return !!this.havingCountId()
        },
        getAttachElementId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.attachElementIds, function(t) {
                return e.has(t)
            })
        },
        getNextAbilityIdForRage: function() {
            var e = r.STATUS_AILMENTS_TYPE.RAGE;
            if (!this.has(e)) throw new Error("invalid call");
            return this._infoMap[e].abilityIds[0]
        },
        getHpRateFromParam: function(e) {
            var t = n.StatusAilmentsConfig.getParam(e);
            if (!t) throw new Error("sa param not found.id=" + e);
            return t.hpRate
        },
        getHpRateForReraise: function() {
            return this._infoMap[r.STATUS_AILMENTS_TYPE.RERAISE_DEATH].hpRate
        },
        startBoost: function(t, n, r) {
            var i = r && r.boost ? r.boost : {},
                s = r && r.brkDefRates ? r.brkDefRates : {};
            t.boosts = [];
            for (var o = 0, u = n.boosts.length; o < u; o++) {
                var a = e.cloneDeep(n.boosts[o]),
                    f = this._actor.get(a.paramName, {
                        usesSelfBaseParam: !0
                    }),
                    l = void 0;
                if (_.has(a, "rate")) {
                    var c = i.rate || a.rate;
                    if (c < 0 && s[a.paramName]) {
                        var h = s[a.paramName];
                        c = Math.floor(c * (100 + h) / 100)
                    }
                    a.rate = c, l = this._actor.setBoost(a.paramName, c)
                } else if (_.has(a, "attachElement")) _.each(a.attachElement, function(e, n) {
                    t.attachElementId = +n, a.attachElement[n] = t.defenseFactor || e
                }), l = this._actor.setAttachElementBoost(a.paramName, a.attachElement, "attachElement");
                else {
                    if (!_.has(a, "absolute")) throw new Error("invalid boostObj");
                    a.absolute = i.absolute || a.absolute, l = this._actor.setBoost(a.paramName, a.absolute, {
                        isAbsolute: !0
                    })
                }
                a.holderId = l, t.boosts.push(a)
            }
        },
        finishBoost: function(e) {
            for (var t = 0, n = e.boosts.length; t < n; t++) {
                var r = e.boosts[t];
                this._actor.resetParam(r.holderId)
            }
        },
        swapSparePanel: function(t, n, r) {
            var i = r && r.spareReceptorIds || [];
            t.sparePanels = [];
            for (var s = 0, o = i.length; s < o; s++) {
                var u = e.cloneDeep(n.sparePanels[s]);
                i[s] && (u.spareReceptorId = i[s]);
                var a = {
                        highlight: !!u.highlight
                    },
                    f = this._actor.swapSparePanel(u.spareReceptorId, u.panelNo, a);
                f && (u.swappedReceptorId = f), t.sparePanels.push(u)
            }
        },
        rewindSparePanel: function(e, t, n) {
            for (var r = 0, i = e.sparePanels.length; r < i; r++) {
                var s = e.sparePanels[r],
                    o = s.swappedReceptorId;
                this._actor.rewindSparePanel(s.spareReceptorId, o)
            }
        },
        update: function(e) {
            var t = this._statusAilments.concat(),
                n = void 0;
            for (var r = 0; r < t.length; ++r) n = t[r], o(this, n, "update", {
                dt: e
            })
        },
        processForStateInCastEntry: function() {
            this._processForEvent("entryCast")
        },
        processForStateInActionEntry: function() {
            this._processForEvent("entryAction")
        },
        processForStateInActionExit: function() {
            this._processForEvent("exitAction")
        },
        processForDamaged: function(e) {
            this._processForEvent("damaged", {
                damageObj: e
            })
        },
        processForDamageCalculateHook: function(e) {
            this._processForEvent("damageCalculateHook", {
                damageObj: e
            })
        },
        _processForEvent: function(e, t) {
            var n = this._statusAilments.concat(),
                r = void 0;
            for (var i = 0; i < n.length; ++i) r = n[i], o(this, r, e, t)
        },
        retrieveSubstituteTypes: function() {
            var e = [];
            return _.each(this._infoMap, function(t, n) {
                var r = this.getSubstitutesById(n);
                if (!r) return;
                e = e.concat(r)
            }, this), _.uniq(e)
        },
        getSubstitutesById: function(e) {
            var t = [],
                n = this._infoMap[e];
            return _.has(n, "substitutes") ? n.substitutes : t
        },
        isCancelCast: function(e) {
            var t = n.Config.getInstance().get("CancelCastStatusAilmentsTypes");
            return _.contains(t, e) ? !0 : !1
        }
    })
}), define("scenes/battle/StatusAilmentsConfig", [], function() {
    var e = FF.ns.battle,
        t = e.Conf,
        n = t.STATUS_AILMENTS_TYPE,
        r = _.invert(n),
        i = {};
    i[n.DEATH] = {
        isContinuance: !0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        exclusive: {
            all: !0,
            blocking: !0
        }
    }, i[n.INSTANT_DEATH] = {
        exclusive: {
            types: []
        }
    }, i[n.STOCK_BREAK] = {
        exclusive: {
            types: []
        }
    }, i[n.RERAISE_40] = {
        isReraise: !0,
        hpRate: 40,
        canNotSetToEnemy: !0,
        exclusive: {
            types: []
        }
    }, i[n.RERAISE_60] = {
        isReraise: !0,
        hpRate: 60,
        canNotSetToEnemy: !0,
        exclusive: {
            types: [n.RERAISE_40]
        }
    }, i[n.RERAISE_80] = {
        isReraise: !0,
        hpRate: 80,
        canNotSetToEnemy: !0,
        exclusive: {
            types: [n.RERAISE_40, n.RERAISE_60]
        }
    }, i[n.RERAISE_100] = {
        isReraise: !0,
        hpRate: 100,
        canNotSetToEnemy: !0,
        exclusive: {
            types: [n.RERAISE_40, n.RERAISE_60, n.RERAISE_80]
        }
    }, i[n.RERAISE_DEATH] = {
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        exclusive: {
            all: !0,
            blocking: !0
        }
    }, i[n.POISON] = {
        isContinuance: !0,
        interval: 5e3,
        damageFactor: 4,
        funcMap: {
            update: "updateTimerPoison"
        },
        exclusive: {
            types: [n.REGEN, n.REGEN_MIDDLE, n.REGEN_STRONG, n.SAP]
        }
    }, i[n.SAP] = {
        interval: 2e3,
        damageFactor: 4,
        duration: {
            a: 0,
            b: 0,
            c: 4e4
        },
        funcMap: {
            update: "updateTimerPoison"
        },
        exclusive: {
            types: [n.REGEN, n.REGEN_MIDDLE, n.REGEN_STRONG, n.POISON]
        }
    }, i[n.SILENCE] = {
        isContinuance: !0,
        canNotUseAllMagic: !0,
        duration: {
            a: 25,
            b: -25,
            c: 2e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        }
    }, i[n.PARALYSIS] = {
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        resetActorWhenUnset: !0,
        duration: {
            a: 20,
            b: -20,
            c: 15e3
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: [n.COUNTER_AIMING]
        }
    }, i[n.CONFUSION] = {
        canNotSelectAbility: !0,
        resetActorWhenSet: !0,
        resetActorWhenUnset: !0,
        duration: {
            a: 25,
            b: -25,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault",
            damaged: "damagedForConfusion"
        },
        exclusive: {
            types: [n.COUNTER_AIMING, n.RAGE]
        }
    }, i[n.HASTE] = {
        atbTimeFactor: 200,
        duration: {
            a: 25,
            b: 0,
            c: 2e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: [n.SLOW]
        }
    }, i[n.SLOW] = {
        atbTimeFactor: 50,
        duration: {
            a: .05,
            b: 0,
            c: 2e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: [n.HASTE]
        }
    }, i[n.STOP] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        duration: {
            a: 20,
            b: -20,
            c: 6e3
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: [n.COUNTER_AIMING]
        }
    }, i[n.PYRAMID] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        isNotContinuousBattle: !0,
        exclusive: {
            invert: !0,
            types: [n.DEATH],
            blocking: !0
        }
    }, i[n.PRISON_CAGE] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        isNotContinuousBattle: !0,
        duration: {
            a: 0,
            b: 0,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            invert: !0,
            types: [n.DEATH, n.REGEN, n.REGEN_MIDDLE, n.REGEN_STRONG],
            blocking: !0
        }
    }, i[n.WATER_BALL] = {
        interval: 1e3,
        damageFactor: 2,
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        isNotContinuousBattle: !0,
        funcMap: {
            update: "updateTimerPoison"
        },
        exclusive: {
            invert: !0,
            types: [n.DEATH],
            blocking: !0
        }
    }, i[n.SWALLOWED] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        isNotContinuousBattle: !0,
        exclusive: {
            invert: !0,
            types: [n.DEATH],
            blocking: !0
        }
    }, i[n.POSSESSION] = {
        duration: {
            a: 0,
            b: 0,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        }
    }, i[n.PROTECT] = {
        duration: {
            a: 30,
            b: 0,
            c: 35e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "def",
            rate: 100
        }],
        exclusive: {
            types: []
        }
    }, i[n.SHELL] = {
        duration: {
            a: 30,
            b: 0,
            c: 35e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "mdef",
            rate: 100
        }],
        exclusive: {
            types: []
        }
    }, i[n.REFLECTION] = {
        duration: {
            a: 30,
            b: 0,
            c: 35e3
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        }
    }, i[n.BLINDED] = {
        isContinuance: !0,
        durationForSide: {
            buddy: {
                a: 20,
                b: -20,
                c: 3e4
            },
            enemy: {
                a: 20,
                b: -20,
                c: 6e4
            }
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "acc",
            rate: -50
        }],
        exclusive: {
            types: []
        }
    }, i[n.SLEEP] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        duration: {
            a: 20,
            b: -20,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault",
            damaged: "damagedForSleep"
        },
        exclusive: {
            types: [n.COUNTER_AIMING]
        }
    }, i[n.PETRIFACTION] = {
        isContinuance: !0,
        isBlocking: !0,
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        exclusive: {
            all: !0,
            blocking: !0
        }
    }, i[n.DOOM] = {
        isDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 60,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, i[n.DOOM_30] = {
        isDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 30,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, i[n.DOOM_45] = {
        isDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 45,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, i[n.DOOM_90] = {
        isDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 90,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, i[n.DOOM_120] = {
        isDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 120,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, i[n.MAGICAL_MINE] = {
        isDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 20,
        funcMap: {
            update: "updateTimerMagicalMine"
        },
        exclusive: {
            types: []
        }
    }, i[n.BERSERKER] = {
        resetActorWhenSet: !0,
        resetActorWhenUnset: !0,
        canNotSelectAbility: !0,
        duration: {
            a: 25,
            b: -25,
            c: 2e4
        },
        boosts: [{
            paramName: "atk",
            rate: 25
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: [n.COUNTER_AIMING, n.RAGE]
        }
    }, i[n.RAGE] = {
        resetActorWhenUnset: !0,
        canNotSelectAbility: !0,
        funcMap: {
            entry: "entryRage",
            exitAction: "exitActionRage"
        },
        exclusive: {
            types: [n.COUNTER_AIMING]
        }
    }, i[n.REGEN] = {
        interval: 3e3,
        duration: {
            a: 30,
            b: 0,
            c: 3e4
        },
        damageFactor: 3,
        funcMap: {
            update: "updateTimerRegen"
        },
        exclusive: {
            types: [n.ZOMBIE, n.POISON, n.SAP, n.REGEN_MIDDLE, n.REGEN_STRONG]
        }
    }, i[n.REGEN_MIDDLE] = {
        interval: 2500,
        duration: {
            a: 30,
            b: 0,
            c: 3e4
        },
        damageFactor: 4,
        funcMap: {
            update: "updateTimerRegen"
        },
        exclusive: {
            types: [n.ZOMBIE, n.POISON, n.SAP, n.REGEN, n.REGEN_STRONG]
        }
    }, i[n.REGEN_STRONG] = {
        interval: 2500,
        duration: {
            a: 30,
            b: 0,
            c: 35e3
        },
        damageFactor: 5,
        funcMap: {
            update: "updateTimerRegen"
        },
        exclusive: {
            types: [n.ZOMBIE, n.POISON, n.SAP, n.REGEN, n.REGEN_MIDDLE]
        }
    }, i[n.ARM_CATCH] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        isNotContinuousBattle: !0,
        exclusive: {
            invert: !0,
            types: [n.DEATH],
            blocking: !0
        }
    }, i[n.REFLECTION_FULL_TIME] = {
        exclusive: {
            types: []
        }
    }, i[n.INVISIBLE] = {}, i[n.FORCE_ESCAPE] = {
        exclusive: {
            all: !0,
            blocking: !0
        }
    }, i[n.DISABLE] = {}, i[n.CUSTOM_MATK] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "matk",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_MND] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "mnd",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_ATK] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_DEF] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "def",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_ATK_ACC] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "acc",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_EVA] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "eva",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_MDEF] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "mdef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_DEF_MDEF] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "def",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_ATK_MATK_DEF_MDEF] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "matk",
            rate: 0
        }, {
            paramName: "def",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_ATK_MATK] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "matk",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_ATK_DEF] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "def",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_MATK_20_MDEF_50] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "matk",
            rate: 20
        }, {
            paramName: "mdef",
            rate: 50
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_ATK_MATK_DEF_MDEF_SPD_ACC_MND] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "matk",
            rate: 0
        }, {
            paramName: "def",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }, {
            paramName: "spd",
            rate: 0
        }, {
            paramName: "acc",
            rate: 0
        }, {
            paramName: "mnd",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.CUSTOM_SPD] = {
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "spd",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, i[n.INVINCIBLE] = {
        canNotHit: "ALL"
    }, i[n.NULL_PHYSICAL] = {
        canNotHit: "PHYSICAL"
    }, i[n.NULL_MAGIC] = {
        canNotHit: "MAGIC"
    }, i[n.FARAWAY] = {}, i[n.NULL_BASIC_MAGIC] = {
        canNotHit: "BASIC_MAGIC"
    }, i[n.TRIPLE] = {}, i[n.MATK_BOOSTER] = {
        duration: {
            a: 25,
            b: 0,
            c: 1e4
        },
        boosts: [{
            paramName: "matk",
            rate: 25
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, i[n.PROVOKE] = {
        boosts: [{
            paramName: "def",
            rate: 200
        }],
        substitutes: [t.EXERCISE_TYPE.PHYSICAL, t.EXERCISE_TYPE.BLACK_MAGIC],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, i[n.COUNTER_AIMING] = {
        duration: {
            a: 0,
            b: 0,
            c: 15e3
        },
        canNotHit: "COUNTER_AIMING",
        counters: [{
            abilityId: e.Conf.ABILITY_ID_OF.ATTACK,
            conditionType: e.Conf.COUNTER_CONDTION_TYPE.CUSTOM,
            conditionValue: e.Conf.COUNTER_CONDTION_CUSTOM_TYPE.COUNTER_AIMING,
            rate: 100
        }],
        funcMap: {
            entry: "entryCounter",
            update: "updateTimerDefault",
            exit: "exitCounter"
        },
        exclusive: {
            types: []
        }
    }, i[n.CHARGE] = {
        boosts: [{
            paramName: "atk",
            rate: 200
        }],
        funcMap: {
            entryAction: "procChargeActionEntry",
            exitAction: "procChargeActionExit"
        },
        exclusive: {
            types: []
        }
    }, i[n.RUNIC] = {
        exclusive: {
            types: [n.GRAND_CROSS]
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        substitutes: [t.EXERCISE_TYPE.BLACK_MAGIC],
        funcMap: {
            update: "updateTimerDefault"
        }
    }, i[n.GRAND_CROSS] = {
        exclusive: {
            types: [n.RUNIC]
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        substitutes: [t.EXERCISE_TYPE.BLACK_MAGIC, t.EXERCISE_TYPE.WHITE_MAGIC],
        funcMap: {
            update: "updateTimerDefault"
        }
    }, i[n.AIRFORCE_SPECK] = {
        exclusive: {
            types: []
        },
        substitutes: [t.EXERCISE_TYPE.BLACK_MAGIC, t.EXERCISE_TYPE.WHITE_MAGIC],
        canNotHit: "BASIC_MAGIC"
    }, i[n.BASIC_MAGIC_BREAKER] = {
        exclusive: {
            types: []
        },
        substitutes: [t.EXERCISE_TYPE.BLACK_MAGIC, t.EXERCISE_TYPE.WHITE_MAGIC],
        canNotHit: "BASIC_MAGIC"
    }, i[n.RAID] = {
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        boosts: [{
            paramName: "atk",
            rate: 150
        }, {
            paramName: "def",
            rate: -50
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, i[n.DEFENSE] = {
        funcMap: {
            entryCast: "end"
        },
        exclusive: {
            types: []
        }
    }, i[n.LOCK_ON] = {
        duration: {
            a: 0,
            b: 0,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        },
        substitutes: [t.EXERCISE_TYPE.PHYSICAL, t.EXERCISE_TYPE.BLACK_MAGIC]
    }, i[n.OVER_DRIVE] = {
        duration: {
            a: 0,
            b: 0,
            c: 4e4
        },
        boosts: [{
            paramName: "atk",
            rate: 30
        }, {
            paramName: "def",
            rate: -30
        }, {
            paramName: "mdef",
            rate: -30
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, i[n.ROAR] = {
        duration: {
            a: 0,
            b: 0,
            c: 2e4
        },
        boosts: [{
            paramName: "atk",
            rate: 20
        }, {
            paramName: "matk",
            rate: 20
        }, {
            paramName: "def",
            rate: -20
        }, {
            paramName: "mdef",
            rate: -20
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, i[n.MAGIC_SEAL] = {
        canNotUseAllMagic: !0,
        exclusive: {
            types: []
        }
    }, i[n.IGNORE_INCONTROLLABLE] = {}, i[n.MIRAGE_1] = {
        canNotHit: "SA_MIRAGE",
        limit: 1,
        exclusive: {
            types: [n.MIRAGE_2, n.MIRAGE_3]
        },
        funcMap: {
            entry: "entryLimit",
            damageCalculateHook: "damageCalculateHookForCanNotHitWithDamaged"
        }
    }, i[n.MIRAGE_2] = {
        canNotHit: "SA_MIRAGE",
        limit: 2,
        exclusive: {
            types: [n.MIRAGE_1, n.MIRAGE_3]
        },
        funcMap: {
            entry: "entryLimit",
            damageCalculateHook: "damageCalculateHookForCanNotHitWithDamaged"
        }
    }, i[n.MIRAGE_3] = {
        canNotHit: "SA_MIRAGE",
        limit: 3,
        exclusive: {
            types: [n.MIRAGE_1, n.MIRAGE_2]
        },
        funcMap: {
            entry: "entryLimit",
            damageCalculateHook: "damageCalculateHookForCanNotHitWithDamaged"
        }
    }, i[n.NON_DAMAGE] = {
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        }
    }, i[n.INDOMITABLENESS] = {
        duration: {
            a: 0,
            b: 0,
            c: 3e4
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "atk",
            rate: 50
        }],
        exclusive: {
            invert: !0,
            types: [n.DEATH, n.INVISIBLE, n.DEFENSE],
            blocking: !0
        }
    }, i[n.CHARM] = {
        boosts: [{
            paramName: "def",
            rate: 100
        }],
        substitutes: [t.EXERCISE_TYPE.PHYSICAL],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, i[n.MAGIC_CHARM] = {
        boosts: [{
            paramName: "mdef",
            rate: 100
        }],
        substitutes: [t.EXERCISE_TYPE.BLACK_MAGIC],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, i[n.STAN] = {
        resetActorWhenSet: !0,
        duration: {
            a: 0,
            b: 0,
            c: 1e3
        },
        funcMap: {
            update: "updateTimerDefault"
        }
    }, i[n.MIGHTY_GUARD_1] = {
        canNotHit: "SA_MIGHTY_GUARD",
        limit: 1,
        exclusive: {
            types: []
        },
        funcMap: {
            entry: "entryLimit",
            damageCalculateHook: "damageCalculateHookForCanNotHitWithDamaged"
        }
    }, i[n.SUCTION] = {
        canNotOverwrite: !0,
        interval: 1e3,
        count: 30,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, i[n.FURY] = {
        exclusive: {
            types: []
        }
    }, i[n.CHANGE_CAST_TIME] = {
        castTimeFactor: 100,
        validAbilityUseCount: 0,
        changeCastTimeFlag: !1,
        funcMap: {
            entryCast: "entryCastAbilityUseCount",
            exitAction: "exitActionAbilityUseCount"
        },
        exclusive: {
            types: []
        }
    }, i[n.ATTACH_ELEMENT_LIGHTNING_WEAK] = {
        isAttachElement: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                102: 0
            }
        }],
        exclusive: {
            types: []
        }
    }, i[n.ATTACH_ELEMENT_LIGHTNING_MIDDLE] = {
        isAttachElement: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                102: 0
            }
        }],
        exclusive: {
            types: []
        }
    }, i[n.ATTACH_ELEMENT_LIGHTNING_STRONG] = {
        isAttachElement: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                102: 0
            }
        }],
        exclusive: {
            types: []
        }
    }, i[n.ATTACH_ELEMENT_FIRE_WEAK] = {
        isAttachElement: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                100: 0
            }
        }],
        exclusive: {
            types: []
        }
    }, i[n.ATTACH_ELEMENT_FIRE_MIDDLE] = {
        isAttachElement: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                100: 0
            }
        }],
        exclusive: {
            types: []
        }
    }, i[n.ATTACH_ELEMENT_FIRE_STRONG] = {
        isAttachElement: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                100: 0
            }
        }],
        exclusive: {
            types: []
        }
    }, i[n.TRANCE] = {
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "def",
            rate: 0
        }, {
            paramName: "matk",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }, {
            paramName: "mnd",
            rate: 0
        }, {
            paramName: "acc",
            rate: 0
        }, {
            paramName: "eva",
            rate: 0
        }, {
            paramName: "spd",
            rate: 0
        }],
        sparePanels: [{
            panelNo: 1,
            spareReceptorId: 0,
            highlight: !0
        }, {
            panelNo: 4,
            spareReceptorId: 0,
            highlight: !0
        }],
        funcMap: {
            entry: "entryTrance",
            update: "updateTimerTrance",
            exitAction: "exitActionTrance",
            exit: "exitTrance"
        },
        exclusive: {
            types: []
        }
    };
    var s = {};
    _.each(i, function(e, t) {
        s[t] = e.isContinuance
    });
    var o = {};
    o[t.STATUS_AILMENTS_BUNDLE.LOT] = [n.POISON, n.PARALYSIS, n.BLINDED, n.SILENCE, n.SLEEP, n.CONFUSION, n.PETRIFACTION, n.STOP], o[t.STATUS_AILMENTS_BUNDLE.ESNA] = [n.POISON, n.SILENCE, n.PARALYSIS, n.CONFUSION, n.BLINDED, n.SLEEP, n.PETRIFACTION, n.MINIMUM, n.TOAD, n.SUCTION, n.BERSERKER], o[t.STATUS_AILMENTS_BUNDLE.DISPEL] = [n.HASTE, n.PROTECT, n.SHELL, n.REFLECTION, n.REGEN, n.REGEN_MIDDLE, n.REGEN_STRONG, n.TRIPLE], o[t.STATUS_AILMENTS_BUNDLE.DEBARIA] = [n.PROTECT, n.SHELL, n.REFLECTION, n.MIGHTY_GUARD_1], o[t.STATUS_AILMENTS_BUNDLE.POISON_AND_PARALYSIS] = [n.POISON, n.PARALYSIS], o[t.STATUS_AILMENTS_BUNDLE.PHOTON_WING] = [n.SLEEP, n.SILENCE, n.BLINDED, n.CONFUSION, n.SAP], o[t.STATUS_AILMENTS_BUNDLE.POISON_AND_BLINDED] = [n.POISON, n.BLINDED], o[t.STATUS_AILMENTS_BUNDLE.SILENCE_AND_STAN] = [n.SILENCE, n.STAN], o[t.STATUS_AILMENTS_BUNDLE.SERAPHIC_RAY] = _.uniq([n.CUSTOM_MATK, n.CUSTOM_MND, n.CUSTOM_ATK, n.CUSTOM_DEF, n.CUSTOM_ATK_ACC, n.CUSTOM_EVA, n.CUSTOM_MDEF, n.CUSTOM_DEF_MDEF, n.CUSTOM_ATK_MATK_DEF_MDEF, n.CUSTOM_ATK_MATK, n.CUSTOM_ATK_DEF, n.RAID, n.CUSTOM_MATK_20_MDEF_50].concat(o[t.STATUS_AILMENTS_BUNDLE.DISPEL])), o[t.STATUS_AILMENTS_BUNDLE.BLINDED_AND_SILENCE] = [n.BLINDED, n.SILENCE], o[t.STATUS_AILMENTS_BUNDLE.CONFUSION_AND_SLEEP] = [n.CONFUSION, n.SLEEP], o[t.STATUS_AILMENTS_BUNDLE.POISON_AND_SILENCE_AND_BLINDED_AND_SLOW] = [n.POISON, n.SILENCE, n.BLINDED, n.SLOW], o[t.STATUS_AILMENTS_BUNDLE.PROTECT_AND_SHELL_AND_HASTE] = [n.PROTECT, n.SHELL, n.HASTE];
    var u = _.compact(_.map(i, function(e, t) {
        return e.isDoom ? +t : null
    }));
    _.map(u, function(e) {
        _.map(u, function(t) {
            if (e === t) return;
            i[e].exclusive.types.push(t)
        })
    });
    var a = _.compact(_.map(i, function(e, t) {
            return e.isReraise ? +t : null
        })),
        f = _.compact(_.map(i, function(e, t) {
            return _.isNumber(e.count) ? +t : null
        })),
        l = _.compact(_.map(i, function(e, t) {
            return e.isAttachElement ? +t : null
        }));
    FF.ns.battle.StatusAilmentsConfig = _.extend({
        doomIds: u,
        countIds: f,
        attachElementIds: l,
        reraiseIds: a,
        getParam: function(e) {
            return i[e]
        },
        isContinuanceStatus: function(e) {
            return !!s[e]
        },
        judgeExclusive: function(e, n) {
            var r = i[e],
                s = i[n];
            if (!s || !r) throw new Error("invalid status param.id=" + e + "," + n);
            if (e === n) return t.STATUS_AILMENTS_EXCLUSIVE.EXTRUDE;
            if (r.isAttachElement && s.isAttachElement) return t.STATUS_AILMENTS_EXCLUSIVE.EXTRUDE;
            var o = this._judgeExclusive(r, n),
                u = this._judgeExclusive(s, e),
                a = s.exclusive ? !!s.exclusive.blocking : !1;
            return o && u ? a ? t.STATUS_AILMENTS_EXCLUSIVE.BLOCK : t.STATUS_AILMENTS_EXCLUSIVE.EXTRUDE : o && !u ? t.STATUS_AILMENTS_EXCLUSIVE.EXTRUDE : !o && u ? t.STATUS_AILMENTS_EXCLUSIVE.BLOCK : t.STATUS_AILMENTS_EXCLUSIVE.TOGETHER
        },
        _judgeExclusive: function(e, t) {
            var n = e.exclusive || {};
            if (n.all) return !0;
            if (!_.isArray(n.types)) return !1;
            var r = n.types.indexOf(t) >= 0,
                i = n.invert ? !r : r;
            return i
        },
        isDefinedStatus: function(e) {
            return !!r[e]
        },
        getBundle: function(e) {
            var t = o[e];
            if (!t) throw new Error("unknown bundleId : " + e);
            return t
        }
    }, n)
}), define("scenes/battle/TextMaster", ["jquery", "lib/TextMaster", "lib/ClassBase"], function(e, t, n) {
    var r = n.extend({
            initialize: function() {
                this._libTxt = t.getInstance()
            },
            append: function(e) {
                this._libTxt.append(e)
            },
            get: function(e) {
                return this._libTxt.get(e)
            },
            getMobacoinUnit: function() {
                return this._libTxt.getMobacoinUnit()
            }
        }),
        i = void 0;
    FF.ns.battle.TextMaster = {
        getInstance: function() {
            return i || (i = new r), i
        }
    }
}), define("scenes/battle/ParameterEncoder", ["util"], function(e) {
    var t = ["init_hp", "soul_strike_gauge"],
        n = ["max_num", "num"],
        r = ["init_hp"],
        i = ["acc", "atk", "critical", "def", "eva", "matk", "mdef", "mnd", "spd"],
        s = ["hp", "ss_gauge", "sa", "panel1", "panel2", "panel3"],
        o = function(e) {
            var t = JSON.stringify(e),
                n = "";
            for (var r = 0; r < t.length; r++) {
                var i = t.charCodeAt(r) + 1;
                n += String.fromCharCode(i)
            }
            return n
        };
    FF.ns.battle.ParameterEncoder = {
        snapshotResponse: function(e) {
            var s = function(e) {
                    var n = e && e.params && e.params instanceof Array ? e.params[0] : null,
                        r = _.pick(n, i);
                    return r.ability_panels = u(e.ability_panels), _.extend(r, _.pick(e, t))
                },
                u = function(e) {
                    return _.map(e, function(e) {
                        return _.pick(e, n)
                    })
                },
                a = function(e) {
                    var t = {};
                    return t.enemy = _.map(e.enemy, function(e) {
                        return f(e)
                    }), t
                },
                f = function(e) {
                    var t = {};
                    return t.children = _.map(e.children, function(e) {
                        return l(e)
                    }), t
                },
                l = function(e) {
                    var t = {};
                    return t.params = _.map(e.params, function(e) {
                        return _.pick(e, i)
                    }), _.extend(t, _.pick(e, r))
                },
                c = {},
                h = e && e instanceof Object ? e.battle : null,
                p = h && h instanceof Object ? h.buddy : null,
                d = h && h instanceof Object ? h.rounds : null,
                v = h && h instanceof Object ? h.supporter : null;
            return p && (c.buddy = _.map(p, function(e) {
                return s(e)
            })), d && (c.rounds = _.map(d, function(e) {
                return a(e)
            })), v && v.length > 0 && v[0] instanceof Object && (c.supporter_ss_gauge = v[0].supporter_ss_gauge), o(c)
        },
        snapshotRequest: function(e) {
            var t = function(e) {
                    return _.reduce(e, function(e, t, n) {
                        return e[n] = _.pick(t, s), e
                    }, {})
                },
                n = {};
            return n.buddy = t(e.buddy), n.initChkResult = e.initChkResult, n.supporter_ss_gauge = e.supporter.supporter_ss_gauge, o(n)
        }
    }
}), define("scenes/battle/action/ActionBase", ["lib/NameConventionFsm"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.ActionBase = e.extend({
        initialize: function(n, r) {
            e.prototype.initialize.apply(this, arguments), this.executer = n, this._attributes = _.extend({
                castTime: 200,
                dependsWeaponEffect: !1,
                actionResult: void 0
            }, r), this._isDone = !1, this._isSuspended = !1, this._isResumed = !1, this._isCanceledInterruptAbility = !1, this.helper = new t.action.ActionHelper(this);
            var i = {},
                s = this.get("statusAilmentsId");
            s && (i[s] = this.get("statusAilmentsFactor")), this.set("atkStatusAilments", i);
            var o = t.Config.getInstance().get("MagicExerciseTypes");
            this._isMagic = _.contains(o, this.get("exerciseType"))
        },
        begin: function() {
            if (this.executer.isContainer()) {
                this.changeState("INIT");
                return
            }
            this.executer.notifyAbilityBegun(this);
            if (this.isEffectOfStatusAilements || this.isBossDeform) {
                this.changeState("INIT");
                return
            }
            this.executer.canDoAbility() ? this.isMagic() && !this.executer.canUseAllMagic() ? this.changeState("INVALIDITY") : this.changeState("INIT") : this.changeState("INVALIDITY")
        },
        processForStateInvalidityEntry: function() {
            var e = this;
            this.helper.showMessage({
                duration: 1e3
            }), this.changeState("WAIT_ANIM");
            var n = this.helper.makeAndSetActionResult(this.executer, this, []),
                r = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.INVALIDITY,
                    action: this,
                    actionResult: n
                }).addCallbackOnce("end", function() {
                    e._isDone = !0
                }).play()
        },
        isMagic: function() {
            return this._isMagic
        },
        exerciseType: function() {
            return this.get("exerciseType")
        },
        getAttributes: function() {
            return this._attributes
        },
        getCastTime: function() {
            return this._attributes.castTime
        },
        detectTargets: function() {
            return FF.ns.battle.util.Targeting.search(this)
        },
        isDone: function() {
            return this._isDone
        },
        suspend: function() {
            this._isSuspended = !0, this._isResumed = !1
        },
        resume: function() {
            this._isSuspended = !1, this._isResumed = !0
        },
        isSuspended: function() {
            return this._isSuspended
        },
        isResumed: function() {
            return this._isResumed
        },
        forceQuit: function() {
            this._isDone = !0
        },
        cancelInterruptAbility: function() {
            this._isCanceledInterruptAbility = !0
        },
        isCanceledInterruptAbility: function() {
            return this._isCanceledInterruptAbility
        }
    }), FF.ns.battle.action.ActionBase
}), define("scenes/battle/action/ActionHelper", ["lib/EventBase", "util"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.ActionHelper = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments), this._ability = t
        },
        _makeActionResult: function(e, t, n, r) {
            return _.extend({
                damageObjects: n,
                executer: e,
                ability: t
            }, r)
        },
        makeAndSetActionResult: function(e, t, n, r) {
            var i = this._makeActionResult(e, t, n, r);
            return t.set("actionResult", i), i
        },
        showMessage: function(e) {
            if (this._ability.get("skipMessage")) return;
            if (!this._ability.get("aliasName")) {
                var t = this._ability.get("name");
                if (this._ability.get("isCounter")) {
                    var r = n.TextMaster.getInstance().get("B10050");
                    t = r + t
                }
                t && n.Message.show(_.extend({
                    message: t
                }, e))
            }
        },
        physicalAttack: function(e, r) {
            var i = this,
                s = this._ability,
                o = this._ability.executer,
                u = [];
            return r = t.option({
                skipStatusAilments: !1
            }, r), _.each(e, function(t) {
                var a = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.ATTACK,
                    executer: o,
                    target: t,
                    ability: s,
                    targetNum: e.length,
                    forceHit: s.get("forceHit"),
                    forceCritical: s.get("forceCritical"),
                    forceMiss: s.get("forceMiss"),
                    defIgnored: s.get("defIgnored"),
                    atkExponentialFactor: s.get("atkExponentialFactor"),
                    defBoostIgnored: s.get("defBoostIgnored")
                });
                if (!r.skipStatusAilments) {
                    var f = s.get("atkStatusAilments"),
                        l = o.get("atkStatusAilments"),
                        c = _.isEmpty(f) ? l : f;
                    i._calculateStatusAilments({
                        target: t,
                        atkStatusAilments: c,
                        damageObject: a,
                        disableForceHit: !0
                    })
                }
                u.push(a)
            }), this.makeAndSetActionResult(o, s, u)
        },
        magicAttack: function(e, r) {
            var i = this,
                s = this._ability,
                o = this._ability.executer,
                u = [];
            return r = t.option({
                skipStatusAilments: !1
            }, r), _.each(e, function(e) {
                var t = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.MAGIC,
                    executer: o,
                    target: e,
                    ability: s,
                    defIgnored: s.get("defIgnored"),
                    defBoostIgnored: s.get("defBoostIgnored"),
                    matkExponentialFactor: s.get("matkExponentialFactor")
                });
                r.skipStatusAilments || i._calculateStatusAilments({
                    target: e,
                    damageObject: t
                }), u.push(t)
            }), this.makeAndSetActionResult(o, s, u)
        },
        lotStatusAilments: function(e) {
            var t = this,
                n = this._ability,
                r = this._ability.executer,
                i = [];
            return _.each(e, function(e) {
                var n = t._calculateStatusAilments({
                    target: e
                });
                i.push(n)
            }), this.makeAndSetActionResult(r, n, i)
        },
        lotStatusAilmentsByLevel: function(e, t) {
            var n = this,
                r = this._ability,
                i = this._ability.executer,
                s = [];
            return _.each(e, function(e) {
                var r = {
                    target: e
                };
                n._judgeHittableByLevel(e, t) ? r.forceHit = !0 : r.forceMiss = !0;
                var i = n._calculateStatusAilments(r);
                s.push(i)
            }), this.makeAndSetActionResult(i, r, s)
        },
        applyActionResult: function(e) {
            return this.applyDamageObjects(e.damageObjects)
        },
        applyActionResultForBarrage: function(e) {
            _.each(e.damageObjects, function(e) {
                this.applyDamageObjects(e)
            }, this)
        },
        applyDamageObjects: function(e) {
            _.each(e, function(e) {
                e.receiver.applyDamageObject(e)
            })
        },
        _calculateStatusAilments: function(e) {
            var t = this._ability,
                r = this._ability.executer,
                i = e.target,
                s = e.atkStatusAilments || t.get("atkStatusAilments"),
                o = e.forceHit || t.get("forceHit"),
                u = e.forceMiss || t.get("forceMiss"),
                a = e.damageObject;
            if (a && !a.canHit) return;
            return n.util.DamageCalculator.calculate({
                type: n.Conf.CALC_TYPE.STATUS_AILMENTS,
                executer: r,
                target: i,
                ability: t,
                atkStatusAilments: s,
                statusAilmentsOptions: t.get("statusAilmentsOptions"),
                forceHit: e.disableForceHit ? !1 : o,
                forceMiss: e.disableForceMiss ? !1 : u,
                damageObject: a
            })
        },
        _judgeHittableByLevel: function(e, t) {
            var n = e.receiver.get("level");
            return n % t === 0
        },
        detectDeformAnimationInfo: function() {
            var e = this._ability.executer;
            if (!e.isEnemy()) throw new Error("this function is useful for only enemy");
            if (e.isContainer()) throw new Error("not allow container execution");
            var t = void 0;
            t = this._ability.get("animationId");
            if (t) return {
                animationId: t
            };
            var n = e.get("no"),
                r = this._ability.get("abilityId"),
                i = e.container.get("abilityDeformMapTag") || {},
                s = i[n] && i[n][r];
            if (s) return {
                deformTag: s
            };
            var o = e.container.get("abilityDeformMap") || {};
            t = o[n] && o[n][r];
            if (t) return {
                animationId: t
            };
            throw new Error("not configure valid abilityDeformMap into AI")
        }
    })
}), define("scenes/battle/action/BuiltinHealDeathAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {
            activeTargetMethod: n.ACTIVE_TARGET_METHOD.OPPONENT_DISABLE,
            exerciseType: n.EXERCISE_TYPE.WHITE_MAGIC,
            ignoresReflection: !0,
            statusAilmentsId: n.STATUS_AILMENTS_TYPE.DEATH,
            targetDeath: n.TARGET_DEATH.INCLUDE,
            targetMethod: n.TARGET_METHOD.SA_RANDOM,
            targetRange: n.TARGET_RANGE.SINGLE,
            targetSegment: n.TARGET_SEGMENT.COLLEAGUE
        };
    FF.ns.battle.action.BuiltinHealDeathAction = e.extend({
        initialize: function(t, n) {
            n = _.extend({}, r, n), e.prototype.initialize.call(this, t, n)
        },
        getActionResultWithTargets: function(e) {
            var r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: n.CALC_TYPE.HEAL_DEATH,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: this.get("hitRate"),
                    hpFactor: this.get("hpFactor")
                });
                r.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        }
    })
}), define("scenes/battle/action/BuiltinIncreaseMpAction", ["./ActionBase", "util"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf,
        i = {
            activeTargetMethod: r.ACTIVE_TARGET_METHOD.BOTH_DISABLE,
            exerciseType: r.EXERCISE_TYPE.INBORN,
            targetDeath: r.TARGET_DEATH.EXCLUDE,
            targetMethod: r.TARGET_METHOD.NOTHING,
            targetRange: r.TARGET_RANGE.ALL,
            targetSegment: r.TARGET_SEGMENT.COLLEAGUE
        };
    FF.ns.battle.action.BuiltinIncreaseMpAction = e.extend({
        initialize: function(t, n) {
            n = _.extend({}, i, n), e.prototype.initialize.call(this, t, n)
        },
        getActionResultWithTargetsAndParams: function(e, t) {
            var r = this,
                i = [];
            return _.each(e, function(e) {
                var r = void 0;
                e.receiver.isBuddy() && (r = n.util.PanelTargeting.search(e.receiver, {
                    receptable: n.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                    remainNum: t.remainNum,
                    usedNum: t.usedNum
                }));
                var s = r ? t.hitRate : 0,
                    o = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.ABILITY_PANEL,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        abilityPanel: r,
                        isDecrease: !1,
                        damageFactor: t.damageFactor,
                        hitRate: s,
                        isRemainingBase: !1
                    });
                i.push(o)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, i)
        }
    })
}), define("scenes/battle/action/BuiltinInflictSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {
            activeTargetMethod: n.ACTIVE_TARGET_METHOD.BOTH_DISABLE,
            exerciseType: n.EXERCISE_TYPE.INBORN,
            targetDeath: n.TARGET_DEATH.EXCLUDE,
            targetMethod: n.TARGET_METHOD.NOTHING,
            targetRange: n.TARGET_RANGE.SELF,
            targetSegment: n.TARGET_SEGMENT.COLLEAGUE
        };
    FF.ns.battle.action.BuiltinInflictSaAction = e.extend({
        initialize: function(t, n) {
            n = _.extend({}, r, n), e.prototype.initialize.call(this, t, n)
        },
        getActionResultWithTargetsAndParams: function(e, r) {
            var i = [];
            return _.each(e, function(e) {
                var s = t.util.DamageCalculator.calculate({
                    type: n.CALC_TYPE.STATUS_AILMENTS,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    atkStatusAilments: r.atkStatusAilments,
                    statusAilmentsOptions: r.statusAilmentsOptions
                });
                i.push(s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, i)
        }
    })
}), define("scenes/battle/action/CustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.CustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg1")
                },
                infoMap: {
                    duration: this.get("arg2")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.lotStatusAilments(this.detectTargets());
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/CustomParamAndSelfDestructAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.CustomParamAndSelfDestructAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg1")
                },
                infoMap: {
                    duration: this.get("arg2")
                }
            }), this.set("deathRate", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var t = this,
                r = this.executer,
                i = this.detectTargets();
            this.helper.showMessage();
            var s = this.helper.lotStatusAilments(this.detectTargets()),
                o = e.lotByFraction(this.get("deathRate"));
            this.changeState("WAIT_ANIM");
            var u = n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: s,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                t.helper.applyActionResult(s), o && r.statusAilments.set(n.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH, r), t._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/DoNothingAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.DoNothingAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this._isDone = !0
        }
    })
}), define("scenes/battle/action/DamagedHpAttackAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.DamagedHpAttackAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.DAMAGED_HP,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/DefenseAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = 1e3;
    FF.ns.battle.action.DefenseAction = e.extend({
        initialize: function(n, r) {
            e.prototype.initialize.apply(this, arguments), this.set("name", t.TextMaster.getInstance().get("B10040"))
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var r = t.util.DamageCalculator.makeDamageObject(this.executer, this.executer, this);
            r.statusAilments = [t.Conf.STATUS_AILMENTS_TYPE.DEFENSE];
            var i = this.helper.makeAndSetActionResult(this.executer, this, [r]);
            this.helper.applyActionResult(i), this.changeState("WAIT_ANIM"), t.util.DelayCallback.register(n, function() {
                e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/DeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = 1e3;
    FF.ns.battle.action.DeformAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), _.bindAll(this, "onDeformEnd"), this.set("messageId", n.messageId), this.set("animationId", n.animationId), this.set("looking", n.looking), this.set("shouldDeformAllNodes", !!n.shouldDeformAllNodes), this.isBossDeform = !0
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.changeState("WAIT_ANIM");
            var r = $.Deferred(),
                i = function() {
                    r.resolve()
                },
                s = $.Deferred(),
                o = function() {
                    s.resolve()
                },
                u = this.get("messageId");
            u ? t.Message.showByMessageId(u, {
                callback: o
            }) : o();
            var a = this.executer.container ? this.executer.container : this.executer;
            FF.logger.debug("DEFORM", {
                animationType: t.Conf.ANIMATION_TYPE.DEFORM,
                enemyContainer: a,
                animationInfo: {
                    animationId: this.get("animationId"),
                    deformTag: this.get("deformTag")
                },
                messageId: u
            });
            if (this.get("animationId") || this.get("deformTag")) {
                var f = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM,
                    enemyContainer: a,
                    animationInfo: {
                        animationId: this.get("animationId"),
                        deformTag: this.get("deformTag")
                    },
                    shouldDeformAllNodes: this.get("shouldDeformAllNodes")
                });
                f.addCallbackOnce("end", i), f.play()
            } else t.util.DelayCallback.register(n, i);
            $.when(r.promise(), s.promise()).then(function() {
                e.onDeformEnd()
            })
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/DeformMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = 1e3,
        r = {
            SET_SA: function(e) {
                var n = t.ai.AiUtil.getActors(this.executer, e.saChildNos);
                _.each(n, function(t) {
                    t.setStatusAilments(e.sa)
                })
            }
        };
    FF.ns.battle.action.DeformMultiAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this.set("sequence", n.sequence), this.set("shouldDeformAllNodes", !!n.shouldDeformAllNodes), this.set("skipEnemyName", !!n.skipEnemyName), this.isBossDeform = !0
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.changeState("WAIT_ANIM");
            var t = this.get("sequence"),
                n = $.Deferred().resolve();
            _.each(t, function(t) {
                n = n.then(function() {
                    var n = [];
                    for (var r = 0, i = t.length; r < i; r++) n.push(e._executeDeferred(t[r]));
                    return $.when.apply($, n)
                })
            }), n.then(function() {
                e._isDone = !0
            })
        },
        _executeDeferred: function(e) {
            return FF.logger.debug("DEFORM_MULTI", e), e.messageId ? this._executeMessageDeferred(e) : e.animationId || e.deformTag ? this._executeAnimationDeferred(e) : e.builtin ? this._executeBuiltinDeferred(e) : (FF.logger.error("DEFORM MULTI:nothing to do"), $.Deferred().resolve().promise())
        },
        _executeMessageDeferred: function(e) {
            var n = e.messageId,
                r = e.buddyId,
                i = e.buddyIds,
                s = e.enemyNo,
                o = !!e.isAny,
                u = !0,
                a = void 0;
            r && (a = _.find(t.ActorMgr.getAllBuddies(), function(e) {
                return e.getId() === r
            }));
            if (i) {
                var f = _.map(t.ActorMgr.getAliveBuddies(), function(e) {
                    return e.getId()
                });
                o ? _.any(i, function(e) {
                    return _.contains(f, e)
                }) || (u = !1) : _.all(i, function(e) {
                    return _.contains(f, e)
                }) || (u = !1)
            }
            var l = this.executer.container ? this.executer.container : this.executer,
                c = void 0;
            s && (c = l.getChild(s)), r && !a && (u = !1), s && !c && (u = !1), a && a.isDead() && (u = !1), c && c.isDead() && (u = !1);
            var h = $.Deferred();
            return u ? t.Message.showByMessageId(n, {
                callback: function() {
                    h.resolve()
                },
                duration: e.duration
            }) : (FF.logger.debug("should not show"), h.resolve()), h.promise()
        },
        _executeAnimationDeferred: function(e) {
            var n = e.animationId,
                r = e.deformTag,
                i = this.executer.container ? this.executer.container : this.executer,
                s = _.isUndefined(e.shouldDeformAllNodes) ? this.get("shouldDeformAllNodes") : !!e.shouldDeformAllNodes,
                o = _.isUndefined(e.skipEnemyName) ? this.get("skipEnemyName") : !!e.skipEnemyName,
                u = $.Deferred(),
                a = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM,
                    enemyContainer: i,
                    animationInfo: {
                        animationId: n,
                        deformTag: r
                    },
                    shouldDeformAllNodes: s,
                    skipEnemyName: o
                });
            return a.addCallbackOnce("end", function() {
                u.resolve()
            }), a.play(), u.promise()
        },
        _executeBuiltinDeferred: function(e) {
            var t = r[e.builtin];
            return t.call(this, e), $.Deferred().resolve().promise()
        }
    })
}), define("scenes/battle/action/EnemyJumpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.EnemyJumpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", t.Conf.ATK_TYPE.INDIRECT), this.set("isFlightAttack", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.ENEMY_JUMP,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/EntrustSsPointAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.EntrustSsPointAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this._calc(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.ENTRUSTING_SS_POINT,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/FractionalAttackByHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FractionalAttackByHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageRate", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FRACTION,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    statusAilmentsId: this.get("statusAilmentsId"),
                    statusAilmentsFactor: this.get("statusAilmentsFactor"),
                    numerator: e.receiver.get("hp")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/FractionalAttackByMaxHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FractionalAttackByMaxHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageRate", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FRACTION,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    statusAilmentsId: this.get("statusAilmentsId"),
                    statusAilmentsFactor: this.get("statusAilmentsFactor"),
                    numerator: e.receiver.get("maxHp")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/FractionalAttackByHpWithoutSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FractionalAttackByHpWithoutSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageRate", this.get("arg1")), this.set("useMaxHp", !!this.get("arg2")), this.set("forceHitWithoutSa", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = this.get("useMaxHp") ? "maxHp" : "hp",
                r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FRACTION,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    statusAilmentsId: this.get("statusAilmentsId"),
                    statusAilmentsFactor: this.get("statusAilmentsFactor"),
                    numerator: e.receiver.get(n),
                    forceHitWithoutSa: this.get("forceHitWithoutSa")
                });
                r.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        }
    }), FF.ns.battle.action.FractionalAttackByHpWithoutSaAction
}), define("scenes/battle/action/FractionalAttackByHpWithoutSaAndInflictSaAction", ["./FractionalAttackByHpWithoutSaAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FractionalAttackByHpWithoutSaAndInflictSaAction = e.extend({
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r),
                s = [];
            _.each(i.damageObjects, function(n) {
                if (n.canHit) {
                    var r = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: n,
                        ability: e,
                        atkStatusAilments: e.get("atkStatusAilments"),
                        statusAilmentsOptions: e.get("statusAilmentsOptions")
                    });
                    s.push(r)
                }
            }), this.changeState("WAIT_ANIM");
            var o = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                _.each(s, function(e) {
                    i.damageObjects.push(e)
                }), e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/FractionalHealByHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FractionalHealByHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this._calc(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FRACTION_HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    numerator: e.receiver.get("maxHp")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    }), FF.ns.battle.action.FractionalHealByHpAction
}), define("scenes/battle/action/PhysicalAttackElementAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkElement", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg5")
                },
                infoMap: {
                    duration: this.get("arg6") || 25e3
                }
            }), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealDeathAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealDeathAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("hitRate", this.get("arg1")), this.set("hpFactor", this.get("arg2"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this._calc(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL_DEATH,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: this.get("hitRate"),
                    hpFactor: this.get("hpFactor")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/ReraiseRiseAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = 500;
    FF.ns.battle.action.ReraiseRiseAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.isEffectOfStatusAilements = !0, this.set("hitRate", 100)
        },
        processForStateInitUpdate: function() {
            var e = this,
                r = t.util.Targeting.makeResult(t.ActorMgr.getReraiseDeathBuddies());
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.RERAISE_RISE,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            });
            t.util.DelayCallback.registerForBattle(n, function() {
                s.play()
            })
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = e.receiver.statusAilments.getHpRateForReraise();
                this.set("hpFactor", r || 1);
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL_DEATH,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: this.get("hitRate"),
                    hpFactor: this.get("hpFactor")
                });
                n.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/HealHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.HealHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this._calc(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    }), FF.ns.battle.action.HealHpAction
}), define("scenes/battle/action/HealHpAndCustomParamAction", ["./HealHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg4")
                },
                infoMap: {
                    duration: this.get("arg5")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this._calc(n),
                i = [];
            _.each(r.damageObjects, function(n) {
                if (n.canHit) {
                    var r = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: n,
                        ability: e,
                        atkStatusAilments: e.get("atkStatusAilments"),
                        statusAilmentsOptions: e.get("statusAilmentsOptions")
                    });
                    i.push(r)
                }
            }), this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                _.each(i, function(e) {
                    r.damageObjects.push(e)
                }), e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealHpAndInflictSaAction", ["./HealHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndInflictSaAction = e.extend({
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n),
                i = [];
            _.each(r.damageObjects, function(n) {
                if (!n.canHit) return;
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: e.executer,
                    target: n,
                    ability: e,
                    atkStatusAilments: e.get("atkStatusAilments"),
                    statusAilmentsOptions: e.get("statusAilmentsOptions")
                });
                i.push(r)
            }), this.helper.showMessage(), this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                r.damageObjects = r.damageObjects.concat(i), e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealHpAndHealSaMultiAction", ["./HealHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this._calc(n),
                i = [],
                s = this.get("healStatusAilmentIds"),
                o = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAll(), function(t) {
                    return t.isColleague(e.executer) && t.isAlive({
                        pureDeath: !0
                    })
                }));
            _.each(o, function(e) {
                var n = e.receiver,
                    r = _.intersection(s, n.statusAilments.getRefs()),
                    o = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.HEAL_SA,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        hitRate: r.length > 0 ? 100 : 0,
                        statusAilmentsIds: r
                    });
                i.push(o), FF.logger.info("HEAL_SA_MULTI", "ids", r)
            }, this), this.changeState("WAIT_ANIM");
            var u = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                r.damageObjects = r.damageObjects.concat(i), e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealHpAndHealSaAction", ["./HealHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndHealSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = _.filter(n, function(e) {
                    return e.receiver.isAlive()
                }),
                i = n,
                s = this._calc(r),
                o = [],
                u = this.get("healStatusAilmentIds");
            _.each(i, function(e) {
                var n = e.receiver,
                    r = _.intersection(u, n.statusAilments.getRefs()),
                    i = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.HEAL_SA,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        hitRate: r.length > 0 ? 100 : 0,
                        statusAilmentsIds: r
                    });
                o.push(i), FF.logger.info("HEAL_SA_MULTI", "ids", r)
            }, this), this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: s
            }).addCallbackOnce("end", function() {
                s.damageObjects = s.damageObjects.concat(o), e.helper.applyActionResult(s), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealSaAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.HealSaAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("hitRate", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.detectTargets();
            this.helper.showMessage();
            var r = this._calc(t);
            this.changeState("WAIT_ANIM"), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var t = [];
            return _.each(e, function(e) {
                var r = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.HEAL_SA,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: this.get("hitRate"),
                    statusAilmentsIds: this.get("healStatusAilmentIds")
                });
                t.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, t)
        }
    })
}), define("scenes/battle/action/HealSaLotAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.HealSaLotAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM"), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(t) {
            var r = [],
                i = n.StatusAilmentsConfig.getBundle(n.Conf.STATUS_AILMENTS_BUNDLE.LOT);
            return _.each(t, function(t) {
                var s = t.receiver,
                    o = _.intersection(i, s.statusAilments.getRefs()),
                    u = void 0;
                o.length && (u = e.lot(o, function() {
                    return 100
                }));
                var a = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.HEAL_SA,
                    executer: this.executer,
                    target: t,
                    ability: this,
                    hitRate: u ? 100 : 0,
                    statusAilmentsIds: [u]
                });
                r.push(a), FF.logger.info("HEAL_SA_LOT", "id", u)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        }
    })
}), define("scenes/battle/action/HealSaMultiAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.HealSaMultiAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM"), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var t = [],
                r = this.get("healStatusAilmentIds");
            return _.each(e, function(e) {
                var i = e.receiver,
                    s = _.intersection(r, i.statusAilments.getRefs()),
                    o = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.HEAL_SA,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        hitRate: s.length > 0 ? 100 : 0,
                        statusAilmentsIds: s
                    });
                t.push(o), FF.logger.info("HEAL_SA_MULTI", "ids", s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, t)
        }
    })
}), define("scenes/battle/action/HealAndInflictSaAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.HealAndInflictSaAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("hitRate", this.get("arg1"));
            var e = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(t) {
                r[t] = e
            }, this), this.set("atkStatusAilments", r), this.set("forceHit", !!this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.detectTargets();
            this.helper.showMessage();
            var r = this._calcHeal(t),
                i = this.helper.lotStatusAilments(t);
            this.changeState("WAIT_ANIM"), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calcHeal: function(e) {
            var t = [];
            return _.each(e, function(e) {
                var r = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.HEAL_SA,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: this.get("hitRate"),
                    statusAilmentsIds: [this.get("statusAilmentsId")]
                });
                t.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, t)
        }
    })
}), define("scenes/battle/action/InflictSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.InflictSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this), this.set("atkStatusAilments", r)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.helper.lotStatusAilments(this.detectTargets());
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/InflictSaAndFallbackMagicAttackAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.InflictSaAndFallbackMagicAttackAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.get("statusAilmentsId"),
                i = _.filter(n, function(e) {
                    var t = e.receiver.get("defAttributeMap");
                    return t[r] ? !1 : !0
                }),
                s = _.difference(n, i),
                o = this.helper.lotStatusAilments(i),
                u = this.helper.magicAttack(s).damageObjects;
            o.damageObjects = o.damageObjects.concat(u), this.helper.showMessage(), this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(o), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/InflictSaAndIncreaseMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.InflictSaAndIncreaseMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("hitRate", this.get("arg2")), this.set("remainNum", this.get("arg3")), this.set("usedNum", this.get("arg4"));
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this), this.set("atkStatusAilments", r)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = [],
                s = this.helper.lotStatusAilments(r);
            i.push(s.damageObjects);
            var o = this._calcIncreaseMpDamgageObjects(r);
            i.push(o);
            var u = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: u,
                options: {
                    skipDamageMotionCountMap: {
                        1: !0
                    }
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(u), e._isDone = !0
            }).play()
        },
        _calcIncreaseMpDamgageObjects: function(e) {
            var n = this,
                r = [];
            return _.each(e, function(e) {
                var i = void 0;
                e.receiver.isBuddy() && (i = t.util.PanelTargeting.search(e.receiver, {
                    receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                    remainNum: n.get("remainNum"),
                    usedNum: n.get("usedNum")
                }));
                var s = i ? n.get("hitRate") : 0,
                    o = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.ABILITY_PANEL,
                        executer: n.executer,
                        target: e,
                        ability: n,
                        abilityPanel: i,
                        isDecrease: !1,
                        damageFactor: n.get("damageFactor"),
                        hitRate: s,
                        isRemainingBase: !1
                    });
                r.push(o)
            }), r
        }
    })
}), define("scenes/battle/action/InflictSaHitAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.InflictSaHitAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("forceHit", !0);
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this), this.set("atkStatusAilments", r)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.helper.lotStatusAilments(this.detectTargets());
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    }), FF.ns.battle.action.InflictSaHitAction
}), define("scenes/battle/action/InflictSaHitAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.InflictSaHitAndDeformAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this.set("forceHit", !0);
            var r = this.get("statusAilmentsFactor"),
                i = this.get("atkStatusAilmentIds"),
                s = {};
            _.each(i, function(e) {
                s[e] = r
            }, this), this.set("checkCanExecAbilityFlag", this.get("arg5")), this.set("atkStatusAilments", s)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this.helper.lotStatusAilments(n),
                i = this.executer.container ? this.executer.container : this.executer;
            this.get("checkCanExecAbilityFlag") && !n.length ? this.changeState("INVALIDITY") : (this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                action: this,
                actionResult: r,
                enemyContainer: i,
                animationInfo: this.helper.detectDeformAnimationInfo(),
                options: {
                    skipDamageMotion: !0,
                    usesMainNode: !!this.get("usesMainNode")
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play())
        }
    })
}), define("scenes/battle/action/JumpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.JumpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", t.Conf.ATK_TYPE.INDIRECT), this.set("flightDuration", this.get("arg2")), this.set("atkElement", this.get("arg3")), this.set("isFlightAttack", !0)
        },
        forceQuit: function() {
            this.isState("INIT") && this._callbackId && (t.util.DelayCallback.clear(this._callbackId), this.resume())
        },
        begin: function() {
            e.prototype.begin.apply(this, arguments)
        },
        processForStateInitEntry: function() {
            var e = this,
                n = this.executer;
            this.helper.showMessage();
            var r = t.util.DamageCalculator.makeDamageObject(n, n, this, {
                statusAilments: [t.Conf.STATUS_AILMENTS_TYPE.INVISIBLE]
            });
            n.applyDamageObject(r);
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.JUMP_OUT,
                action: this
            }).addCallbackOnce("end", function() {
                e.suspend(), e._callbackId = t.util.DelayCallback.registerForBattle(e.get("flightDuration"), function() {
                    e.resume()
                })
            }).play()
        },
        processForStateInitUpdate: function() {
            var e = this.executer;
            if (this.isResumed()) {
                var n = t.util.DamageCalculator.makeDamageObject(e, e, this, {
                    unsetStatusAilments: [t.Conf.STATUS_AILMENTS_TYPE.INVISIBLE]
                });
                e.applyDamageObject(n), this.changeState("FALL")
            }
        },
        processForStateFallUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.JUMP_IN,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndSelfSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndSelfSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.set("selfSaBundleId", this.get("arg7")), this.set("forceHitSelfSa", this.get("arg8")), this.set("dependsWeaponEffect", !0);
            var n = {},
                r = t.StatusAilmentsConfig.getBundle(this.get("selfSaBundleId"));
            _.each(r, function(e) {
                n[e] = 100
            }), this.set("selfStatusAilments", n)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = this.get("forceHitSelfSa"),
                u = [],
                a;
            for (var f = 1; f <= r; f++) {
                if (!s || !i) i = this.detectTargets();
                var l = this.helper.physicalAttack(i);
                a || (a = _.any(l.damageObjects, function(e) {
                    return e.canHit
                })), u.push(l.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(u);
            var c = this.helper.makeAndSetActionResult(n, this, u),
                h = void 0;
            if (a || o) h = e._calcSelfSa();
            this.changeState("WAIT_ANIM");
            var p = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: c
            }).addCallbackOnce("end", function() {
                h && c.damageObjects.push([h]), e.helper.applyActionResultForBarrage(c), e._isDone = !0
            }).play()
        },
        _calcSelfSa: function() {
            var e = this,
                n = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: e.executer,
                    target: _.first(t.util.Targeting.makeResult(e.executer)),
                    ability: e,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceHit: !0
                });
            return n
        }
    })
}), define("scenes/battle/action/LotAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.LotAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            var e = [];
            _.each(["arg1", "arg2", "arg3", "arg4", "arg5", "arg6", "arg7", "arg8", "arg9", "arg10"], function(t) {
                this.get(t) && e.push(this.get(t))
            }, this), this.set("lotAbilityIds", e), this.set("wrappedAbility", null)
        },
        update: function() {
            t.prototype.update.apply(this, arguments);
            var e = this.get("wrappedAbility");
            e && e.update()
        },
        processForStateInitUpdate: function() {
            var t = this,
                r = this.executer,
                i = t.get("lotAbilityIds");
            if (i.length === 0) throw new Error("not found lotAbilityIds.");
            var s = e.lot(i, function() {
                    return 100
                }, {}),
                o = n.AbilityFactory.create(s, r, {});
            _.each(["activeTarget", "isAbilityPanel", "isSoulStrike", "receptorId"], function(e) {
                this.has(e) && o.set(e, this.get(e))
            }, this), this.set("wrappedAbility", o), this.changeState("WAIT_ANIM")
        },
        processForStateWaitAnimEntry: function() {
            var e = this.get("wrappedAbility");
            if (!e) return;
            e.begin()
        },
        processForStateWaitAnimUpdate: function() {
            var e = this.get("wrappedAbility");
            if (!e) return;
            e.isDone() && (this._isDone = !0)
        }
    })
}), define("scenes/battle/action/MagicAttackAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndAbsorbHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndAbsorbHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("absorbHpFactor", this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndDefIgnoredAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndDefIgnoredAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("matkExponentialFactor", this.get("arg4")), this.set("defIgnored", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndDefIgnoredAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndDefIgnoredAndDeformAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("matkExponentialFactor", this.get("arg4")), this.set("defIgnored", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/MagicAttackAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndDeformAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/MagicAttackAndDefBoostIgnoredAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndDefBoostIgnoredAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("defBoostIgnored", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("barrageNum", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5"))
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.magicAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackMultiWithMultiSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiWithMultiSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("barrageNum", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5"));
            var t = {},
                n = this.get("statusAilmentsFactor");
            _.each(this.get("atkStatusAilmentIds"), function(e) {
                t[e] = n
            }), this.set("atkStatusAilments", t)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.magicAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndHealHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndHealHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this._atkParams = {
                damageFactor: this.get("arg1"),
                matkElement: this.get("arg2"),
                minDamageFactor: this.get("arg3"),
                targetSegment: t.Conf.TARGET_SEGMENT.OPPONENT,
                targetRange: t.Conf.TARGET_RANGE.ALL
            }, this._healParams = {
                factor: this.get("arg4"),
                matkElement: this.get("arg5")
            }
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = void 0,
                i = [];
            _.extend(this._attributes, this._atkParams), r = this.detectTargets();
            var s = this.helper.magicAttack(r);
            i.push(s.damageObjects), _.extend(this._attributes, this._healParams), r = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAliveActors(), function(e) {
                return e.isColleague(n)
            }));
            var o = this._calc(r);
            i.push(o);
            var u = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: u
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(u), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), n
        }
    })
}), define("scenes/battle/action/MagicAttackAndPhysicalAttackElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndPhysicalAttackElementAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("magicalAttackDamageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("physicalAttackDamageFactor", this.get("arg3")), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5")), this.set("atkElement", this.get("arg6")), this.set("dependsWeaponEffect", !0), this.set("isSameTarget", !!this.get("arg7"))
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("isSameTarget"),
                i = [],
                s = this.detectTargets();
            this.set("damageFactor", this.get("magicAttackDamageFactor"));
            var o = this.helper.magicAttack(s);
            i.push(o.damageObjects), r || (s = this.detectTargets()), this.set("damageFactor", this.get("physicalAttackDamageFactor")), o = this.helper.physicalAttack(s), i.push(o.damageObjects), t.util.DamageCalculator.recalculateHp(i);
            var u = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: u
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(u), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndPartyCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndPartyCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("matkElement", this.get("arg3")), this.set("isSameTarget", !!this.get("arg4")), this.set("minDamageFactor", this.get("arg8"));
            var t = this.get("arg5"),
                n = {};
            n[t] = 1, this.set("partyStatusAilments", n), this.set("partyStatusAilmentsOptions", {
                boost: {
                    rate: this.get("arg6")
                },
                infoMap: {
                    duration: this.get("arg7")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.magicAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this._calcCustomParam();
            o.push(f);
            var l = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var c = {};
            c[r + 1] = !0;
            var h = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l,
                options: {
                    skipDamageMotionCountMap: c
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        },
        _calcCustomParam: function() {
            var e = this,
                n = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAliveActors(), function(t) {
                    return t.isColleague(e.executer)
                })),
                r = [];
            return _.each(n, function(e) {
                var n = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    atkStatusAilments: this.get("partyStatusAilments"),
                    statusAilmentsOptions: this.get("partyStatusAilmentsOptions"),
                    forceHit: !0
                });
                r.push(n)
            }, this), r
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndInflictSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndInflictSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("barrageNum", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5"));
            var t = {};
            t[this.get("statusAilmentsId")] = this.get("statusAilmentsFactor"), t[this.get("arg6")] = this.get("arg7"), t[this.get("arg8")] = this.get("arg9"), this.set("atkStatusAilments", t)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.magicAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackWithMultiSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackWithMultiSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("saBundleId", this.get("arg3"));
            var n = t.StatusAilmentsConfig.getBundle(this.get("saBundleId")),
                r = {},
                i = this.get("statusAilmentsFactor");
            _.each(n, function(e) {
                r[e] = i
            }), this.set("atkStatusAilments", r), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/ParamBoosterAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.ParamBoosterAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("forceHit", !0), this.set("statusAilmentsOptions", {
                infoMap: {
                    duration: this.get("arg1")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this.helper.lotStatusAilments(n);
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.PhysicalAttackAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3")), this.set("paramConvertType", this.get("arg4")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    }), FF.ns.battle.action.PhysicalAttackAction
}), define("scenes/battle/action/PhysicalAttackAndAbsorbHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndAbsorbHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("absorbHpFactor", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg2")
                },
                infoMap: {
                    duration: this.get("arg3")
                }
            }), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndDefIgnoredAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndDefIgnoredAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3")), this.set("atkExponentialFactor", this.get("arg4")), this.set("defIgnored", !0), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndHpBarterAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndHpBarterAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barterRate", this.get("arg2")), this.set("atkElement", this.get("arg3")), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HP_BARTER,
                    executer: n,
                    receiver: n,
                    ability: e
                }),
                s = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var o = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: s
            }).addCallbackOnce("end", function() {
                e.helper.applyDamageObjects([i]), e.helper.applyActionResult(s), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackCriticalOrMissAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackCriticalOrMissAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("rate", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var t = this,
                r = this.executer,
                i = this.detectTargets();
            this.helper.showMessage();
            var s = e.lotByFraction(this.get("rate"));
            this.set("forceCritical", s), this.set("forceMiss", !s);
            var o = this.helper.physicalAttack(i);
            this.changeState("WAIT_ANIM");
            var u = n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                t.helper.applyActionResult(o), t._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkElement", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackHitAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackHitAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("dependsWeaponEffect", !0), this.set("forceHit", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.get("arg7") > 0 && this.set("critical", this.get("arg7")), this.set("paramConvertType", this.get("arg8")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiWithMultiParamsAction", ["underscore", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiWithMultiParamsAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this._paramsList = [{
                damageFactor: this.get("arg1"),
                barrageNum: this.get("arg2"),
                atkType: this.get("arg3"),
                forceHit: this.get("arg4"),
                targetRange: this.get("arg5")
            }, {
                barrageNum: this.get("arg7") ? this.get("arg7") : 1,
                atkType: this.get("arg8") ? this.get("arg8") : 2,
                forceHit: this.get("arg9") ? this.get("arg9") : 1,
                targetRange: this.get("arg10") ? this.get("arg10") : n.Conf.TARGET_RANGE.ALL,
                damageFactor: this.get("arg11") ? this.get("arg11") : 210
            }], this.set("isSameTarget", !!this.get("arg6")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var t = this,
                r = [];
            e.each(this._paramsList, function(e) {
                r = r.concat(t._calcWithParams(e))
            }), n.util.DamageCalculator.recalculateHp(r);
            var i = this.helper.makeAndSetActionResult(this.executer, this, r);
            this.helper.showMessage(), this.changeState("WAIT_ANIM"), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                t.helper.applyActionResultForBarrage(i), t._isDone = !0
            }).play()
        },
        _calcWithParams: function(t) {
            e.extend(this._attributes, t);
            var n = [],
                r = this.get("barrageNum"),
                i, s, o = this.get("isSameTarget");
            for (var u = 1; u <= r; u++) {
                if (!o || !i) i = this.detectTargets();
                s = this.helper.physicalAttack(i), n.push(s.damageObjects)
            }
            return n
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiWithMultiSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiWithMultiSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.set("dependsWeaponEffect", !0);
            var t = {},
                n = this.get("statusAilmentsFactor");
            _.each(this.get("atkStatusAilmentIds"), function(e) {
                t[e] = n
            }), this.set("atkStatusAilments", t)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackWithoutAimingBySaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackWithoutAimingBySaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3")), this.set("dependsWeaponEffect", !0)
        },
        detectTargets: function() {
            var e = this.get("statusAilmentsId"),
                n = _.filter(t.ActorMgr.getAll(), function(t) {
                    return !t.statusAilments.has(e)
                });
            return FF.ns.battle.util.Targeting.search(this, {
                actors: n
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r, {
                skipStatusAilments: !0
            });
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg2")
                },
                infoMap: {
                    duration: this.get("arg3")
                }
            }), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5")), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r, {
                    skipStatusAilments: !0
                }),
                s = _.any(i.damageObjects, function(e) {
                    return e.canHit
                }),
                o = void 0;
            if (s) {
                var u = this._selfCustomParamAbility.detectTargets(),
                    a = {
                        atkStatusAilments: this.get("atkStatusAilments"),
                        statusAilmentsOptions: this.get("statusAilmentsOptions")
                    };
                o = this._selfCustomParamAbility.getActionResultWithTargetsAndParams(u, a)
            }
            this.changeState("WAIT_ANIM");
            var f = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), o && e.helper.applyActionResult(o), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndPartyCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndPartyCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg2")
                },
                infoMap: {
                    duration: this.get("arg3")
                }
            }), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5"))
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = void 0,
                i = [];
            _.extend(this._attributes, this._atkParams), r = this.detectTargets();
            var s = this.helper.physicalAttack(r, {
                    skipStatusAilments: !0
                }),
                o = _.any(s.damageObjects, function(e) {
                    return e.canHit
                });
            i.push(s.damageObjects);
            if (o) {
                _.extend(this._attributes, this._healParams), r = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAliveActors(), function(e) {
                    return e.isColleague(n)
                }));
                var u = this._calc(r);
                i.push(u)
            }
            var a = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM");
            var f = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: a,
                options: {
                    skipDamageMotionCountMap: {
                        2: !0
                    }
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(a), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    atkStatusAilments: this.get("atkStatusAilments"),
                    statusAilmentsOptions: this.get("statusAilmentsOptions")
                });
                n.push(r)
            }, this), n
        }
    })
}), define("scenes/battle/action/MagicAttackAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg4")
                },
                infoMap: {
                    duration: this.get("arg5")
                }
            }), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.magicAttack(r, {
                    skipStatusAilments: !0
                }),
                s = this._selfCustomParamAbility.detectTargets(),
                o = {
                    atkStatusAilments: this.get("atkStatusAilments"),
                    statusAilmentsOptions: this.get("statusAilmentsOptions")
                },
                u = this._selfCustomParamAbility.getActionResultWithTargetsAndParams(s, o);
            this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e.helper.applyActionResult(u), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalCustomParamBidirectionallyAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalCustomParamBidirectionallyAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg1")
                },
                infoMap: {
                    duration: this.get("arg3")
                }
            }), this.set("selfStatusAilmentsOptions", {
                boost: {
                    rate: this.get("arg2")
                },
                infoMap: {
                    duration: this.get("arg3")
                }
            }), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5"))
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this._calc(this.detectTargets());
            this.changeState("WAIT_ANIM");
            var r = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(n), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = this,
                r = this.executer,
                i = [],
                s = !1;
            _.each(e, function(e) {
                var o = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.PHYSICAL_STATUS_AILMENTS,
                    executer: r,
                    target: e,
                    ability: n,
                    atkStatusAilments: n.get("atkStatusAilments"),
                    statusAilmentsOptions: n.get("statusAilmentsOptions"),
                    forceHit: n.get("forceHit")
                });
                o.canHit && (s = !0), i.push([o])
            });
            if (s) {
                var o = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.PHYSICAL_STATUS_AILMENTS,
                    executer: r,
                    target: _.first(t.util.Targeting.makeResult(r)),
                    ability: this,
                    atkStatusAilments: this.get("atkStatusAilments"),
                    statusAilmentsOptions: this.get("selfStatusAilmentsOptions"),
                    forceHit: !0
                });
                i.push([o])
            }
            return this.helper.makeAndSetActionResult(r, this, i)
        }
    })
}), define("scenes/battle/action/PhysicalInflictSaBidirectionallyAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalInflictSaBidirectionallyAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this.get("arg1"),
                n = {};
            n[t] = this.get("statusAilmentsFactor"), this.set("atkStatusAilments", n);
            var r = this.get("arg2"),
                i = {};
            i[r] = this.get("statusAilmentsFactor"), this.set("selfStatusAilments", i), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this._calc(this.detectTargets());
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(n), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = this,
                r = this.executer,
                i = [],
                s = !1;
            _.each(e, function(e) {
                var o = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.PHYSICAL_STATUS_AILMENTS,
                    executer: r,
                    target: e,
                    ability: n,
                    atkStatusAilments: n.get("atkStatusAilments"),
                    forceHit: n.get("forceHit")
                });
                o.canHit && (s = !0), i.push([o])
            });
            if (s) {
                var o = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.PHYSICAL_STATUS_AILMENTS,
                    executer: r,
                    target: _.first(t.util.Targeting.makeResult(r)),
                    ability: this,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceHit: !0
                });
                i.push([o])
            }
            return this.helper.makeAndSetActionResult(r, this, i)
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndInflictSaAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndInflictSaAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg5"));
            var t = {};
            t[this.get("arg6")] = this.get("arg7");
            var n = {
                atkStatusAilments: t,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg8")
                    },
                    infoMap: {
                        duration: this.get("arg9")
                    }
                }
            };
            this.set("customParamConfs", n)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = this.get("customParamConfs"),
                u = [];
            for (var a = 1; a <= r; a++) {
                if (!s || !i) i = this.detectTargets();
                var f = this.helper.physicalAttack(i);
                u.push(f.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(u);
            var l = this.helper.makeAndSetActionResult(n, this, u),
                c = [];
            _.each(i, function(r) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: n,
                    target: r,
                    ability: e,
                    atkStatusAilments: o.atkStatusAilments,
                    statusAilmentsOptions: o.statusAilmentsOptions
                });
                c.push(i)
            }), l.damageObjects.push(c), this.changeState("WAIT_ANIM");
            var h = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndHealSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.set("saHitRate", this.get("arg8")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o),
                l = [];
            _.each(_.flatten(o), function(e) {
                if (!e.canHit) return;
                var t = e.receiver;
                l.push(t)
            });
            var c = [];
            if (l.length > 0) {
                var h = t.util.Targeting.makeResult(l),
                    p = this.get("healStatusAilmentIds");
                _.each(h, function(r) {
                    var i = r.receiver,
                        s = _.intersection(p, i.statusAilments.getRefs()),
                        o = t.util.DamageCalculator.calculate({
                            type: t.Conf.CALC_TYPE.HEAL_SA,
                            executer: n,
                            target: r,
                            ability: e,
                            hitRate: s.length > 0 ? e.get("saHitRate") : 0,
                            statusAilmentsIds: s
                        });
                    c.push(o)
                })
            }
            this.changeState("WAIT_ANIM");
            var d = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                c && f.damageObjects.push(c), e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementMultiAndSelfSaAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementMultiAndSelfSaAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6"));
            var n = this.get("arg7"),
                r = {};
            r[n] = 100, this.set("selfStatusAilments", r);
            var i = this.get("arg8"),
                s = {};
            s[i] = 100, this.set("selfStatusAilmentsForCustomParam", s), this.set("selfStatusAilmentsOptionsForCustomParam", {
                boost: {
                    rate: this.get("arg9")
                },
                infoMap: {
                    duration: this.get("arg10")
                }
            }), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o),
                l = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: n,
                    target: _.first(t.util.Targeting.makeResult(n)),
                    ability: this,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceHit: !0
                });
            f.damageObjects.push([l]);
            var c = this._selfCustomParamAbility.detectTargets(),
                h = {
                    atkStatusAilments: this.get("selfStatusAilmentsForCustomParam"),
                    statusAilmentsOptions: this.get("selfStatusAilmentsOptionsForCustomParam")
                },
                p = this._selfCustomParamAbility.getActionResultWithTargetsAndParams(c, h);
            this.changeState("WAIT_ANIM");
            var d = {};
            d[r + 1] = !0;
            var v = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f,
                options: {
                    skipDamageMotionCountMap: d
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e.helper.applyActionResult(p), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/ReduceMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.ReduceMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("hitRate", this.get("arg2"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = void 0;
                e.receiver.isBuddy() && (r = t.util.PanelTargeting.search(e.receiver, {
                    receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                    remainNum: t.Conf.PANEL_TARGET_REMAIN_NUM.EXISTS
                }));
                var i = r ? this.get("hitRate") : 0,
                    s = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.ABILITY_PANEL,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        abilityPanel: r,
                        isDecrease: !0,
                        damageFactor: this.get("damageFactor"),
                        hitRate: i,
                        isRemainingBase: !0
                    });
                n.push(s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/IncreaseMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.IncreaseMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("hitRate", this.get("arg2")), this.set("remainNum", this.get("arg3")), this.set("usedNum", this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = void 0;
                e.receiver.isBuddy() && (r = t.util.PanelTargeting.search(e.receiver, {
                    receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                    remainNum: this.get("remainNum"),
                    usedNum: this.get("usedNum")
                }));
                var i = r ? this.get("hitRate") : 0,
                    s = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.ABILITY_PANEL,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        abilityPanel: r,
                        isDecrease: !1,
                        damageFactor: this.get("damageFactor"),
                        hitRate: i,
                        isRemainingBase: !1
                    });
                n.push(s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/SaPoisonAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.SaPoisonAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.isEffectOfStatusAilements = !0
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = n,
                i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.POISON,
                    executer: n,
                    receiver: n,
                    ability: this
                });
            this.changeState("WAIT_ANIM"), this._isDone = !0, this.helper.applyDamageObjects([i]), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DAMAGE,
                action: this,
                actionResult: this.helper.makeAndSetActionResult(n, this, [i])
            }).play()
        }
    })
}), define("scenes/battle/action/SaRegenAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.SaRegenAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.isEffectOfStatusAilements = !0
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = n,
                i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.REGEN,
                    executer: n,
                    receiver: n,
                    ability: this
                });
            this.changeState("WAIT_ANIM"), this._isDone = !0, this.helper.applyDamageObjects([i]);
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DAMAGE,
                action: this,
                actionResult: this.helper.makeAndSetActionResult(n, this, [i])
            }).play()
        }
    })
}), define("scenes/battle/action/SelfDestructAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.SelfDestructAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1") || 0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e.executer.statusAilments.set(t.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH, e.executer), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.SELF_DESTRUCTION,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/SelfDestructAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.SelfDestructAndDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1") || 0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                n = this.get("looking");
            n && e.set("looking", n), this.executer.statusAilments.set(t.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH, this.executer), this._isDone = !0
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.SELF_DESTRUCTION,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/FixedDamageAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FixedDamageAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedDamage", this.get("arg1") || 0), this.set("ignoreTargetCountDivision", !!this.get("arg2")), this.get("fixedDamage") || this.set("fixedDamage", this.get("optionalFixedDamage") || 0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = e.length,
                r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FIXED_DAMAGE,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    fixedDamage: this.get("fixedDamage"),
                    targetCount: n,
                    ignoreTargetCountDivision: this.get("ignoreTargetCountDivision")
                });
                r.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        }
    })
}), define("scenes/battle/action/FixedDamageMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FixedDamageMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedDamage", this.get("arg1") || 0), this.set("ignoreTargetCountDivision", !!this.get("arg2")), this.set("barrageNum", this.get("arg3")), this.set("isSameTarget", !!this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this._calc(i);
                o.push(a)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = e.length,
                r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FIXED_DAMAGE,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    fixedDamage: this.get("fixedDamage"),
                    targetCount: n,
                    ignoreTargetCountDivision: this.get("ignoreTargetCountDivision")
                });
                r.push(i)
            }, this), r
        }
    })
}), define("scenes/battle/action/FixedDamageAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FixedDamageAndDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedDamage", this.get("arg1") || 0), this.set("ignoreTargetCountDivision", !!this.get("arg2")), this.get("fixedDamage") || this.set("fixedDamage", this.get("optionalFixedDamage") || 0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        _calc: function(e) {
            var n = e.length,
                r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FIXED_DAMAGE,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    fixedDamage: this.get("fixedDamage"),
                    targetCount: n,
                    ignoreTargetCountDivision: this.get("ignoreTargetCountDivision")
                });
                r.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/LvInflictSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.LvInflictSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            if (this.executer.isBuddy()) throw new Error("not allowed buddy executing");
            this.set("baseLevel", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.helper.lotStatusAilmentsByLevel(this.detectTargets(), this.get("baseLevel"));
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg4")
                },
                infoMap: {
                    duration: this.get("arg5")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/FixedHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FixedHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedHp", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = Math.max(0, e.receiver.get("hp") - this.get("fixedHp")),
                    i = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.FIXED_DAMAGE,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        fixedDamage: r,
                        targetCount: 1
                    });
                n.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    }), FF.ns.battle.action.FixedHpAction
}), define("scenes/battle/action/FixedHpAndDeformAction", ["./FixedHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FixedHpAndDeformAction = e.extend({
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/MagicAttackAndHealDeathAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndHealDeathAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var n = {
                exerciseType: this.get("exerciseType"),
                hitRate: 100,
                hpFactor: this.get("arg4")
            };
            this._raiseAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.HEAL_DEATH, this.executer, n), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer;
            this._raiseAbility.set("activeTarget", this.get("activeTarget"));
            var r = this._raiseAbility.detectTargets(),
                i = this._raiseAbility.getActionResultWithTargets(r),
                s = this.detectTargets(),
                o = this.helper.magicAttack(s),
                u = o.damageObjects,
                a = [].concat(u);
            _.each(i.damageObjects, function(e, n) {
                if (!e.canHit) return;
                var r = t.util.DamageCalculator.makeDamageObject(this.executer, this.executer, this, {
                    canHit: !0,
                    isNotShownHitMotion: !0,
                    isNotShownDamageMotion: !0
                });
                r.absorber = e.receiver, r.absorbHp = e, a.push(r)
            }, this), o.damageObjects = a, this.helper.showMessage(), this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                o.damageObjects = u, e.helper.applyActionResult(o), e._raiseAbility.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackWithHealSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackWithHealSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("hitRate", this.get("arg3")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.get("hitRate"),
                s = this.get("statusAilmentsId"),
                o = this.helper.physicalAttack(r, {
                    skipStatusAilments: !0
                }),
                u = [];
            _.each(o.damageObjects, function(r) {
                if (r.canHit) {
                    var o = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.HEAL_SA,
                        executer: n,
                        target: r,
                        ability: e,
                        hitRate: i,
                        statusAilmentsIds: [s]
                    });
                    u.push(o)
                }
            }), this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                _.each(u, function(e) {
                    o.damageObjects.push(e)
                }), e.helper.applyActionResult(o), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = this.executer.container ? this.executer.container : this.executer,
                c = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_BARRAGE,
                    action: this,
                    actionResult: f,
                    enemyContainer: l,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResultForBarrage(f), e._isDone = !0
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndDeformAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3")), this.set("atkElement", this.get("arg4")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    shouldDeformAllNodes: !!this.get("shouldDeformAllNodes"),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/ShowAbilityEffectAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.ShowAbilityEffectAction = e.extend({
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.makeDamageObject(this.executer, e.receiver, this, {
                    canHit: !0,
                    isCritical: !1
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/PhysicalDamagedHpAttackAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalDamagedHpAttackAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.DAMAGED_HP,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndSelfSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndSelfSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3"));
            var t = this.get("arg4"),
                n = {};
            n[t] = 100, this.set("selfStatusAilments", n)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = [],
                s = this.helper.physicalAttack(r);
            i.push(s.damageObjects);
            var o = _.any(s.damageObjects, function(e) {
                return e.canHit
            });
            if (o) {
                var u = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: n,
                    target: _.first(t.util.Targeting.makeResult(n)),
                    ability: this,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceHit: !0
                });
                i.push([u])
            }
            var a = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM");
            var f = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: a,
                options: {
                    skipDamageMotionCountMap: {
                        2: !0
                    }
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(a), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndColleagueSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndColleagueSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.set("hasColleagueSaAnimation", !!this.get("arg9"));
            var n = {};
            _.each(this.get("atkStatusAilmentIds"), function(e) {
                if (!e) return;
                n[e] = 100
            }), this.set("additionalAtkStatusAilments", n), this._inflictSaAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                targetRange: t.Conf.TARGET_RANGE.ALL,
                targetSegment: t.Conf.TARGET_SEGMENT.COLLEAGUE
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            this.helper.showMessage();
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this._inflictSaAbility.detectTargets(),
                l = this._inflictSaAbility.getActionResultWithTargetsAndParams(f, {
                    atkStatusAilments: this.get("additionalAtkStatusAilments")
                }),
                c = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var h = {};
            this.get("hasColleagueSaAnimation") && (c.damageObjects.push(l.damageObjects), h[r + 1] = !0);
            var p = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: c,
                options: {
                    skipDamageMotionCountMap: h
                }
            }).addCallbackOnce("end", function() {
                e.get("hasColleagueSaAnimation") || c.damageObjects.push(l.damageObjects), e.helper.applyActionResultForBarrage(c), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndSelfSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndSelfSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.set("selfSaId", this.get("arg7")), this.set("forceHitSelfSa", this.get("arg8")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = this.get("forceHitSelfSa"),
                u = [],
                a;
            for (var f = 1; f <= r; f++) {
                if (!s || !i) i = this.detectTargets();
                var l = this.helper.physicalAttack(i);
                a || (a = _.any(l.damageObjects, function(e) {
                    return e.canHit
                })), u.push(l.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(u);
            var c = this.helper.makeAndSetActionResult(n, this, u),
                h = void 0;
            if (a || o) h = e._calcSelfSa();
            this.changeState("WAIT_ANIM");
            var p = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: c
            }).addCallbackOnce("end", function() {
                h && c.damageObjects.push([h]), e.helper.applyActionResultForBarrage(c), e._isDone = !0
            }).play()
        },
        _calcSelfSa: function() {
            var e = this,
                n = {};
            n[this.get("selfSaId")] = 1;
            var r = t.util.DamageCalculator.calculate({
                type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                executer: e.executer,
                target: _.first(t.util.Targeting.makeResult(e.executer)),
                ability: e,
                atkStatusAilments: n,
                forceHit: !0
            });
            return r
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg7")
                },
                infoMap: {
                    duration: this.get("arg8")
                }
            }), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndCustomParamAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndCustomParamAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("atkElement", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg6")
                },
                infoMap: {
                    duration: this.get("arg9")
                }
            });
            var n = this.get("arg7"),
                r = {};
            r[n] = 100, this.set("selfStatusAilments", r), this.set("selfStatusAilmentsOptions", {
                boost: {
                    rate: this.get("arg8")
                },
                infoMap: {
                    duration: this.get("arg9")
                }
            }), this.set("forceHit", !0), this.set("dependsWeaponEffect", !0), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [],
                u;
            for (var a = 1; a <= r; a++) {
                if (!s || !i) i = this.detectTargets();
                var f = this.helper.physicalAttack(i);
                u || (u = _.any(f.damageObjects, function(e) {
                    return e.canHit
                })), o.push(f.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var l = this.helper.makeAndSetActionResult(n, this, o),
                c = void 0;
            if (u) {
                var h = this._selfCustomParamAbility.detectTargets(),
                    p = {
                        atkStatusAilments: this.get("selfStatusAilments"),
                        statusAilmentsOptions: this.get("selfStatusAilmentsOptions")
                    };
                c = this._selfCustomParamAbility.getActionResultWithTargetsAndParams(h, p)
            }
            this.changeState("WAIT_ANIM");
            var d = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(l), c && e.helper.applyActionResult(c), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndSelfAttachElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = 25e3;
    FF.ns.battle.action.PhysicalAttackMultiAndSelfAttachElementAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("atkElement", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("forceHit", !0), this.set("dependsWeaponEffect", !0);
            var n = 100,
                r = {};
            r[this.get("arg6")] = n, this.set("attachElementAtkStatusAilments", r), this.set("attachElementStatusAilmentsOptions", {
                infoMap: {
                    swapAbilityId: this.get("arg7"),
                    normalAbilityDamageFactor: this.get("arg8"),
                    soulStrikeDamageFactor: this.get("arg9"),
                    defenseFactor: this.get("arg10")
                }
            }), this._selfAttachElementAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o),
                l = {
                    atkStatusAilments: this.get("attachElementAtkStatusAilments"),
                    statusAilmentsOptions: this.get("attachElementStatusAilmentsOptions")
                },
                c = this._selfAttachElementAbility.getActionResultWithTargetsAndParams(t.util.Targeting.makeResult(n), l);
            this.set("actionResult", f), this.changeState("WAIT_ANIM");
            var h = {};
            h[r + 1] = !0;
            var p = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f,
                options: {
                    skipDamageMotionCountMap: h
                }
            }).addCallbackOnce("end", function() {
                o.push(c.damageObjects), e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/InflictSaAndCustomProbabilityDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.InflictSaAndCustomProbabilityDeformAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments);
            var n = {};
            _.each([
                [1, 2],
                [3, 4],
                [5, 6],
                [7, 8],
                [9, 10]
            ], function(e) {
                var r = t.get(sprintf("arg%d", e[0]));
                r && (n[r] = t.get(sprintf("arg%d", e[1])))
            }), t.set("atkStatusAilments", n)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this.helper.lotStatusAilments(n),
                i = this.executer.container ? this.executer.container : this.executer;
            this.get("checkCanExecAbilityFlag") && !n.length ? this.changeState("INVALIDITY") : (this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                action: this,
                actionResult: r,
                enemyContainer: i,
                animationInfo: this.helper.detectDeformAnimationInfo(),
                options: {
                    skipDamageMotion: !0,
                    usesMainNode: !!this.get("usesMainNode")
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play())
        }
    })
}), define("scenes/battle/action/ShowAbilityEffectDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.ShowAbilityEffectDeformAction = e.extend({
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this._calc(n),
                i = this.executer.container ? this.executer.container : this.executer;
            this.get("checkCanExecAbilityFlag") && !n.length ? this.changeState("INVALIDITY") : (this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                action: this,
                actionResult: r,
                enemyContainer: i,
                animationInfo: this.helper.detectDeformAnimationInfo(),
                options: {
                    skipDamageMotion: !0,
                    usesMainNode: !!this.get("usesMainNode")
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play())
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.makeDamageObject(this.executer, e.receiver, this, {
                    canHit: !0,
                    isCritical: !1
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndHealHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndHealHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this._atkParams = {
                damageFactor: this.get("arg1"),
                atkType: this.get("arg2"),
                forceHit: !!this.get("arg3"),
                atkElement: this.get("arg4")
            }, this.set("dependsWeaponEffect", !0), this._healParams = {
                factor: this.get("arg5"),
                matkElement: this.get("arg6")
            }
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = void 0,
                i = [];
            _.extend(this._attributes, this._atkParams), r = this.detectTargets();
            var s = this.helper.physicalAttack(r);
            i.push(s.damageObjects), _.extend(this._attributes, this._healParams), r = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAliveActors(), function(e) {
                return e.isColleague(n)
            }));
            var o = this._calc(r);
            i.push(o);
            var u = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: u
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(u), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), n
        }
    })
}), define("scenes/battle/action/CustomParamMultiAndInflictSaMultiAction", ["./ActionBase", "sprintf"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.CustomParamMultiAndInflictSaMultiAction = e.extend({
        initialize: function() {
            var n = this;
            e.prototype.initialize.apply(this, arguments);
            var r = this.get("statusAilmentsFactor"),
                i = this.get("atkStatusAilmentIds"),
                s = {};
            _.each(i, function(e) {
                s[e] = r
            }, this), this.set("atkStatusAilments", s);
            var o = [],
                u = this.get("arg1");
            _.each([2, 4, 6], function(e) {
                var r = n.get(t("arg%d", e));
                if (r) {
                    var i = 100,
                        s = {};
                    s[r] = i, o.push({
                        atkSa: s,
                        statusAilmentsOptions: {
                            boost: {
                                rate: n.get(t("arg%d", e + 1))
                            },
                            infoMap: {
                                duration: u
                            }
                        }
                    })
                }
            }), this.set("customParamConfs", o)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var t = this.helper.lotStatusAilments(this.detectTargets()),
                r = [];
            _.each(t.damageObjects, function(t) {
                t.canHit && _.each(e.get("customParamConfs"), function(i) {
                    var s = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: t,
                        ability: e,
                        atkStatusAilments: i.atkSa,
                        statusAilmentsOptions: i.statusAilmentsOptions,
                        forceHit: !0
                    });
                    r.push(s)
                })
            }), this.changeState("WAIT_ANIM");
            var i = n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: t,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                _.each(r, function(e) {
                    t.damageObjects.push(e)
                }), e.helper.applyActionResult(t), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/WrappedAbilityActionBase", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    return FF.ns.battle.action.WrappedAbilityActionBase = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("wrappedAbilityId", 0), this.set("continuousStatusAilment", 0), this.set("continuousStatusAilmentInfo", {}), this.set("wrappedAbility", null)
        },
        update: function() {
            t.prototype.update.apply(this, arguments);
            var e = this.get("wrappedAbility");
            e && e.update()
        },
        processForStateInitUpdate: function() {
            var e = this.executer,
                t = this.get("wrappedAbilityId"),
                r = n.AbilityFactory.create(t, e, {});
            _.each(["activeTarget", "isAbilityPanel", "isSoulStrike", "receptorId"], function(e) {
                this.has(e) && r.set(e, this.get(e))
            }, this), this.set("wrappedAbility", r), this.changeState("WAIT_ANIM")
        },
        processForStateWaitAnimEntry: function() {
            var e = this.get("wrappedAbility");
            if (!e) return;
            e.begin()
        },
        processForStateWaitAnimUpdate: function() {
            var e = this.executer,
                t = this.get("wrappedAbility");
            if (!t) return;
            if (t.isDone()) {
                this._isDone = !0;
                var r = this.get("continuousStatusAilment"),
                    i = this.get("continuousStatusAilmentOptions");
                if (r) {
                    var s = n.util.DamageCalculator.makeDamageObject(e, e, this, {
                        statusAilments: [r],
                        statusAilmentsOptions: i
                    });
                    e.applyDamageObject(s)
                }
            }
        }
    }), FF.ns.battle.action.WrappedAbilityActionBase
}), define("scenes/battle/action/RageAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.RageAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            var e = this.get("arg1"),
                r = this.get("arg2"),
                i = this.get("arg3"),
                s = [];
            for (var o = 1; o < e; o++) s.push(i);
            this.set("wrappedAbilityId", r), this.set("continuousStatusAilment", n.Conf.STATUS_AILMENTS_TYPE.RAGE), this.set("continuousStatusAilmentOptions", {
                abilityIds: s
            })
        }
    })
}), define("scenes/battle/action/TranceAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.TranceAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            var e = this.get("arg1");
            this.set("wrappedAbilityId", e);
            var n = this.get("arg7"),
                r = this.get("arg8");
            this.set("continuousStatusAilment", this.get("statusAilmentsId")), this.set("continuousStatusAilmentOptions", {
                spareReceptorIds: [this.get("arg3"), this.get("arg5")],
                infoMap: {
                    duration: this.get("arg6")
                },
                boosts: [{
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: r
                }]
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementAndInflictSaAndSelfSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    FF.ns.battle.action.PhysicalAttackAndInflictSaAndSelfSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("targetRange", n.TARGET_RANGE.SINGLE), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3")), this.set("atkElement", this.get("arg4"));
            var t = this.get("arg5"),
                r = {};
            r[t] = this.get("arg6"), this.set("opponentStatusAilments", r);
            var i = this.get("arg7"),
                s = {};
            s[i] = 1, this.set("selfStatusAilments", s)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this._calc(_.first(n));
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: r,
                options: {
                    skipDamageMotionCountMap: {
                        2: !0,
                        3: !0
                    }
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = this,
                r = this.executer,
                i = [],
                s = this.helper.physicalAttack([e]);
            i.push(s.damageObjects);
            var o = _.first(s.damageObjects).canHit,
                u = !1;
            if (o) {
                var a = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: r,
                    target: e,
                    ability: this,
                    atkStatusAilments: this.get("opponentStatusAilments")
                });
                i.push([a]), a.canHit && (u = !0)
            }
            if (u) {
                var f = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: r,
                    target: _.first(t.util.Targeting.makeResult(r)),
                    ability: this,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceHit: !0
                });
                i.push([f])
            }
            return this.helper.makeAndSetActionResult(r, this, i)
        }
    })
}), define("scenes/battle/action/AttachElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.AttachElementAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments);
            var n = this.get("atkStatusAilmentIds"),
                r = this.get("statusAilmentsFactor"),
                i = {};
            _.each(n, function(e) {
                i[e] = r
            }, this), this.set("atkStatusAilments", i), this.set("statusAilmentsOptions", {
                infoMap: {
                    swapAbilityId: this.get("arg2"),
                    normalAbilityDamageFactor: this.get("arg3"),
                    soulStrikeDamageFactor: this.get("arg4"),
                    defenseFactor: this.get("arg5"),
                    duration: this.get("arg6")
                }
            });
            var s = [];
            _.each([7, 8], function(e) {
                var n = t.get(sprintf("arg%d", e));
                if (n) {
                    var i = {};
                    i[n] = r, s.push({
                        atkSa: i,
                        statusAilmentsOptions: {}
                    })
                }
            }), this.set("optionalStatusAilmentsConfs", s);
            var o = [],
                u = this.get("statusAilmentsId");
            if (u) {
                var a = {};
                a[u] = r, o.push({
                    atkSa: a,
                    statusAilmentsOptions: {
                        boost: {
                            rate: this.get("arg9")
                        },
                        infoMap: {
                            duration: this.get("arg10")
                        }
                    }
                })
            }
            this.set("customParamConfs", o), this.set("forceHit", !0)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.helper.lotStatusAilments(this.detectTargets()),
                r = [];
            _.each(n.damageObjects, function(n) {
                _.each(e.get("optionalStatusAilmentsConfs"), function(i) {
                    var s = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: n,
                        ability: e,
                        atkStatusAilments: i.atkSa,
                        statusAilmentsOptions: i.statusAilmentsOptions,
                        forceHit: !0
                    });
                    r.push(s)
                })
            });
            var i = [];
            _.each(n.damageObjects, function(n) {
                _.each(e.get("customParamConfs"), function(r) {
                    var s = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: n,
                        ability: e,
                        atkStatusAilments: r.atkSa,
                        statusAilmentsOptions: r.statusAilmentsOptions,
                        forceHit: !0
                    });
                    i.push(s)
                })
            }), this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                _.each(r, function(e) {
                    n.damageObjects.push(e)
                }), _.each(i, function(e) {
                    n.damageObjects.push(e)
                }), e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/CustomParamMultiAction", ["./ActionBase", "sprintf"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.CustomParamMultiAction = e.extend({
        initialize: function() {
            var n = this;
            e.prototype.initialize.apply(this, arguments);
            var r = [],
                i = {},
                s = this.get("arg1"),
                o = this.get("arg2");
            this.set("forceHit", !!this.get("arg3")), _.each([4, 6, 8], function(e) {
                var u = n.get(t("arg%d", e));
                if (!u) return;
                if (i[u]) throw new Error("duplicate entry status_ailment_id." + u);
                i[u] = 1;
                var a = {};
                a[u] = o, r.push({
                    atkSa: a,
                    statusAilmentsOptions: {
                        boost: {
                            rate: n.get(t("arg%d", e + 1))
                        },
                        infoMap: {
                            duration: s
                        }
                    }
                })
            }), this.set("customParamConfs", r)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var t = this.detectTargets(),
                r = [];
            _.each(t, function(t) {
                _.each(e.get("customParamConfs"), function(i) {
                    var s = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: t,
                        ability: e,
                        atkStatusAilments: i.atkSa,
                        statusAilmentsOptions: i.statusAilmentsOptions,
                        forceHit: e.get("forceHit")
                    });
                    r.push(s)
                })
            });
            var i = this.helper.makeAndSetActionResult(this.executer, this, r);
            this.changeState("WAIT_ANIM");
            var s = n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementMultiAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementMultiAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6"));
            var n = this.get("arg7"),
                r = {};
            r[n] = this.get("arg8"), this.set("selfStatusAilments", r), this.set("selfStatusAilmentsOptions", {
                boost: {
                    rate: this.get("arg9")
                },
                infoMap: {
                    duration: this.get("arg10")
                }
            }), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [],
                u;
            for (var a = 1; a <= r; a++) {
                if (!s || !i) i = this.detectTargets();
                var f = this.helper.physicalAttack(i);
                u || (u = _.any(f.damageObjects, function(e) {
                    return e.canHit
                })), o.push(f.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var l = this.helper.makeAndSetActionResult(n, this, o),
                c = void 0;
            if (u) {
                var h = this._selfCustomParamAbility.detectTargets(),
                    p = {
                        atkStatusAilments: this.get("selfStatusAilments"),
                        statusAilmentsOptions: this.get("selfStatusAilmentsOptions")
                    };
                c = this._selfCustomParamAbility.getActionResultWithTargetsAndParams(h, p)
            }
            this.changeState("WAIT_ANIM");
            var d = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(l), c && e.helper.applyActionResult(c), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementMultiAndPartyCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementMultiAndPartyCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6"));
            var t = this.get("arg7"),
                n = {};
            n[t] = 1, this.set("partyStatusAilments", n), this.set("partyStatusAilmentsOptions", {
                boost: {
                    rate: this.get("arg8")
                },
                infoMap: {
                    duration: this.get("arg9")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this._calcCustomParam();
            o.push(f);
            var l = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var c = {};
            c[r + 1] = !0;
            var h = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l,
                options: {
                    skipDamageMotionCountMap: c
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        },
        _calcCustomParam: function() {
            var e = this,
                n = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAliveActors(), function(t) {
                    return t.isColleague(e.executer)
                })),
                r = [];
            return _.each(n, function(e) {
                var n = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    atkStatusAilments: this.get("partyStatusAilments"),
                    statusAilmentsOptions: this.get("partyStatusAilmentsOptions"),
                    forceHit: !0
                });
                r.push(n)
            }, this), r
        }
    })
}), define("scenes/battle/action/PhysicalAttackWithMultiHealSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackWithMultiHealSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("hitRate", this.get("arg3")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.get("hitRate"),
                s = this.get("healStatusAilmentIds"),
                o = this.helper.physicalAttack(r, {
                    skipStatusAilments: !0
                }),
                u = [];
            _.each(o.damageObjects, function(r) {
                if (r.canHit) {
                    var o = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.HEAL_SA,
                        executer: n,
                        target: r,
                        ability: e,
                        hitRate: i,
                        statusAilmentsIds: s
                    });
                    u.push(o)
                }
            }), this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                _.each(u, function(e) {
                    o.damageObjects.push(e)
                }), e.helper.applyActionResult(o), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/ChangeCastTimeAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.ChangeCastTimeAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("statusAilmentsOptions", {
                infoMap: {
                    castTimeFactor: this.get("arg1"),
                    validAbilityUseCount: this.get("arg2"),
                    abilityCategoryId: this.get("arg3")
                }
            }), this.set("forceHit", !0)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.helper.lotStatusAilments(this.detectTargets());
            this.changeState("WAIT_ANIM");
            var r = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealHpAndHealDeathAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.HealHpAndHealDeathAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3")), this.set("hpFactor", this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets();
            this.helper.showMessage();
            var r = this._calc(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                if (e.receiver.isDead()) return;
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), _.each(e, function(e) {
                if (e.receiver.isAlive()) return;
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL_DEATH,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: 100,
                    hpFactor: this.get("hpFactor")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    }), FF.ns.battle.action.HealHpAndHealDeathAction
}), define("scenes/battle/action/MagicAttackMultiAndSelfSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndSelfSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("matkElement", this.get("arg3")), this.set("isSameTarget", !!this.get("arg4")), this.set("selfSaId", this.get("arg5"));
            var t = {
                    infoMap: {}
                },
                n = this.get("arg6") || 0;
            n > 0 && (t.infoMap.duration = n), this.set("selfSaOptions", t)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.magicAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), n.statusAilments.set(e.get("selfSaId"), n, e.get("selfSaOptions")), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndInflictSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndInflictSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3"));
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this), this.set("atkStatusAilments", r)
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.detectTargets(),
                r = this.helper.magicAttack(n);
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndAbsorbHpAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndAbsorbHpAndDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("absorbHpFactor", this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/HealSaMultiAndDeformAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.HealSaMultiAndDeformAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = n.BattleViewController.getInstance().createAnimation({
                    animationType: n.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode"),
                        skipDamageMotion: !0
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        },
        _calc: function(e) {
            var t = [],
                r = this.get("healStatusAilmentIds");
            return _.each(e, function(e) {
                var i = e.receiver,
                    s = _.intersection(r, i.statusAilments.getRefs()),
                    o = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.HEAL_SA,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        hitRate: s.length > 0 ? 100 : 0,
                        statusAilmentsIds: s
                    });
                t.push(o), FF.logger.info("HEAL_SA_MULTI_AND_DEFORM", "ids", s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, t)
        }
    })
}), define("scenes/battle/action/HealHpAndIncreaseMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndIncreaseMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3")), this.set("increaseMpDamageFactor", this.get("arg5")), this.set("increaseMpHitRate", this.get("arg6")), this.set("remainNum", this.get("arg7")), this.set("usedNum", this.get("arg8")), this._increaseMpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.INCREASE_MP, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = {},
                r = this.executer;
            this.helper.showMessage();
            var i = [],
                s = this.detectTargets(),
                o = this._calcHealHp(s),
                u = [],
                a = [];
            _.each(o.damageObjects, function(e) {
                var t = e.receiver;
                e.canHit ? u.push(t) : a.push(t)
            });
            var f = u.length ? t.util.Targeting.makeResult(u) : void 0,
                l = this._calcIncreaseMp(f),
                c = a.length ? t.util.Targeting.makeResult(a) : void 0,
                h = this._calcIncreaseMp(c, {
                    hitRate: 0
                });
            i.push(o.damageObjects), i.push([].concat(l.damageObjects, h.damageObjects));
            var p = this.helper.makeAndSetActionResult(r, this, i);
            this.changeState("WAIT_ANIM");
            var d = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: p
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(p), e._isDone = !0
            }).play()
        },
        _calcHealHp: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        },
        _calcIncreaseMp: function(e, t) {
            var n = {
                damageFactor: this.get("increaseMpDamageFactor"),
                hitRate: this.get("increaseMpHitRate"),
                remainNum: this.get("remainNum"),
                usedNum: this.get("usedNum")
            };
            return _.extend(n, t), this._increaseMpAbility.getActionResultWithTargetsAndParams(e, n)
        }
    })
}), define("scenes/battle/action/PhysicalAttackDependedOnSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.PhysicalAttackDependedOnSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactorForMismatchedSa", this.get("arg1")), this.set("damageFactorForMatchedSa", this.get("arg2")), this.set("atkType", this.get("arg3"));
            var t = [];
            this.get("arg4") && t.push(this.get("arg4")), this.get("arg5") && t.push(this.get("arg5")), this.get("arg6") && t.push(this.get("arg6")), this.set("targetSaIdsByAttackDependedOnSa", t), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets();
            this.helper.showMessage();
            var i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    }), FF.ns.battle.action.PhysicalAttackDependedOnSaAction
}), define("scenes/battle/ai/AiUtil", [], function() {
    var e = FF.ns.battle;
    FF.ns.battle.ai.AiUtil = {
        getContainer: function(e) {
            return e.isContainer() ? e : e.container
        },
        getActors: function(e, t) {
            var n = [];
            if (t) {
                var r = this.getContainer(e);
                _.each(t, function(e) {
                    n.push(r.getChild(e))
                })
            } else {
                if (!!e.isContainer()) throw new Error("actor is not specified");
                n.push(e)
            }
            return n
        },
        getActor: function(e, t) {
            if (t) {
                var n = this.getContainer(e);
                return n.getChild(t)
            }
            if (!e.isContainer()) return e;
            throw new Error("actor is not specified")
        },
        getEventNameOfApplyDamageObject: function(e) {
            var t = void 0;
            switch (e) {
                case "SET_SA":
                    t = "ActorBase::addStatusAilments";
                    break;
                case "UNSET_SA":
                    t = "ActorBase::unsetStatusAilments";
                    break;
                case "ANY":
                    t = "ActorBase::applyDamageObject";
                    break;
                default:
                    t = "ActorBase::addDamage"
            }
            return t
        },
        checkConditionForDamageObject: function(t, n, r) {
            var i = r.ability;
            if (t.counter && !e.util.DamageCalculator.isEnableCounter(r)) return !1;
            var s = !0;
            t.elements && (_.any(t.elements, function(e) {
                return e === r.element
            }) || (s = !1)), t.exercises && (_.any(t.exercises, function(e) {
                return e === i.get("exerciseType")
            }) || (s = !1));
            if (t.damagedOnly)
                if (t.ignorePoison === !0 && r.type === e.Conf.CALC_TYPE.POISON) s = !1;
                else if (_.isNumber(r.damage)) {
                var o = t.damagedOnlyOptions || {},
                    u = !1;
                _.isNumber(o.under) ? u = r.damage < o.under : _.isNumber(o.underOrEqual) ? u = r.damage <= o.underOrEqual : _.isNumber(o.over) ? u = r.damage > o.over : _.isNumber(o.overOrEqual) ? u = r.damage >= o.overOrEqual : u = r.damage > 0, u || (s = !1)
            } else s = !1;
            return s
        }
    }
}), define("scenes/battle/action/PhysicalAttackElementMultiAndSelfCustomParamWithEffectAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementMultiAndSelfCustomParamWithEffectAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6"));
            var t = this.get("arg7"),
                n = {};
            n[t] = this.get("arg8"), this.set("selfStatusAilments", n), this.set("selfStatusAilmentsOptions", {
                boost: {
                    rate: this.get("arg9")
                },
                infoMap: {
                    duration: this.get("arg10")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.helper.showMessage();
            var n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [],
                u;
            for (var a = 1; a <= r; a++) {
                if (!s || !i) i = this.detectTargets();
                var f = this.helper.physicalAttack(i);
                u || (u = _.any(f.damageObjects, function(e) {
                    return e.canHit
                })), o.push(f.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var l = [];
            if (u) {
                var c = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: n,
                    target: _.first(t.util.Targeting.makeResult(n)),
                    ability: this,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    statusAilmentsOptions: this.get("selfStatusAilmentsOptions"),
                    forceHit: !0
                });
                l.push(c)
            }
            o.push(l);
            var h = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var p = {};
            p[r + 1] = !0;
            var d = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: h,
                options: {
                    skipDamageMotionCountMap: p
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(h), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/fsm/State", ["lib/EventBase"], function(e) {
    var t = {};
    return FF.ns.battle.fsm.State = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments), this.transitions = [], this._stateId = t.id, this._memberValues = t.memberValues || {}
        },
        getMemberValues: function() {
            return this._memberValues
        },
        getStateId: function() {
            return this._stateId
        },
        inState: function() {},
        outState: function() {},
        update: function(e) {},
        updateTransition: function() {
            var e = null,
                t = this;
            _.any(this.transitions, function(n) {
                return n.update(), n.canTransition(t) ? (e = n, !0) : !1
            });
            if (e) return _.each(this.transitions, function(e) {
                e.reset()
            }), this.triggerTx = e, e.getNextStateId()
        },
        preUpdate: function(e) {},
        postUpdate: function(e) {},
        isInCurrentState: function() {
            return this.parent.isCurrentState(this.getStateId())
        }
    }, {
        registerBuiltinFunction: function(e, n) {
            t[e] = n
        },
        getBuiltinFunction: function(e) {
            return t[e]
        }
    }), FF.ns.battle.fsm.State
}), define("scenes/battle/ai/State", ["util", "../fsm/State"], function(e, t) {
    var n = FF.ns.battle,
        r = function(e, t, r) {
            _.isArray(r) || (r = [r]), e.parent.globalRegister.lastVisibleNo = _.last(r);
            var i = {};
            _.each(r, function(e) {
                i[e] = !0
            }), _.each(t.getNos(), function(e) {
                var r = t.getChild(e),
                    s = n.Conf.STATUS_AILMENTS_TYPE.DISABLE,
                    o = r.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.DISABLE);
                if (i[e]) o && r.statusAilments.unset(s);
                else if (!o) {
                    var u = n.util.DamageCalculator.makeDamageObject(r, r, void 0, {
                        statusAilments: [s]
                    });
                    r.applyDamageObject(u)
                }
            })
        },
        i = {
            OVERRIDE_ACTOR_PARAM: function(e) {
                _.each(this._memberValues.overrideActorParam, function(e, t) {
                    this._executer.set(t, e)
                }, this), e()
            },
            RECOVER: function(t) {
                var n = e.option({
                        recoverNo: void 0,
                        rate: void 0
                    }, this._memberValues.recover),
                    r = this._executer.isContainer() ? this._executer : this._executer.container;
                _.each(n.recoverNo, function(e) {
                    var t = r.getChild(e),
                        i = t.get("maxHp");
                    n.rate > 0 && (i = Math.ceil(i * (n.rate / 100))), t.set("hp", i), t.rise()
                }), t()
            },
            RECOVER_ENABLE: function(t) {
                var n = e.option({
                        visibleNo: void 0
                    }, this._memberValues.visible),
                    r = this._executer.isContainer() ? this._executer : this._executer.container;
                _.each(n.visibleNo, function(e) {
                    var t = r.getChild(e);
                    t.set("hp", t.get("maxHp")), t.rise()
                }), t()
            },
            SET_SA: function(e) {
                var t = [];
                this._executer.container ? t.push(this._executer) : _.each(this._memberValues.saChildNos, function(e) {
                    t.push(this._executer.getChild(e))
                }, this);
                var n = this._memberValues.sa;
                _.each(t, function(e) {
                    e.setStatusAilments(n)
                }), e()
            },
            UNSET_SA: function(e) {
                var t = [];
                this._executer.container ? t.push(this._executer) : _.each(this._memberValues.saChildNos, function(e) {
                    t.push(this._executer.getChild(e))
                }, this);
                var n = this._memberValues.sa;
                n = _.isArray(n) ? n : [n], _.each(t, function(e) {
                    _.each(n, function(t) {
                        e.statusAilments.unset(t)
                    })
                }), e()
            },
            UNSET_ALL_SA: function(e) {
                var t = [];
                if (this._executer.isContainer()) _.each(this._memberValues.saChildNos, function(e) {
                    var n = this._executer.getChild(e);
                    t.push(n)
                }, this);
                else {
                    var n = this._executer;
                    t.push(n)
                }
                t = _.filter(t, function(e) {
                    return e.isAlive()
                }), _.each(t, function(e) {
                    var t = e.statusAilments.cloneIds();
                    _.each(t, function(t) {
                        e.statusAilments.unset(t)
                    })
                }), e()
            },
            RESET: function(e) {
                var t;
                this._executer.container ? t = [this._executer] : t = this._executer.getChildren(), _.each(t, function(e) {
                    e.isAlive() && e.reset()
                }), e()
            },
            SHUFFLE_ATB: function(t) {
                var n = e.option({
                        visibleNo: void 0
                    }, this._memberValues.visible),
                    r = this._executer.isContainer() ? this._executer : this._executer.container;
                _.each(n.visibleNo, function(t) {
                    var n = r.getChild(t),
                        i = e.randomInt(n.getAtbTime() - 1);
                    n.set("elapsedAtbTime", i)
                }), t()
            },
            CLEAR_TARGET: function(e) {
                var t = [],
                    r = this._executer,
                    i = n.ActorMgr.getActiveTarget();
                if (!i) {
                    e();
                    return
                }
                r.isContainer() ? _.each(this._memberValues.ctChildNos, function(e) {
                    var n = this._executer.getChild(e);
                    t.push(n)
                }, this) : t = [r], _.any(t, function(e) {
                    if (i.equals(e)) return n.ActorMgr.clearActiveTarget(), !0
                }), e()
            },
            RESET_CAST_ABILITY: function(e) {
                var t;
                this._executer.isContainer() ? t = this._executer.getChildren() : t = [this._executer], _.each(t, function(e) {
                    e.isAlive() && e.resetCastAbility()
                }), e()
            },
            CLEAR_TARGET: function(e) {
                var t = [],
                    r = this._executer,
                    i = n.ActorMgr.getActiveTarget();
                if (!i) {
                    e();
                    return
                }
                r.isContainer() ? _.each(this._memberValues.ctChildNos, function(e) {
                    var n = this._executer.getChild(e);
                    t.push(n)
                }, this) : t = [r], _.any(t, function(e) {
                    if (i.equals(e)) return n.ActorMgr.clearActiveTarget(), !0
                }), e()
            },
            ENABLE: function(t) {
                var n = e.option({
                        visibleNo: void 0
                    }, this._memberValues.visible),
                    i = this._executer;
                r(this, i, n.visibleNo), t()
            },
            ENABLE_AND_UPDATE_POS_ARRAY: function(t) {
                var i = e.option({
                        visibleNo: void 0
                    }, this._memberValues.visible),
                    s = this._executer;
                r(this, s, i.visibleNo), n.BattleViewController.getInstance().updateEnemyContainerPosArray(s.get("posId")), t()
            },
            CHANGE_PARAM: function(t) {
                var n = this._executer;
                this._memberValues.id && (n = n.getChild(this._memberValues.id));
                var r = this._memberValues.paramId,
                    i = this._memberValues.lotParam;
                if (i && r === void 0) {
                    var s = this._executer.get("paramId"),
                        o;
                    i.allowCurrentParam ? o = i.paramIds : o = _.filter(i.paramIds, function(e) {
                        return e !== s
                    }), r = e.lot(o, function() {
                        return 1
                    })
                }
                n.changeBaseParam(r), t()
            },
            CHANGE_PARAM_MULTI: function(e) {
                var t = this._executer;
                if (this._memberValues.childParams === void 0) throw new Error("childParams is required");
                if (!t.isContainer()) throw new Error("exclusive use for god-ai");
                _.each(this._memberValues.childParams, function(e) {
                    var n = t.getChild(e.id);
                    n.changeBaseParam(e.paramId)
                }), e()
            },
            CHANGE_ABILITY_DEFORM_MAP: function(e) {
                var t = this._executer,
                    n = t.isContainer() ? t : t.container,
                    r = this._memberValues.abilityDeformMap,
                    i = n.get("abilityDeformMap") || {};
                i = _.extend(i, r), n.set("abilityDeformMap", i), e()
            },
            CHANGE_ABILITY_DEFORM_MAP_TAG: function(e) {
                var t = this._executer,
                    n = t.isContainer() ? t : t.container,
                    r = {};
                _.each(this._memberValues.abilityDeformMapTag, function(e, t) {
                    var i = n.getChild(t);
                    r[t] = {}, _.each(e, function(e, n) {
                        var s = i.getAbilityIdByTag(n);
                        r[t][s] = e
                    })
                });
                var i = n.get("abilityDeformMapTag") || {};
                i = _.extend(i, r), n.set("abilityDeformMapTag", i), e()
            },
            SET_DEAD_ANIMATE_TYPE: function(e) {
                var t = this._executer,
                    n = this._memberValues.deadAnimateType;
                if (_.isNumber(n)) {
                    if (t.isContainer()) throw new Error("in enemy container, argument type must be object.");
                    t.setDeadAnimateType(n)
                } else {
                    if (!_.isObject(n)) throw new Error("argument type must be number or object.");
                    var r = t.isContainer() ? t : t.container;
                    _.each(n, function(e, t) {
                        var n = r.getChild(t);
                        if (!n) throw new Error("undefined actorNo. NO:" + t);
                        n.setDeadAnimateType(e)
                    })
                }
                e()
            },
            CANCEL_INTERRUPT_ABILITY: function(e) {
                var t;
                this._executer.container ? t = [this._executer] : t = this._executer.getChildren(), _.each(t, function(e) {
                    e.cancelInterruptAbility()
                }), e()
            }
        };
    return FF.ns.battle.ai.State = t.extend({
        initialize: function(e, n) {
            t.prototype.initialize.apply(this, arguments), this._executer = n, this._internalNextStateId = void 0, this.conditionFlags = {}, this.resultObjectTmps = {}
        },
        preUpdate: function(e) {
            t.prototype.preUpdate.apply(this, arguments), this._internalNextStateId = void 0, _.each(this.conditionFlags, function(t) {
                t.preUpdate(e)
            })
        },
        postUpdate: function(e) {
            t.prototype.postUpdate.apply(this, arguments), _.each(this.resultObjectTmps, function(t) {
                t.postUpdate(e)
            })
        },
        setNextStateId: function(e) {
            this._internalNextStateId = e
        },
        getNextStateId: function() {
            return this._internalNextStateId
        },
        getConditionFlagInCurrTransition: function(e) {
            var t = this.conditionFlags[e];
            return t.getFlagInCurrTransition()
        },
        getConditionFlagInFrame: function(e) {
            var t = this.conditionFlags[e];
            return t.getFlagInFrame()
        },
        getResultObjectsInFrame: function(e) {
            var t = this.resultObjectTmps[e];
            return t.getResultObjects()
        }
    }, {
        getBuiltinFunction: function(e) {
            return i[e]
        }
    }), FF.ns.battle.ai.State
}), define("scenes/battle/fsm/StateMap", ["util", "lib/EventBase"], function(e, t) {
    return FF.ns.battle.fsm.StateMap = t.extend({
        initialize: function(n) {
            t.prototype.initialize.apply(this, arguments), this.globalRegister = e.cloneDeep(n.globalRegister || {}), this.states = {}, this._params = n, this._currentState = null
        },
        update: function(e) {
            var t = this._currentState;
            if (!t) {
                t = this._currentState = this.states[this._params.startStateId];
                if (!t || !_.isFunction(t.inState)) throw new Error("inState Error Debug: " + JSON.stringify({
                    startStateId: this._params.startStateId,
                    existsCurrState: !!t,
                    statesKeys: _.keys(this.states)
                }));
                t.inState()
            }
            t.preUpdate(e), t.update(e), t.postUpdate(e);
            var n = t.updateTransition();
            n && this.changeState(n)
        },
        changeState: function(e) {
            var t = this._currentState,
                n = this.states[e],
                r = t.getStateId();
            t.outState(), t.triggerTx && (t.triggerTx.transit(t, n), t.triggerTx = null), FF.logger.debug("IN_STATE", e), n.inState(), this._currentState = n, this.trigger("StateMap::changeState", e, r)
        },
        findState: function(e) {
            return this.states[e]
        },
        isCurrentState: function(e) {
            return this._currentState && e === this._currentState.getStateId()
        }
    }), FF.ns.battle.fsm.StateMap
}), define("scenes/battle/ai/StateMap", ["../fsm/StateMap"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.ai.StateMap = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this._executer = n;
            var r = this._params.notifyJudgedDeath;
            _.isFunction(r) && (this.notifyJudgedDeath = r);
            var i = this._executer.isContainer() ? this._executer : this._executer.container;
            if (this._executer.isContainer()) {
                var s = [].concat(this._params.initialInvisibleNos || []);
                _.each(s, function(e) {
                    var t = i.getChild(e);
                    t.setInvisible()
                })
            } else this._params.initialInvisible && this._executer.setInvisible();
            this._params.shouldDeformAllNodesInAppearing && i.setEnabledShouldDeformAllNodesInAppearing()
        },
        getExecuter: function() {
            return this._executer
        },
        notifyJudgedDeath: function() {
            return !0
        }
    }), FF.ns.battle.ai.StateMap
}), define("scenes/battle/ai/StateMapBuilder", ["util"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.StateMapBuilder = {
        createById: function(e, n) {
            var r = t.ai.conf[e];
            if (!r) throw new Error("state map not found." + e);
            return this.createByJson(r, n)
        },
        createByJson: function(e, n) {
            var r = new t.ai.StateMap(e, n);
            return e.states && _.each(e.states, function(e) {
                var t = this._buildState(e, n, r);
                t.parent = r, r.states[e.id] = t
            }, this), r
        },
        _buildState: function(n, r, i) {
            var s = n.class ? t.ai.state[n.class] : t.ai.State;
            if (!s) throw new Error("state class not found." + n.class);
            var o = new s(n, r);
            return _.each(["inState", "outState", "update", "updateTransition"], function(t) {
                var r = this._getBuiltinFuncs(s, n[t]);
                r.push(o[t]), o[t] = e.makeInterceptor(o, r)
            }, this), _.each(n.transitions, function(e) {
                var t = this._buildTransition(e, r);
                t.parent = o, o.transitions.push(t)
            }, this), _.each(n.conditionFlags, function(e) {
                var t = this._buildConditionFlag(e, r, i);
                t.parent = o, o.conditionFlags[t.conditionFlagTag] = t
            }, this), _.each(n.resultObjectTmps, function(e) {
                var t = this._buildResultObjectTmp(e, r, i);
                t.parent = o, o.resultObjectTmps[t.resultObjectTmpTag] = t
            }, this), o
        },
        _buildTransition: function(n, r) {
            if (!n.class && !n.nextStateId && !n.nextStateLot) throw new Error("transition nextState[Id|Lot] not defined.");
            var i = n.class ? t.ai.transition[n.class] : t.ai.Transition;
            if (!i) throw new Error("transition class not found." + n.class);
            var s = new i(n, r);
            return s.nextStateId = n.nextStateId, s.args = e.cloneDeep(n.args || {}), s.condition = this._buildTransitConditions(n.condition, r), _.each(s.condition, function(e) {
                e.parent = s
            }), _.each(["canTransition", "transit"], function(e) {
                var t = this._getBuiltinFunc(i, n[e]);
                t && (s[e] = t)
            }, this), s
        },
        _buildTransitConditions: function(e, n) {
            e = e || [], _.isArray(e) || (e = [e]);
            var r = [];
            return _.each(e, function(e) {
                var i = e.class ? t.ai.transitCondition[e.class] : t.ai.TransitCondition;
                if (!i) throw new Error("transitCondition class not found." + e.class);
                var s = new i(e, n);
                _.each(["canTransition"], function(t) {
                    var n = this._getBuiltinFunc(i, e[t]);
                    n && (s[t] = n)
                }, this), r.push(s)
            }, this), r
        },
        _buildConditionFlag: function(n, r, i) {
            if (!n.conditionFlagTag) throw new Error("conditionFlag conditionFlagTag not defined.");
            var s = n.class ? t.ai.conditionFlag[n.class] : t.ai.ConditionFlag;
            if (!s) throw new Error("conditionFlag class not found." + n.class);
            var o = new s(n, r, i);
            return o.conditionFlagTag = n.conditionFlagTag, o.args = e.cloneDeep(n.args || {}), o.condition = this._buildTransitConditions(n.condition, r), _.each(o.condition, function(e) {
                e.parent = o
            }), _.each([], function(e) {
                var t = this._getBuiltinFunc(s, n[e]);
                t && (o[e] = t)
            }, this), o
        },
        _buildResultObjectTmp: function(e, n, r) {
            if (!e.resultObjectTmpTag) throw new Error("resultObjectTmp resultObjectTmpTag not defined.");
            var i = t.ai.resultObjectTmp[e.class];
            if (!i) throw new Error("resultObjectTmp class not found." + e.class);
            var s = new i(e, n, r);
            return s.resultObjectTmpTag = e.resultObjectTmpTag, s
        },
        _getBuiltinFunc: function(e, t) {
            var n = t;
            if (!n) return;
            if (!_.isFunction(n)) {
                n = e.getBuiltinFunction(n);
                if (!n) throw new Error("invalid builtin func." + t)
            }
            return n
        },
        _getBuiltinFuncs: function(e, t) {
            var n = [];
            if (!t) return n;
            _.isArray(t) || (t = [t]);
            for (var r = 0, i = t.length; r < i; r++) n.push(this._getBuiltinFunc(e, t[r]));
            return n
        }
    }
}), define("scenes/battle/fsm/TransitCondition", ["lib/EventBase"], function(e) {
    var t = {};
    return FF.ns.battle.fsm.TransitCondition = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments)
        },
        canTransition: function(e, t) {
            return !1
        },
        isInCurrentState: function() {
            return this.parent.isInCurrentState()
        },
        update: function() {}
    }, {
        registerBuiltinFunction: function(e, n) {
            t[e] = n
        },
        getBuiltinFunction: function(e) {
            return t[e]
        }
    }), FF.ns.battle.fsm.TransitCondition
}), define("scenes/battle/ai/TransitCondition", ["../fsm/TransitCondition", "util"], function(e, t) {
    var n = FF.ns.battle,
        r = {
            INTERRUPT_DONE: function() {
                var e = this.parent.parent,
                    t = e._ability;
                if (t) return t.isDone()
            },
            ABILITY_DONE: function() {
                var e = this._executer,
                    t = this._args;
                t && t.id && (e = e.getChild(t.id));
                var n = e.getAbility(),
                    r = !1;
                n && (this._ability = n);
                if (this._ability) {
                    var i = t ? t.abilityId : void 0;
                    t && t.abilityTag && (i = e.getAbilityIdByTag(t.abilityTag)), i ? r = this._ability.isDone() && this._ability.getAttributes().abilityId === i : r = this._ability.isDone(), r && (this._ability = void 0)
                }
                return r
            },
            DEAD: function() {
                var e = this._executer,
                    t = this._args;
                return t && t.id && (e = e.getChild(t.id)), e.isDead()
            },
            JUDGE_DEATH: function() {
                var e = this._executer,
                    t = this._args;
                return t && t.id && (e = e.getChild(t.id)), e.judgeDeath()
            },
            HP: function() {
                var e = this._executer,
                    t = this._args;
                t.id && (e = e.getChild(t.id));
                if (!!t.canNotDoAbility && !e.canDoAbility()) return !1;
                var n = e.getRemainingHpRate();
                if (t.under) return n < t.under;
                if (t.underOrEqual) return n <= t.underOrEqual;
                if (t.over) return n > t.over;
                if (t.overOrEqual) return n >= t.overOrEqual;
                throw new Error("invalid args")
            },
            HP_DIFF: function() {
                var e = this._executer,
                    t = this._args;
                t.id && (e = e.getChild(t.id));
                var n = e.getRemainingHpRate();
                if (!_.isNumber(this._targetRate)) {
                    var r = t.under || t.underOrEqual || t.over || t.overOrEqual || 0;
                    if (r === 0) throw new Error("invalid arguments");
                    var i = n + r;
                    if (i < 0 || i > 100) return !1;
                    this._targetRate = i
                }
                var s = !1;
                return t.under ? s = n < this._targetRate : t.underOrEqual ? s = n <= this._targetRate : t.over ? s = n > this._targetRate : t.overOrEqual && (s = n >= this._targetRate), s && (this._targetRate = void 0), s
            },
            SA: function() {
                var e = this._executer,
                    t = this._args,
                    r = [];
                t.saIds && (r = r.concat(t.saIds)), t.bundleId && (r = r.concat(n.StatusAilmentsConfig.getBundle(t.bundleId)));
                var i = _.intersection(e.statusAilments.getRefs(), r),
                    s = i.length > 0;
                return t.isNone ? !s : s
            },
            RANDOM: function() {
                var e = this._args,
                    n = e.rate || 50;
                return t.lotByFraction(n)
            }
        };
    return FF.ns.battle.ai.TransitCondition = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this._executer = n, this._params = t, this._args = t.args || {}
        },
        dispose: function() {
            this.stopListening()
        },
        reset: function() {}
    }, {
        getBuiltinFunction: function(e) {
            return r[e]
        }
    }), FF.ns.battle.ai.TransitCondition
}), define("scenes/battle/fsm/Transition", ["lib/EventBase"], function(e) {
    var t = {};
    return FF.ns.battle.fsm.Transition = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments), this.condition = null, this._params = t
        },
        getNextStateId: function() {
            return this._params.nextStateId
        },
        canTransition: function(e) {
            return _.all(this.condition, function(t) {
                return t.canTransition(e)
            })
        },
        update: function() {
            _.each(this.condition, function(e) {
                e.update()
            })
        },
        transit: function() {},
        isInCurrentState: function() {
            return this.parent.isInCurrentState()
        }
    }, {
        registerBuiltinFunction: function(e, n) {
            t[e] = n
        },
        getBuiltinFunction: function(e) {
            return t[e]
        }
    }), FF.ns.battle.fsm.Transition
}), define("scenes/battle/ai/Transition", ["../fsm/Transition"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.ai.Transition = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this._executer = n
        },
        getNextStateId: function() {
            var e = this._params.nextStateLot,
                n, r;
            return e ? (n = this.parent.parent.globalRegister.stateIds, r = new t.LotteryBox(n, e), r.lot()) : this._params.nextStateId
        },
        reset: function() {
            _.each(this.condition, function(e) {
                e.reset()
            })
        }
    }), FF.ns.battle.ai.Transition
}), define("scenes/battle/ai/ConditionFlag", ["lib/EventBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.ai.ConditionFlag = e.extend({
        initialize: function(t, n, r) {
            e.prototype.initialize.apply(this, arguments), this.condition = null, this._params = t, this._flagInCurrTransition = !1, this._flagInFrame = !1, this.listenTo(r, "StateMap::changeState", this._onChangeState)
        },
        _onChangeState: function(e, t) {
            this.parent.getStateId() === e && (this._flagInCurrTransition = !1, this._flagInFrame = !1, _.each(this.condition, function(e) {
                e.reset()
            }))
        },
        preUpdate: function() {
            var e = this.parent;
            _.each(this.condition, function(e) {
                e.update()
            });
            var t = _.all(this.condition, function(t) {
                return t.canTransition(e)
            });
            t ? (this._flagInCurrTransition = !0, this._flagInFrame = !0, _.each(this.condition, function(e) {
                e.reset()
            })) : this._flagInFrame = !1
        },
        isInCurrentState: function() {
            return this.parent.isInCurrentState()
        },
        getFlagInCurrTransition: function() {
            return this._flagInCurrTransition
        },
        getFlagInFrame: function() {
            return this._flagInFrame
        }
    }), FF.ns.battle.ai.ConditionFlag
}), define("scenes/battle/ai/ResultObjectTmp", ["lib/EventBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.ai.ResultObjectTmp = e.extend({
        initialize: function(t, n, r) {
            e.prototype.initialize.apply(this, arguments), this._executer = n, this._params = t, this._args = t.args || {}, this._resultObjects = [], this.listenTo(r, "StateMap::changeState", this._onChangeState)
        },
        _onChangeState: function(e, t) {
            this.parent.getStateId() === e && (this._resultObjects = [])
        },
        postUpdate: function() {
            this._resultObjects = []
        },
        isInCurrentState: function() {
            return this.parent.isInCurrentState()
        },
        getResultObjects: function() {
            return this._resultObjects
        }
    }), FF.ns.battle.ai.ResultObjectTmp
}), define("scenes/battle/ai/resultObjectTmp/DamageResultObjectTmp", ["../ResultObjectTmp"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.resultObjectTmp.DamageResultObjectTmp = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var n = t.ai.AiUtil.getActor(this._executer, this._args.id),
                r = t.ai.AiUtil.getEventNameOfApplyDamageObject(this._args.scope);
            this.listenTo(n, r, this._damageConditionHook)
        },
        _damageConditionHook: function(e, n) {
            var r = t.ai.AiUtil.checkConditionForDamageObject(this._args, e, n);
            r && this._resultObjects.push(n)
        }
    })
}), define("scenes/battle/ai/state/DoNothingState", ["../State"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.state.DoNothingState = e.extend({
        update: function() {
            var e = this._executer,
                n = this._executer.isContainer() ? this._executer : this._executer.container,
                r = this._memberValues;
            r && r.id && (e = n.getChild(r.id)), e.isReadyToSelectAbility() && t.Commander.getInstance().register(t.Conf.ABILITY_ID_OF.DO_NOTHING, e)
        }
    })
}), define("scenes/battle/ai/state/InitState", ["util", "../State"], function(e, t) {
    FF.ns.battle.ai.state.InitState = t.extend({
        inState: function() {
            var n = [];
            this._memberValues.visible && n.push(t.getBuiltinFunction("ENABLE")), this._memberValues.overrideActorParam && n.push(t.getBuiltinFunction("OVERRIDE_ACTOR_PARAM")), this._memberValues.paramId && n.push(t.getBuiltinFunction("CHANGE_PARAM")), this._memberValues.childParams && n.push(t.getBuiltinFunction("CHANGE_PARAM_MULTI")), this._memberValues.sa && n.push(t.getBuiltinFunction("SET_SA"));
            var r = this._executer,
                i = r.isContainer() ? r : r.container;
            this._memberValues.id && (r = r.getChild(this._memberValues.id)), this._memberValues.deadAnimateType && n.push(t.getBuiltinFunction("SET_DEAD_ANIMATE_TYPE")), this._memberValues.abilityDeformMap && n.push(t.getBuiltinFunction("CHANGE_ABILITY_DEFORM_MAP")), this._memberValues.abilityDeformMapTag && n.push(t.getBuiltinFunction("CHANGE_ABILITY_DEFORM_MAP_TAG")), n.push(function() {});
            var s = e.makeInterceptor(this, n);
            s()
        },
        updateTransition: function() {
            return this._memberValues.nextStateId
        }
    })
}), define("scenes/battle/ai/state/InterruptAbility", ["../State"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.state.InterruptAbility = e.extend({
        inState: function() {
            var e = this._memberValues.abilityId,
                n = this._memberValues.abilityTag,
                r = _.extend({}, this._memberValues.abilityOptions),
                i = this._memberValues.options,
                s = this._executer,
                o = s.isContainer() ? s : s.container;
            r.id && (s = o.getChild(r.id)), r.activeTargetId && (r.activeTarget = o.getChild(r.activeTargetId)), n ? e = s.getAbilityIdByTag(n) : e || (e = s.lotAbility()), this._memberValues.shouldRegisterAbilityFromActor ? this._ability = s.registerInterruptAbility(e, r, i) : (i || (i = {
                interruptBoss: !0
            }), this._ability = t.Commander.getInstance().register(e, s, r, i))
        },
        outState: function() {
            this._ability = void 0
        },
        updateTransition: function() {
            if (this._ability && this._ability.isDone()) return this._ability = void 0, this._memberValues.nextStateId
        }
    })
}), define("scenes/battle/ai/state/InterruptMultipleAbility", ["../State"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.state.InterruptMultipleAbility = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments);
            if (_.isUndefined(this._memberValues.nextStateId)) throw new Error("InterruptMultipleAbility: memberValues.nextStateId must be specified")
        },
        inState: function() {
            this._isDone = !1, this._abilityNum = 1, this.registerCurrentAbility()
        },
        shiftNextAbility: function() {
            return this._abilityNum++, this._abilityNum <= this._memberValues.abilityCount
        },
        registerCurrentAbility: function() {
            var e = this._memberValues.abilitySettingMap ? this._memberValues.abilitySettingMap[this._abilityNum] : {},
                n = e.abilityId,
                r = e.abilityTag,
                i = _.extend({}, e.abilityOptions),
                s = e.options,
                o = this._executer,
                u = this._executer.isContainer() ? this._executer : this._executer.container;
            i.id && (o = o.getChild(i.id)), i.activeTargetId && (i.activeTarget = u.getChild(i.activeTargetId));
            if (r) n = o.getAbilityIdByTag(r);
            else if (!n)
                if (e.useFuncOfLotAbilityWithout) {
                    var a = o.getWithoutAbilityList({});
                    n = o.lotAbilityWithout(a)
                } else n = o.lotAbility();
            this._memberValues.shouldRegisterAbilityFromActor || i.shouldRegisterAbilityFromActor ? this._ability = o.registerInterruptAbility(n, i, s) : (s || (s = {
                interruptBoss: !0
            }), this._ability = t.Commander.getInstance().register(n, o, i, s))
        },
        update: function() {
            this._ability && this._ability.isDone() && (this.shiftNextAbility() ? this.registerCurrentAbility() : this._isDone = !0)
        },
        updateTransition: function() {
            if (this._isDone) return this._ability = void 0, this._memberValues.nextStateId
        }
    })
}), define("scenes/battle/ai/state/SimpleState", ["../State"], function(e) {
    FF.ns.battle.ai.state.SimpleState = e.extend({
        update: function() {
            var e = this._executer;
            e.isReadyToSelectAbility() && e.lotAndRegisterAbility()
        }
    })
}), define("scenes/battle/ai/state/SimpleWithoutState", ["../State"], function(e) {
    FF.ns.battle.ai.state.SimpleWithoutState = e.extend({
        update: function() {
            var e = this._executer;
            if (e.isReadyToSelectAbility()) {
                var t = {};
                this._memberValues && this._memberValues.withoutOptions && _.extend(t, this._memberValues.withoutOptions), e.withoutAndLotAndRegisterAbility(t)
            }
        }
    })
}), define("scenes/battle/ai/transition/NextStateIdTransition", ["../Transition"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.ai.transition.NextStateIdTransition = e.extend({
        getNextStateId: function() {
            return this.parent.getNextStateId()
        },
        canTransition: function(e, t) {
            return !!this.parent.getNextStateId()
        }
    }), FF.ns.battle.ai.transition.NextStateIdTransition
}), define("scenes/battle/ai/transitCondition/AbilityCountTransitCondition", ["../TransitCondition", "util"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.ai.transitCondition.AbilityCountTransitCondition = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this._executer,
                n = this._args;
            if (!n.count) throw new Error("count is required");
            if (!(n.anyAbilities || n.abilityId || n.abilityTag)) throw new Error("abilityId, abilityTag or anyAbilities is required");
            n.id && (t = t.getChild(n.id));
            var r = "ActorBase::entryInAction";
            !n.whenDone || (r = "ActorBase::exitInAction"), this.listenTo(t, r, this._onAction), this.reset()
        },
        reset: function() {
            this._can = !1, this._count = 0
        },
        canTransition: function(e) {
            return this._can
        },
        _onAction: function(e) {
            if (!this.isInCurrentState()) return;
            this._args.anyAbilities ? this._count++ : this._countCondAbility(e), this._count >= this._args.count && (this._can = !0, this._args && this._args.rate && (this._can = t.lotByFraction(this._args.rate), this._can || (this._count = 0)))
        },
        _countCondAbility: function(e) {
            var t = this._retrieveAbility(e),
                n = this._args.abilityId;
            if (this._args.abilityTag) {
                var r = _.isArray(this._args.abilityTag) ? this._args.abilityTag : [this._args.abilityTag];
                n = _.map(r, function(t) {
                    return e.getAbilityIdByTag(t)
                }, this)
            }
            if (n) {
                var i = _.isArray(n) ? n : [n];
                _.any(i, function(e) {
                    return t.get("abilityId") === e
                }) && this._count++
            }
        },
        _retrieveAbility: function(e) {
            var t = e.getAbility();
            return !this._args.whenDone || (t = e.getLastAbility()), t
        }
    })
}), define("scenes/battle/ai/transitCondition/DamageTransitCondition", ["../TransitCondition", "util"], function(e, t) {
    var n = FF.ns.battle;
    return FF.ns.battle.ai.transitCondition.DamageTransitCondition = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this._executer,
                n = this._args;
            n.id && (t = t.getChild(n.id));
            var r = void 0;
            switch (n.scope) {
                case "SET_SA":
                    r = "ActorBase::addStatusAilments";
                    break;
                case "UNSET_SA":
                    r = "ActorBase::unsetStatusAilments";
                    break;
                case "ANY":
                    r = "ActorBase::applyDamageObject";
                    break;
                default:
                    r = "ActorBase::addDamage"
            }
            this.listenTo(t, r, this._damageConditionHook), this.reset()
        },
        reset: function() {
            this._can = !1
        },
        canTransition: function(e) {
            return this._can
        },
        _damageConditionHook: function(e, t) {
            if (!this.isInCurrentState()) return;
            if (this._can) return;
            this._onDamage(e, t)
        },
        _onDamage: function(e, r) {
            var i = r.ability,
                s = this._args;
            if (s.counter && !n.util.DamageCalculator.isEnableCounter(r)) return;
            var o = !1;
            s.all && (o = !0), s.element && n.Conf.ELEMENT_TYPE[s.element] === r.element && (o = !0), s.elements && _.any(s.elements, function(e) {
                return e === r.element
            }) && (o = !0), s.exercise && n.Conf.EXERCISE_TYPE[s.exercise] === i.exerciseType() && (o = !0), s.exercises && _.any(s.exercises, function(e) {
                return e === i.get("exerciseType")
            }) && (o = !0);
            if (s.targetRange) {
                var u = i.get("targetRange");
                u === s.targetRange && (o = !0)
            }
            s.abilityIds && _.any(s.abilityIds, function(e) {
                return e === i.get("abilityId")
            }) && (o = !0);
            if (s.abilityTags && i.executer.isEnemy()) {
                var a = _.any(s.abilityTags, function(e) {
                    return i.executer.hasAbilityTag(e) ? i.executer.getAbilityIdByTag(e) === i.get("abilityId") : !1
                });
                a && (o = !0)
            }
            s.evaluateFlgName && r[s.evaluateFlgName] && (o = !0);
            if (s.setSaIds) {
                var f = [].concat(s.setSaIds),
                    l = r.statusAilments || [];
                l = _.map(l, function(e) {
                    return Number(e)
                }), _.intersection(f, l).length > 0 && (o = !0)
            }
            if (s.unsetSaIds) {
                var c = [].concat(s.unsetSaIds),
                    h = r.unsetStatusAilments || [];
                h = _.map(h, function(e) {
                    return Number(e)
                }), _.intersection(c, h).length > 0 && (o = !0)
            }
            s.buddyId && r.executer.getId() !== s.buddyId && (o = !1);
            if (s.damagedOnly)
                if (s.ignorePoison === !0 && r.type === n.Conf.CALC_TYPE.POISON) o = !1;
                else if (_.isNumber(r.damage)) {
                var p = s.damagedOnlyOptions || {},
                    d = !1;
                _.isNumber(p.under) ? d = r.damage < p.under : _.isNumber(p.underOrEqual) ? d = r.damage <= p.underOrEqual : _.isNumber(p.over) ? d = r.damage > p.over : _.isNumber(p.overOrEqual) ? d = r.damage >= p.overOrEqual : d = r.damage > 0, d || (o = !1)
            } else o = !1;
            if (s.canDoAbility) {
                var v = this._executer;
                s.id && (v = v.getChild(s.id)), v.canDoAbility() || (o = !1)
            }
            o && (s.rate ? this._can = t.lotByFraction(s.rate) : this._can = !0)
        }
    }), FF.ns.battle.ai.transitCondition.DamageTransitCondition
}), define("scenes/battle/ai/transitCondition/EachDamageTransitCondition", ["./DamageTransitCondition"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.transitCondition.EachDamageTransitCondition = e.extend({
        _damageConditionHook: function(e, t) {
            this.reset();
            if (!this.isInCurrentState()) return;
            this._onDamage(e, t)
        }
    })
}), define("scenes/battle/ai/transitCondition/TimeTransitCondition", ["../TransitCondition"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.transitCondition.TimeTransitCondition = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.reset()
        },
        update: function() {
            this._elapsedTime += FF.scene.elapsedBattleTime
        },
        reset: function() {
            this._elapsedTime = 0
        },
        canTransition: function(e, t) {
            return this._elapsedTime >= this._args.sec * 1e3
        }
    })
}), define("scenes/battle/ai/transitCondition/TurnTransitCondition", ["../TransitCondition"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.transitCondition.TurnTransitCondition = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this._args,
                n = this._executer;
            t.id && (n = n.getChild(t.id)), this.listenTo(n, "ActorBase::changeState", this._onChangeState), this.reset()
        },
        reset: function() {
            this._can = !1, this._box = void 0, this._elapsedTurn = 0;
            var e = this._args;
            e.lot && (this._box = new t.LotteryBox([!0, !1], e.lot))
        },
        canTransition: function(e, t) {
            return this._can
        },
        _onChangeState: function(e, t, n) {
            if (!this.isInCurrentState()) return;
            if (n !== "IN_ACTION") return;
            this._elapsedTurn++;
            var r = this._args;
            this._box && (this._can = this._box.lot()), r.turn > 0 && r.turn <= this._elapsedTurn && (this._can = !0)
        }
    })
}), define("scenes/battle/materia/MateriaHelper", ["util", "lib/EventBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.materia.MateriaHelper = t.extend({
        initialize: function(e) {
            t.prototype.initialize.apply(this, arguments), this._materia = e
        },
        inflictSa: function(e) {
            var t = this._materia,
                r = t.executer,
                i = n.util.DamageCalculator.makeDamageObject(r, r, void 0, {
                    statusAilments: [e]
                });
            r.applyDamageObject(i)
        },
        inflictParam: function(t) {
            var r = this._materia,
                i = r.executer,
                s = n.Config.getInstance().get("MateriaParamConfig"),
                o = s[t];
            if (!o) throw new Error("param config not found.id=".configId);
            var u = [];
            for (var a = 0, f = o.length; a < f; a++) {
                var l = e.cloneDeep(o[a]),
                    c = void 0,
                    h = void 0,
                    p = l.paramName,
                    d = i.getBaseParam(),
                    v = d[p] || 0,
                    m = i.get(p);
                if (!_.has(l, "rate")) throw new Error("invalid ParamMateria boostObj");
                l.rate = l.rate;
                var g = i.setBoost(p, l.rate);
                u.push(g), FF.logger.debug("PARAM_MATERIA", m, c)
            }
            return u
        },
        resetParam: function(e) {
            var t = this._materia,
                n = t.executer;
            _.each(e, function(e) {
                n.resetParam(e)
            })
        },
        matchesForDamageHook: function(e, t) {
            var r = this._materia,
                i = e.ability,
                s = r.get("conditionType"),
                o = r.get("conditionValue");
            switch (s) {
                case n.Conf.MATERIA_CONDTION_TYPE.ABILITY_ID:
                    if (o === i.get("abilityId")) return !0;
                    break;
                case n.Conf.MATERIA_CONDTION_TYPE.ELEMENT:
                    if (o === t.element) return !0;
                    break;
                case n.Conf.MATERIA_CONDTION_TYPE.EXERCISE:
                    if (o === i.exerciseType()) return !0;
                    break;
                case n.Conf.MATERIA_CONDTION_TYPE.ALL:
                    return !0;
                case n.Conf.MATERIA_CONDTION_TYPE.FLIGHT:
                    if (t.isFlightAttack) return !0;
                    break;
                default:
                    throw new Error("invalid materia condition type=" + s)
            }
            return !1
        },
        isAllowableTypesWithParams: function(t) {
            t = e.option({
                exerciseType: void 0,
                calcType: void 0
            }, t);
            var r = this._materia.get("allowableTypesId");
            if (!r) return !1;
            var i = n.Config.getInstance().get("MateriaAllowableTypesConfig", r);
            if (_.isUndefined(i) || !_.isObject(i)) throw new Error("undefined materia allowable types. ID:" + r);
            return _.all(i, function(e, n) {
                switch (n) {
                    case "exerciseTypes":
                        return _.contains(e, t.exerciseType);
                    case "calcTypes":
                        return _.contains(e, t.calcType);
                    default:
                        return !1
                }
            })
        },
        calcResultDamageByFactor: function(e, t) {
            return n.util.DamageCalculator.getAllowableDamage(Math.floor(e * t / 100))
        }
    })
}), define("scenes/battle/materia/MateriaBase", ["lib/NameConventionFsm"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.materia.MateriaBase = e.extend({
        initialize: function(n, r) {
            e.prototype.initialize.apply(this, arguments), this.executer = n, this._attributes = _.extend({}, r), this.helper = new t.materia.MateriaHelper(this), this._resumeData = {}
        },
        update: function() {},
        getSlot: function() {
            return this.get("slot")
        },
        notify: function(e, t) {},
        toPlainObject: function() {
            return this._resumeData
        },
        applyPlainObject: function(e) {
            _.extend(this._resumeData, e)
        }
    }), FF.ns.battle.materia.MateriaBase
}), define("scenes/battle/materia/FirstAttackMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.materia.FirstAttackMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("prob", this.get("arg1"))
        },
        notify: function(t) {
            var r = this.executer;
            if (t !== n.Conf.MATERIA_NOTIFY_TYPE.SETUP_ROUND) return;
            FF.logger.debug("FirstAttackMateria"), e.lotByFraction(this.get("prob")) && r.set("elapsedAtbTime", r.getAtbTime() - 1)
        }
    })
}), define("scenes/battle/materia/PanelNumMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelNumMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("num", this.get("arg1")), this.set("exerciseType", this.get("arg2")), this.set("recoverRate", this.get("arg3"))
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND ? !1 : this._resumeData.isDone ? !1 : !0
        },
        notify: function(t, n) {
            if (!this._should(t)) return;
            var r = this.executer,
                i = e.lotByFraction(this.get("recoverRate"));
            _.each(r.getAbilityPanels(), function(e) {
                if (!e.isCommandPanel()) return;
                if (!e.equalsExerciseType(this.get("exerciseType"))) return;
                if (!i) return;
                var t = _.min([e.get("remainNum") + this.get("num"), e.get("maxNum")]);
                e.set("remainNum", t), FF.logger.debug("PanelNumMateria")
            }, this), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/PanelNumMateriaByCategory", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelNumMateriaByCategory = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("num", this.get("arg1")), this.set("categoryId", this.get("arg2")), this.set("recoverRate", this.get("arg3"))
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND ? !1 : this._resumeData.isDone ? !1 : !0
        },
        notify: function(t, n) {
            if (!this._should(t)) return;
            var r = this.executer,
                i = e.lotByFraction(this.get("recoverRate"));
            _.each(r.getAbilityPanels(), function(e) {
                if (!e.isCommandPanel()) return;
                if (!e.equalsCategoryId(this.get("categoryId"))) return;
                if (!i) return;
                var t = _.min([e.get("remainNum") + this.get("num"), e.get("maxNum")]);
                e.set("remainNum", t), FF.logger.debug("PanelNumMateriaByCategory")
            }, this), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/PanelNumMateriaByMultiCategory", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelNumMateriaByMultiCategory = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("num", this.get("arg1")), this.set("recoverRate", this.get("arg2"));
            var e = [];
            _.times(3, function(t) {
                var n = this.get("arg" + (t + 3));
                n && e.push(n)
            }, this), this.set("categoryIds", e)
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND ? !1 : this._resumeData.isDone ? !1 : !0
        },
        notify: function(t, n) {
            if (!this._should(t)) return;
            var r = this.executer,
                i = e.lotByFraction(this.get("recoverRate"));
            _.each(r.getAbilityPanels(), function(e) {
                if (!e.isCommandPanel()) return;
                if (!_.include(this.get("categoryIds"), e.get("abilityInfo").categoryId)) return;
                if (!i) return;
                var t = _.min([e.get("remainNum") + this.get("num"), e.get("maxNum")]);
                e.set("remainNum", t), FF.logger.debug("PanelNumMateriaByCategory")
            }, this), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/PanelSwapMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelSwapMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("rate", this.get("arg1")), this.set("abilityId", this.get("arg2")), this.set("swapAbilitySsPoint", this.get("arg3"))
        },
        notify: function(t, i) {
            if (t !== r.ABILITY_PANEL) return;
            var s = i.abilityPanel,
                o = i.result,
                u = s.get("receptorId");
            if (u !== n.Conf.RECEPTOR.PANEL_ATTACK) return;
            if (o.abilityId) return;
            e.lotByFraction(this.get("rate")) && (o.abilityId = this.get("abilityId"), o.swapAbilitySsPoint = this.get("swapAbilitySsPoint"))
        }
    })
}), define("scenes/battle/materia/PanelRandomSwapMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelRandomSwapMateria = t.extend({
        initialize: function() {
            var e = this;
            t.prototype.initialize.apply(this, arguments), this.set("rate", this.get("arg1")), this.set("swapAbilitySsPoint", this.get("arg2"));
            var n = [],
                r = [],
                i = ["arg3", "arg4", "arg5"];
            _.each(i, function(t) {
                e.get(t) !== 0 && (n.push(e.get(t)), r.push(1))
            }), this.set("abilityIds", n), this.set("abilityLot", r)
        },
        notify: function(t, i) {
            if (t !== r.ABILITY_PANEL) return;
            var s = i.abilityPanel,
                o = i.result,
                u = s.get("receptorId");
            if (u !== n.Conf.RECEPTOR.PANEL_ATTACK) return;
            if (o.abilityId) return;
            if (e.lotByFraction(this.get("rate"))) {
                var a = new n.LotteryBox(this.get("abilityIds"), this.get("abilityLot")),
                    f = a.lot();
                o.abilityId = f, o.swapAbilitySsPoint = this.get("swapAbilitySsPoint")
            }
        }
    })
}), define("scenes/battle/materia/ParamMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.ParamMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1"))
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE ? !1 : e === r.SETUP_ROUND && this._resumeData.isDone ? !1 : !0
        },
        notify: function(e) {
            if (!this._should.apply(this, arguments)) return;
            this.helper.inflictParam(this.get("configId")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/ParamAndInflictSaMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.ParamAndInflictSaMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1")), this.set("statusAilmentsId", this.get("arg2"))
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE ? !1 : e === r.SETUP_ROUND && this._resumeData.isDone ? !1 : !0
        },
        notify: function(e) {
            if (!this._should(e)) return;
            this.helper.inflictParam(this.get("configId")), this.helper.inflictSa(this.get("statusAilmentsId")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/InflictSaMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.InflictSaMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("statusAilmentsId", this.get("arg1"))
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE ? !1 : e === r.SETUP_ROUND && this._resumeData.isDone ? !1 : !0
        },
        notify: function(e) {
            if (!this._should(e)) return;
            this.helper.inflictSa(this.get("statusAilmentsId")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/InflictSaWhenHpFallsMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.InflictSaWhenHpFallsMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("hpRate", this.get("arg1")), this.set("statusAilmentsId", this.get("arg2"))
        },
        update: function() {
            if (this._resumeData.isDone) return;
            var e = this.executer,
                t = e.get("hp"),
                n = e.get("maxHp");
            Math.ceil(t / n * 100) <= this.get("hpRate") && (this.helper.inflictSa(this.get("statusAilmentsId")), this._resumeData.isDone = !0)
        }
    })
}), define("scenes/battle/materia/DamageBoostWhenWeaknessMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostWhenWeaknessMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1"))
        },
        notify: function(e, t) {
            var n = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var i = t.result,
                s = i.damage || 0,
                o = this.get("factor") || 100;
            if (!i.canHit || !i.isWeakness || s <= 0) return;
            i.damage = this.helper.calcResultDamageByFactor(s, o), FF.logger.debug("DamageBoostWhenWeaknessMateria", "dmg", i.damage, "dmg_old", s, "factor", o)
        }
    })
}), define("scenes/battle/materia/DamageBoostElementMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostElementMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("element", this.get("arg2"))
        },
        notify: function(e, t) {
            var n = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var i = t.result,
                s = i.damage || 0,
                o = this.get("factor") || 100;
            if (!i.canHit || s <= 0) return;
            if (i.element !== this.get("element")) return;
            i.damage = this.helper.calcResultDamageByFactor(s, o), FF.logger.debug("DamageBoostElementMateria", "dmg", i.damage, "dmg_old", s, "factor", o)
        }
    })
}), define("scenes/battle/materia/DamageBoostByWeaponMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostByWeaponMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("weaponCategoryId", this.get("arg2"))
        },
        notify: function(e, t) {
            var i = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var s = t.result,
                o = s.damage || 0,
                u = this.get("factor") || 100,
                a = s.type;
            if (!s.canHit || o <= 0) return;
            var f = i.get("weapon");
            if (f.categoryId !== this.get("weaponCategoryId")) return;
            if (a !== n.Conf.CALC_TYPE.ATTACK) return;
            var l = t.data.ability.get("exerciseType");
            if (l !== n.Conf.EXERCISE_TYPE.PHYSICAL) return;
            s.damage = this.helper.calcResultDamageByFactor(o, u), FF.logger.debug("DamageBoostByWeaponMateria", "dmg", s.damage, "dmg_old", o, "factor", u)
        }
    })
}), define("scenes/battle/materia/BlackMagicDamageBoostByWeaponMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.BlackMagicDamageBoostByWeaponMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("weaponCategoryId", this.get("arg2"))
        },
        notify: function(e, t) {
            var i = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var s = t.result,
                o = s.damage || 0,
                u = this.get("factor") || 100,
                a = s.type;
            if (!s.canHit || o <= 0) return;
            var f = i.get("weapon");
            if (f.categoryId !== this.get("weaponCategoryId")) return;
            if (a !== n.Conf.CALC_TYPE.MAGIC) return;
            var l = t.data.ability.get("exerciseType");
            if (l !== n.Conf.EXERCISE_TYPE.BLACK_MAGIC) return;
            s.damage = this.helper.calcResultDamageByFactor(o, u), FF.logger.debug("BlackMagicDamageBoostByWeaponMateria", "dmg", s.damage, "dmg_old", o, "factor", u)
        }
    })
}), define("scenes/battle/materia/DamageBoostAbilityMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostAbilityMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("conditionType", this.get("arg2")), this.set("conditionValue", this.get("arg3"))
        },
        notify: function(e, t) {
            var n = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var i = t.data,
                s = t.result,
                o = s.damage || 0,
                u = this.get("factor") || 100;
            if (!s.canHit || o <= 0) return;
            if (!this.helper.matchesForDamageHook(i, s)) return;
            s.damage = this.helper.calcResultDamageByFactor(o, u), FF.logger.debug("DamageBoostAbilityMateria", "dmg", s.damage, "dmg_old", o, "factor", u)
        }
    })
}), define("scenes/battle/materia/DamageBoostByWeaponWithAllowableTypesMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostByWeaponWithAllowableTypesMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("weaponCategoryId", this.get("arg2")), this.set("allowableTypesId", this.get("arg3"))
        },
        notify: function(e, t) {
            var n = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var i = t.result,
                s = i.damage || 0,
                o = this.get("factor") || 100,
                u = i.type;
            if (!i.canHit || s <= 0) return;
            var a = n.get("weapon");
            if (a.categoryId !== this.get("weaponCategoryId")) return;
            var f = {
                exerciseType: t.data.ability.get("exerciseType"),
                calcType: u
            };
            if (!this.helper.isAllowableTypesWithParams(f)) return;
            i.damage = this.helper.calcResultDamageByFactor(s, o), FF.logger.debug("DamageBoostByWeaponWithAllowableTypesMateria", "dmg", i.damage, "dmg_old", s, "factor", o)
        }
    })
}), define("scenes/battle/materia/HealBoostMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.HealBoostMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("conditionType", this.get("arg2")), this.set("conditionValue", this.get("arg3"))
        },
        notify: function(e, t) {
            var n = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var i = t.data,
                s = t.result,
                o = s.damage || 0,
                u = this.get("factor") || 100;
            if (!s.canHit || o >= 0 || s.isAbilityPanel) return;
            if (!this.helper.matchesForDamageHook(i, s)) return;
            s.damage = this.helper.calcResultDamageByFactor(o, u), FF.logger.debug("HealBoostMateria", "dmg", s.damage, "dmg_old", o, "factor", u)
        }
    })
}), define("scenes/battle/materia/CounterMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.CounterMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("prob", this.get("arg1")), this.set("condType", this.get("arg2")), this.set("condValue", this.get("arg3")), this.set("factor", this.get("arg4")), this.set("abilityId", this.get("arg5"))
        },
        notify: function(e, t) {
            if (e === r.SETUP_ROUND) return this._notifySetupRound(t);
            if (e === r.DAMAGE_HOOK) return this._notifyDamageHook(t)
        },
        _notifyDamageHook: function(e) {
            var t = this.executer,
                n = e.result,
                r = n.damage || 0,
                i = this.get("factor") || 100,
                s = e.data.ability;
            if (!n.canHit || r <= 0) return;
            if (!s.get("isCounter")) return;
            if (s.get("abilityId") !== this._getAbilityId()) return;
            n.damage = this.helper.calcResultDamageByFactor(r, i), FF.logger.debug("CounterMateria", "dmg", n.damage, "dmg_old", r, "factor", i)
        },
        _notifySetupRound: function(e) {
            var t = this.executer;
            if (this._resumeData.isDone) return;
            if (!t.isBuddy()) return;
            var r = t.getReceptorById(n.Conf.RECEPTOR.PANEL_ATTACK),
                i = this._getAbilityId(),
                s = this.get("condType"),
                o = this.get("condValue"),
                u = this.get("prob");
            t.counters.add(i, s, o, u), FF.logger.debug("CounterMateria", "abilityId", i, "condType", s, "condValue", o, "prob", u), this._resumeData.isDone = !0
        },
        _getAbilityId: function() {
            if (this.get("abilityId")) return this.get("abilityId");
            var e = this.executer.getReceptorById(n.Conf.RECEPTOR.PANEL_ATTACK);
            return e.get("abilityId")
        }
    })
}), define("scenes/battle/materia/ParamBoostInBuddyDeadMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.ParamBoostInBuddyDeadMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1")), this._resumeData.attachParams = []
        },
        update: function() {
            var e = n.BuddyPartyMgr.getInstance().getMaxPartyNum() - n.ActorMgr.getAllBuddies().length,
                t = e + n.ActorMgr.getDeadBuddies().length - this._resumeData.attachParams.length;
            t !== 0 && (t > 0 ? this._inflictParams(t) : this._resetParams(Math.abs(t)))
        },
        _inflictParams: function(e) {
            for (var t = 0; t < e; t++) {
                var n = this.helper.inflictParam(this.get("configId"));
                this._resumeData.attachParams.push(n)
            }
        },
        _resetParams: function(e) {
            for (var t = 0; t < e; t++) {
                var n = this._resumeData.attachParams.shift();
                this.helper.resetParam(n)
            }
        },
        notify: function(e) {
            e === r.RESET_FOR_CONTINUE && (this._resumeData.attachParams = [])
        }
    })
}), define("scenes/battle/materia/ParamBoostInHpDecreaseMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE,
        i = 10;
    FF.ns.battle.materia.ParamBoostInHpDecreaseMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1")), this._resumeData.attachParams = []
        },
        update: function() {
            var e = i - Math.ceil(this.executer.getRemainingHpRate() / i),
                t = e - this._resumeData.attachParams.length;
            t !== 0 && (t > 0 ? this._inflictParams(t) : this._resetParams(Math.abs(t)))
        },
        _inflictParams: function(e) {
            for (var t = 0; t < e; t++) {
                var n = this.helper.inflictParam(this.get("configId"));
                this._resumeData.attachParams.push(n)
            }
        },
        _resetParams: function(e) {
            for (var t = 0; t < e; t++) {
                var n = this._resumeData.attachParams.shift();
                this.helper.resetParam(n)
            }
        },
        notify: function(e) {
            e === r.RESET_FOR_CONTINUE && (this._resumeData.attachParams = [])
        }
    })
}), define("scenes/battle/materia/ParamBoostByArmorMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.ParamBoostByArmorMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1")), this.set("armorCategoryId", this.get("arg2"))
        },
        notify: function(e) {
            var t = this.executer;
            if (e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE) return !1;
            if (e === r.SETUP_ROUND && this._resumeData.isDone) return !1;
            var n = t.get("armor");
            if (+n.categoryId !== this.get("armorCategoryId")) return;
            this.helper.inflictParam(this.get("configId")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/ParamBoostByWeaponMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.ParamBoostByWeaponMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1")), this.set("weaponCategoryId", this.get("arg2"))
        },
        notify: function(e) {
            var t = this.executer;
            if (e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE) return !1;
            if (e === r.SETUP_ROUND && this._resumeData.isDone) return !1;
            var n = t.get("weapon");
            if (+n.categoryId !== this.get("weaponCategoryId")) return;
            this.helper.inflictParam(this.get("configId")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/SoulStrikePointFactorBoostMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.materia.SoulStrikePointFactorBoostMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("atkSsPointFactorByMateria", this.get("arg1")), this.set("defSsPointFactorByMateria", this.get("arg2"))
        },
        notify: function(e) {
            var t = this.executer;
            if (e !== n.Conf.MATERIA_NOTIFY_TYPE.SETUP_ROUND) return;
            if (this._resumeData.isDone) return;
            t.set("atkSsPointFactorByMateria", this.get("atkSsPointFactorByMateria")), t.set("defSsPointFactorByMateria", this.get("defSsPointFactorByMateria")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/SeqActionByCategoryMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.SeqActionByCategoryMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("rate", this.get("arg1")), this.set("categoryId", this.get("arg2"))
        },
        notify: function(t, i) {
            if (t !== r.ACTION_EXIT) return;
            var s = i.ability,
                o = s.get("abilityId"),
                u = n.AbilityInfoMgr.getInstance().getById(o).categoryId;
            if (u !== this.get("categoryId") || s.get("isSoulStrike") || s.get("isSupporterSoulStrike")) return;
            e.lotByFraction(this.get("rate")) && n.Commander.getInstance().register(o, this.executer, {}, {
                interruptCounter: !0
            })
        }
    })
}), define("scenes/battle/recept/ReceptBase", ["lib/ClassBase"], function(e) {
    return FF.ns.battle.recept.ReceptBase = e.extend({
        initialize: function(t) {
            e.prototype.initialize.call(this), this._actor = t, this.set("visible", !0)
        },
        load: function() {
            throw new Error("override plz.")
        },
        canRecept: function() {
            throw new Error("override plz.")
        },
        makeCommandFunc: function() {
            throw new Error("override plz.")
        },
        decreaseResources: function() {
            throw new Error("override plz.")
        },
        toPlainObject: function() {
            return {
                attributes: this._attributes
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            _.extend(this._attributes, e.attributes)
        }
    }), FF.ns.battle.recept.ReceptBase
}), define("scenes/battle/recept/AbilityPanel", ["./ReceptBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    FF.ns.battle.recept.AbilityPanel = e.extend({
        load: function(e) {
            var r = e.maxNum ? e.maxNum : null,
                i = t.Config.getInstance().get("DefaultAbilityPanels"),
                s = !!e.isSpare,
                o = e.receptorId ? e.receptorId : i[e.panelNo];
            if (!o) throw new Error("not detect receptorId");
            var u = null;
            if (!s) {
                u = e.panelNo ? e.panelNo : _.invert(i)[o];
                if (!u) throw new Error("not detect panelNo")
            }
            _.extend(this._attributes, {
                receptorId: o,
                panelNo: u,
                isInfinity: r === null,
                remainNum: e.num,
                maxNum: r,
                defaultMaxNum: r,
                abilityId: e.abilityId,
                abilityInfo: t.AbilityInfoMgr.getInstance().getById(e.abilityId),
                abilitySsPoint: e.abilitySsPoint || 0,
                panelType: e.panelType || n.PANEL_TYPE.COMMAND
            }), this.set("name", this._detectName(e)), s ? (this.set("visible", !1), this._actor.sparePanelReceptors[o] = this) : (this.set("visible", !0), this._actor.receptors[o] = this)
        },
        _detectName: function(e) {
            return e.name ? e.name : this.isDefensePanel() ? t.TextMaster.getInstance().get("B10040") : ""
        },
        isLocated: function() {
            return !!this.get("panelNo") && !!this.get("visible")
        },
        locate: function(e) {
            this.set("panelNo", e), this.set("visible", !0)
        },
        dislocate: function() {
            this.set("panelNo", null), this.set("visible", !1)
        },
        isInfinity: function() {
            return this.get("isInfinity")
        },
        isCommandPanel: function() {
            return this.get("panelType") === n.PANEL_TYPE.COMMAND
        },
        isDefensePanel: function() {
            return this.get("panelType") === n.PANEL_TYPE.DEFENSE
        },
        decreaseResources: function() {
            if (this.isInfinity()) return;
            var e = this.get("remainNum");
            this.set("remainNum", _.max([0, e - 1]))
        },
        equalsExerciseType: function(e) {
            return this.get("abilityInfo").exerciseType === e
        },
        equalsCategoryId: function(e) {
            return this.get("abilityInfo").categoryId === e
        },
        canRecept: function() {
            if (!this._actor.canUseAllMagic()) {
                var e = t.Config.getInstance().get("MagicExerciseTypes");
                if (_.contains(e, this.get("abilityInfo").exerciseType)) return !1
            }
            return this.isInfinity() ? !0 : this.get("remainNum") > 0
        },
        resetForContinue: function() {
            if (this.isInfinity()) return;
            var e = this.get("defaultMaxNum");
            this.set("maxNum", e), this.set("remainNum", e)
        },
        addConsumableNum: function(e) {
            if (this.isInfinity()) return;
            var t = this.get("maxNum") + e,
                n = this.get("remainNum") + e;
            this.set("maxNum", t), this.set("remainNum", n)
        },
        makeCommandFunc: function() {
            var e = this,
                r = e._actor,
                i = e.get("abilityId"),
                s = e.get("abilityInfo"),
                o = t.ActorMgr.getActiveTarget(),
                u = n.ABILITY_ID_OF.ATTACK === i,
                a = n.PANEL_TYPE.DEFENSE === this.get("panelType");
            FF.logger.debug("[ã‚¢ãƒ“ãƒªãƒ†ã‚£ãƒ‘ãƒãƒ«] " + s.options.name + "ã‚’é¸æŠž");
            var f = {
                receptorId: this.get("receptorId")
            };
            a || (f.isAbilityPanel = !0, f.activeTarget = o);
            var l = {};
            r.materiaHolder.notify(t.Conf.MATERIA_NOTIFY_TYPE.ABILITY_PANEL, {
                abilityPanel: this,
                result: l
            });
            var c = r.getSwapAbilityByAttachedElement();
            return u && c ? i = c : l.abilityId && (i = l.abilityId), !l.swapAbilitySsPoint || (f.swapAbilitySsPoint = l.swapAbilitySsPoint),
                function() {
                    t.ActorMgr.clearActiveTarget(), FF.ns.battle.Commander.getInstance().register(i, r, f)
                }
        }
    })
}), define("scenes/battle/recept/Skip", ["./ReceptBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    FF.ns.battle.recept.Skip = e.extend({
        load: function(e) {
            _.extend(this._attributes, e), this._actor.receptors[n.RECEPTOR.SKIP] = this
        },
        decreaseResources: function() {},
        canRecept: function() {
            var e = this,
                n = _.filter(t.ActorMgr.getReadyToSelectAbilityBuddies(), function(t) {
                    return e._actor.getUid() !== t.getUid()
                });
            return n.length > 0
        },
        makeCommandFunc: function() {
            var e = this._actor;
            return function() {
                t.ActorMgr.notifySkipAbility(e)
            }
        }
    })
}), define("scenes/battle/recept/SoulStrike", ["./ReceptBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.recept.SoulStrike = e.extend({
        load: function(e) {
            _.extend(this._attributes, {
                abilityId: e.abilityId,
                name: e.options.name,
                dispName: e.options.dispName,
                consumeSoulStrikePoint: e.options.consumeSoulStrikePoint,
                point: e.point,
                abilityInfo: t.AbilityInfoMgr.getInstance().getById(e.abilityId)
            }), this._actor.receptors[t.Conf.RECEPTOR.SOUL_STRIKE] = this
        },
        addPointAsExecuter: function(e) {
            var t = e.get("actionResult");
            if (!t) return;
            var n = _.flatten(t.damageObjects),
                r = _.any(n, function(e) {
                    return e.canHit
                }, this);
            if (!r) return;
            var i = _.any(n, function(e) {
                    return e.isWeakness
                }, this),
                s = this._calculateAbilitySsPoint(e, i);
            s > 0 && this.addPoint(s)
        },
        addPointAsReceiver: function(e) {
            if (e.isRecovery) return;
            var t = e.executer,
                n = e.receiver;
            if (!t || !n) return;
            if (!t.isEnemy() || !n.isBuddy()) return;
            var r = this._calculateDamagedSsPoint();
            r > 0 && this.addPoint(r)
        },
        addPoint: function(e) {
            var n = this.get("point"),
                r = n + e,
                i = t.Config.getInstance().get("SoulStrike", "maxSsPoint");
            r > i && (r = i), r < 0 && (r = 0), this.set("point", r)
        },
        makeCommandFunc: function() {
            var e = this,
                n = e._actor,
                r = e.get("abilityId"),
                i = t.ActorMgr.getActiveTarget();
            return function() {
                var e = {
                    isSoulStrike: !0,
                    activeTarget: i
                };
                t.ActorMgr.clearActiveTarget(), t.Commander.getInstance().register(r, n, e)
            }
        },
        canRecept: function() {
            var e = this.get("consumeSoulStrikePoint"),
                n = this._actor.getSoulStrike().get("point");
            if (n < e) return !1;
            if (!this._actor.canUseAllMagic()) {
                var r = t.Config.getInstance().get("MagicExerciseTypes");
                if (_.contains(r, this.get("abilityInfo").exerciseType)) return !1
            }
            return !0
        },
        decreaseResources: function() {
            var e = this.get("point"),
                t = this.get("consumeSoulStrikePoint");
            this.set("point", e - t)
        },
        _calculateAbilitySsPoint: function(e, n) {
            var r = t.Config.getInstance(),
                i = void 0,
                s = this._actor.getAtkSsPointFactor(),
                o = _.max([s + 100, 0]),
                u = n ? r.get("SoulStrike", "c") : 100,
                a = e.get("receptorId"),
                f = this._actor.getReceptorById(a);
            return i = f.get("abilitySsPoint"), e.get("swapAbilitySsPoint") >= 1 && (i = e.get("swapAbilitySsPoint")), Math.floor(i * (o / 100) * (u / 100))
        },
        _calculateDamagedSsPoint: function() {
            var e = t.Config.getInstance().get("SoulStrike", "damagedSsPoint"),
                n = this._actor.getDefSsPointFactor(),
                r = _.max([n + 100, 0]);
            return Math.floor(e * (r / 100))
        },
        replaceBaseInfo: function(e) {
            this.set("abilityId", e.get("abilityId")), this.set("name", e.get("name")), this.set("consumeSoulStrikePoint", e.get("consumeSoulStrikePoint")), this.set("abilityInfo", e.get("abilityInfo"))
        }
    }), FF.ns.battle.recept.SoulStrike
}), define("scenes/battle/recept/SoulStrikePanel", ["./SoulStrike"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.recept.SoulStrikePanel = e.extend({
        load: function(e) {
            var n = t.Config.getInstance().get("SoulStrikePanels"),
                r = n[e.slot];
            _.extend(this._attributes, {
                abilityId: e.abilityId,
                name: e.options.name,
                dispName: e.options.dispName,
                consumeSoulStrikePoint: e.options.consumeSoulStrikePoint,
                abilityInfo: t.AbilityInfoMgr.getInstance().getById(e.abilityId),
                receptorId: r,
                slot: e.slot
            }), this._actor.receptors[r] = this
        },
        makeCommandFunc: function() {
            var e = this,
                t = this._actor.getSoulStrike();
            return function() {
                t.replaceBaseInfo(e), t.makeCommandFunc()()
            }
        },
        get: function(t) {
            if (t === "point") throw new Error("invalid access: SoulStrike point.");
            return e.prototype.get.call(this, t)
        }
    })
}), define("scenes/battle/recept/SupporterSoulStrike", ["./ReceptBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.recept.SupporterSoulStrike = e.extend({
        load: function(e) {
            _.extend(this._attributes, {
                abilityId: e.abilityId,
                name: e.options.name,
                restCount: e.restCount,
                abilityInfo: t.AbilityInfoMgr.getInstance().getById(e.abilityId)
            }), this._actor.receptors[t.Conf.RECEPTOR.SUPPORTER_SOUL_STRIKE] = this
        },
        makeCommandFunc: function(e) {
            var n = this,
                r = n.get("abilityId"),
                i = t.ActorMgr.getActiveTarget();
            return function() {
                var n = {
                    isSupporterSoulStrike: !0,
                    activeTarget: i
                };
                t.ActorMgr.clearActiveTarget(), t.Commander.getInstance().register(r, e, n)
            }
        },
        canRecept: function(e) {
            var t = this.get("restCount");
            return t < 1 ? !1 : !0
        },
        decreaseResources: function() {
            var e = this.get("restCount");
            this.set("restCount", e - 1)
        }
    })
}), define("scenes/battle/recept/PositiveIncontrollable", ["./ReceptBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    FF.ns.battle.recept.PositiveIncontrollable = e.extend({
        load: function(e) {
            _.extend(this._attributes, e), this._actor.receptors[n.RECEPTOR.POSITIVE_INCONTROLLABLE] = this
        },
        decreaseResources: function() {},
        canRecept: function() {
            return !0
        },
        makeCommandFunc: function() {
            var e = this._actor,
                t = e.getAbilityInfoByPositiveIncontrollable(),
                n = t.abilityId,
                r = _.extend({
                    isPositiveIncontrollable: !0,
                    shouldAddSsPoint: !1
                }, t.abilityOptions);
            return function() {
                FF.ns.battle.Commander.getInstance().register(n, e, r)
            }
        }
    })
}), define("scenes/battle/util/DamageCalculator", ["util"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {};
    r[n.CALC_TYPE.ATTACK] = "_calculateDamageByAttack", r[n.CALC_TYPE.MAGIC] = "_calculateDamageByMagic", r[n.CALC_TYPE.FRACTION] = "_calculateDamageByFraction", r[n.CALC_TYPE.SELF_DESTRUCTION] = "_calculateDamageBySelfDestruction", r[n.CALC_TYPE.FIXED_DAMAGE] = "_calculateFixedDamage", r[n.CALC_TYPE.DAMAGED_HP] = "_calculateDamageByDamagedHp", r[n.CALC_TYPE.HEAL] = "_calculateHealValue", r[n.CALC_TYPE.HEAL_SA] = "_calculateHealSa", r[n.CALC_TYPE.HEAL_DEATH] = "_calculateHealDeath", r[n.CALC_TYPE.POISON] = "_calculatePoison", r[n.CALC_TYPE.REGEN] = "_calculateRegen", r[n.CALC_TYPE.HP_BARTER] = "_calculateHpBarter", r[n.CALC_TYPE.STATUS_AILMENTS] = "_calculateStatusAilments", r[n.CALC_TYPE.PHYSICAL_STATUS_AILMENTS] = "_calculatePhysicalStatusAilments", r[n.CALC_TYPE.ENTRUSTING_SS_POINT] = "_calculateEntrustingSsPoint", r[n.CALC_TYPE.ABILITY_PANEL] = "_calculateAbilityPanel", r[n.CALC_TYPE.FRACTION_HEAL] = "_calculateHealByFractionValue", FF.ns.battle.util.DamageCalculator = {
        postCalculate: function(e) {
            return e
        },
        makeDamageObject: function(e, t, n, r) {
            return _.extend({
                damage: void 0,
                executer: e,
                receiver: t,
                ability: n
            }, r)
        },
        isEnableCounter: function(e) {
            if (!e.ability) return !1;
            var t = e.ability.get("isCounter");
            if (t) return !1;
            var n = e.executer,
                r = e.receiver;
            return !n || !r ? !1 : n.equals(r) ? !1 : e.reflector ? !1 : e.counterEnable ? r.canDoAbility() ? !0 : !1 : !1
        },
        calculateHp: function(e, t) {
            var n = e.get("hp") || 0,
                r = e.get("maxHp") || 0,
                i = this._calculateHp(t, n, r);
            return {
                maxHp: r,
                prevHp: n,
                currHp: i,
                actualDamage: n - i
            }
        },
        recalculateHp: function(e) {
            var t = {},
                n = {},
                r = function(e) {
                    if (_.isArray(e)) {
                        _.each(e, r, this);
                        return
                    }
                    var i = e.receiver;
                    if (!i) return;
                    if (!_.isNumber(e.damage) || !_.isNumber(e.prevHp) || !_.isNumber(e.currHp) || !_.isNumber(e.maxHp)) return;
                    var s = i.getUid();
                    e.counterEnable && e.canHit && (e.counterEnable = n[s] ? !1 : !0, n[s] = !0);
                    var o = _.isNumber(t[s]) ? t[s] : e.prevHp;
                    e.prevHp = o, e.currHp = this._calculateHp(e.damage, o, e.maxHp), e.actualDamage = o - e.currHp, t[s] = e.currHp
                };
            _.each(e, r, this)
        },
        _calculateHp: function(e, t, n) {
            var r = _.max([t - e, 0]);
            return r = _.min([r, n]), r
        },
        calculateAbilityPanelNum: function(e, t) {
            var n = t.get("maxNum"),
                r = t.isInfinity(),
                i = t.get("remainNum"),
                s = 0;
            return r || (s = _.max([i - e, 0]), s = _.min([s, n])), {
                maxNum: n,
                prevNum: i,
                currNum: s,
                actualDamage: i - s
            }
        },
        calculate: function(e) {
            var n = e.type,
                i = r[n];
            if (!this[i]) throw new Error("invalid type.t=" + n);
            var s = this[i](e);
            return s.type = n, s = t.DamageCalculateHook.postCalculate(e, s), this.postCalculate(s)
        },
        _calculateDamageByAttack: function(r) {
            var i = r.type;
            r = e.option({
                executer: {},
                target: {},
                ability: {},
                targetNum: 1,
                forceHit: !1,
                forceCritical: !1,
                forceMiss: !1,
                defIgnored: !1,
                atkExponentialFactor: void 0,
                defBoostIgnored: !1
            }, r);
            var s = r.ability,
                o = s.get("atkElement"),
                u = r.executer,
                a = r.target.receiver,
                f = u.equals(a) ? 0 : s.get("absorbHpFactor"),
                l = !!f,
                c = u.getAttachElementAddOnFactor(o, s),
                h = s.get("atkType") === n.ATK_TYPE.INDIRECT || u.get("atkType") === n.ATK_TYPE.INDIRECT ? n.ATK_TYPE.INDIRECT : n.ATK_TYPE.DIRECT,
                p = _.isUndefined(s.get("paramConvertType")) ? t.Conf.PARAM_CONVERT_TYPE.NONE : s.get("paramConvertType"),
                d = u.get("hp") / u.get("maxHp"),
                v = u.getBaseParam(),
                m = a.getBaseParam();
            FF.logger.info("ATTACK", u.get("dispName"), u.get("hp"), "->", a.get("dispName"), a.get("hp"));
            var g = this.__calculateDamageByAttack({
                atk: u.get("atk"),
                def: a.get("def"),
                acc: u.get("acc"),
                eva: a.get("eva"),
                executerDef: u.get("def"),
                executerBaseDef: v.def,
                critical: _.isUndefined(s.get("critical")) ? u.get("critical") : s.get("critical"),
                baseDef: m.def,
                executerRow: u.get("row"),
                receiverRow: a.get("row"),
                targetRange: s.get("targetRange"),
                targetNum: r.targetNum,
                abilityDamageFactor: this.__getAbilityDamageFactor(s, a),
                abilityAbsorbHpFactor: f,
                isAbsorbable: l,
                element: o,
                matkElementMap: u.get("matkElementMap"),
                defAttributeMap: a.get("defAttributeMap"),
                atkType: h,
                forceHit: r.forceHit,
                forceCritical: r.forceCritical,
                forceMiss: r.forceMiss,
                defIgnored: r.defIgnored,
                defBoostIgnored: r.defBoostIgnored,
                isDead: a.isDead(),
                isInDefense: a.isInDefense(),
                isHittable: a.isHittable(s.get("exerciseType"), i),
                isBlinded: u.isBlinded(),
                receiverType: a.isBuddy() ? "buddy" : "enemy",
                attachElementCoefficient: c,
                paramConvertType: p,
                currHpRate: d,
                atkExponentialFactor: r.atkExponentialFactor
            });
            return g.ability = s, g.executer = u, g.receiver = a, l && g.absorbHpDamage ? (g.absorber = u, g.absorbHp = _.extend({
                damage: g.absorbHpDamage
            }, this.calculateHp(g.absorber, g.absorbHpDamage))) : g.absorber = void 0, _.extend(g, this.calculateHp(a, g.damage)), g
        },
        __calculateDamageByAttack: function(n) {
            n = e.option({
                atk: 0,
                def: 0,
                acc: 0,
                eva: 0,
                critical: 0,
                executerDef: 0,
                executerBaseDef: 0,
                baseDef: 0,
                executerRow: void 0,
                receiverRow: void 0,
                targetRange: t.Conf.TARGET_RANGE.SINGLE,
                targetNum: 1,
                abilityDamageFactor: 100,
                abilityAbsorbHpFactor: 0,
                element: "",
                matkElementMap: {},
                defAttributeMap: {},
                forceHit: !1,
                forceCritical: !1,
                forceMiss: !1,
                defIgnored: !1,
                defBoostIgnored: !1,
                atkType: void 0,
                isDead: !1,
                isInDefense: !1,
                isHittable: !0,
                isBlinded: !1,
                isAbsorbable: !1,
                receiverType: void 0,
                attachElementCoefficient: 100,
                paramConvertType: void 0,
                currHpRate: 1,
                atkExponentialFactor: void 0
            }, n);
            var r = {
                damage: 0,
                canHit: !1,
                isCritical: !1,
                isWeakness: !1,
                advantage: void 0,
                atkType: n.atkType
            };
            if (!this._lotCanAttackHit(n)) return r;
            var i = n.atkExponentialFactor ? Math.pow(n.atk, n.atkExponentialFactor / 100) : n.atk,
                s = n.defIgnored ? 1 : n.defBoostIgnored ? n.baseDef : n.def,
                o = n.abilityDamageFactor,
                u = n.executerDef,
                a = n.executerBaseDef,
                f = t.Config.getInstance().get("DamageCalculator", "DAMAGE"),
                l = this._lotIsAttackCritical(n),
                c = f.minDamage,
                h = f.basePower,
                p = f.ratioDefence,
                d = f.maxBasic,
                v = f.maxBasicForPhysicalAndReceiverEnemy,
                m = f.ratioPower,
                g = f.ratioPowerDefence,
                y = f.ratioCoefficient,
                b = f.maxRatio,
                w = f.randCoeffiecient,
                E = f.defBufAtkConvertPower,
                S = f.maxDefBufRatio,
                x = this._calculateCoefficientByElement(n),
                T = x.coefficient,
                N = this._calculateCoefficientByRow(n),
                C = this._calculateCoefficientByNumber(n),
                k = l ? f.criticalCoefficient : 10,
                L = this._calculateCoefficientByDefense(n),
                A = n.matkElementMap[n.element] || 100,
                O = n.attachElementCoefficient,
                M = n.receiverType,
                D = n.paramConvertType,
                P = i,
                H = n.currHpRate;
            if (M === "enemy") switch (D) {
                case t.Conf.PARAM_CONVERT_TYPE.DEF_CONVERT_ATK:
                    P = i * .3 + a * _.min([Math.pow(u / a, E), S]) * .7;
                    break;
                case t.Conf.PARAM_CONVERT_TYPE.SPD_CONVERT_ATK:
                case t.Conf.PARAM_CONVERT_TYPE.NONE:
                    break;
                case t.Conf.PARAM_CONVERT_TYPE.VALIANT_ATTACK:
                    P = this.___getAtkForValiantAttack(H, i);
                    break;
                default:
                    throw new Error("invalid paramConvertType.t=" + D)
            }
            var B = M === "buddy" ? Math.floor(c + _.min([Math.pow(P, h), d]) * _.min([Math.pow(P / Math.pow(s, p), g) * y, b]) * o / 100) : Math.floor(c + _.min([Math.pow(P, h), v]) * _.min([Math.pow(P / s, m) * y, b]) * o / 100),
                j = this.getAllowableDamage(Math.floor(B * (T / 10) * (C / 100) * (k / 10) * (N / 10) * (L / 10) * ((100 + (A - 100) + (O - 100)) / 100) * (1 + w * Math.pow(e.randomInt(100, 0), 2) / 1e6))),
                F = 0;
            return n.isAbsorbable && (F = this.getAllowableDamage(Math.min(-1 * Math.floor(j * n.abilityAbsorbHpFactor / 100), -1))), FF.logger.info("dmg", j, "atk", i, "def", s, "basicPhysicalDamage", B, "damageFactor", o, "minDamage", c, "basePower", h, "ratioDefence", p, "receiverType", M, "maxBasic", d, "ratioPower", m, "ratioPowerDefence", g, "ratioCoefficient", y, "maxRatio", b, "elementCoefficient", T, "backCoefficient", N, "multipleTargetCoefficient", C, "criticalCoefficient", k, "defenseCoefficient", L, "randCoeffiecient", w, "absorbHpDamage", F, "matkElementCoefficient", A, "atkExponentialFactor", n.atkExponentialFactor), r.damage = j, r.absorbHpDamage = F, r.canHit = !0, r.isCritical = l, r.isRecovery = j < 0, r.isDamage = !0, r.isWeakness = x.isWeakness, r.advantage = x.advantage, r.element = n.element, r
        },
        _calculateDamageByMagic: function(t) {
            var n = t.type;
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                targetNum: 1,
                defIgnored: !1,
                defBoostIgnored: !1,
                matkExponentialFactor: void 0
            }, t);
            var r = t.executer,
                i = t.target.receiver,
                s = t.ability,
                o = s.get("matkElement"),
                u = i.getBaseParam();
            FF.logger.info("MAGIC", r.get("dispName"), r.get("hp"), "->", i.get("dispName"), i.get("hp"), "id", s.get("abilityId"), "el", s.get("matkElement"));
            var a = !1;
            r.equals(i) && s.get("absorbHpFactor") && (a = !0);
            var f = !!s.get("absorbHpFactor"),
                l = r.getAttachElementAddOnFactor(o, s),
                c = this.__calculateDamageByMagic({
                    matk: r.get("matk"),
                    mnd: r.get("mnd"),
                    mdef: i.get("mdef"),
                    baseMdef: u.mdef,
                    exerciseType: s.get("exerciseType"),
                    targetRange: s.get("targetRange"),
                    targetNum: t.targetNum,
                    element: o,
                    matkElementMap: r.get("matkElementMap"),
                    defAttributeMap: i.get("defAttributeMap"),
                    abilityDamageFactor: s.get("damageFactor"),
                    abilityMinDamageFactor: s.get("minDamageFactor"),
                    abilityAbsorbHpFactor: s.get("absorbHpFactor"),
                    isAbsorbable: f,
                    isInDefense: i.isInDefense(),
                    isHittable: i.isHittable(s.get("exerciseType"), n),
                    forceMiss: a,
                    defIgnored: t.defIgnored,
                    defBoostIgnored: t.defBoostIgnored,
                    receiverType: i.isBuddy() ? "buddy" : "enemy",
                    matkExponentialFactor: t.matkExponentialFactor,
                    attachElementCoefficient: l
                });
            return c.ability = t.ability, c.executer = r, c.receiver = i, f && c.absorbHpDamage ? (c.absorber = r, c.absorbHp = _.extend({
                damage: c.absorbHpDamage
            }, this.calculateHp(c.absorber, c.absorbHpDamage))) : c.absorber = void 0, _.extend(c, this.calculateHp(i, c.damage)), c
        },
        __calculateDamageByMagic: function(n) {
            n = e.option({
                matk: 0,
                mnd: 0,
                mdef: 0,
                baseMdef: 0,
                exerciseType: 0,
                element: "",
                matkElementMap: {},
                defAttributeMap: {},
                targetNum: 1,
                targetRange: t.Conf.TARGET_RANGE.SINGLE,
                abilityDamageFactor: 100,
                abilityMinDamageFactor: 0,
                abilityAbsorbHpFactor: 0,
                isInDefense: !1,
                isHittable: !0,
                forceMiss: !1,
                defIgnored: !1,
                defBoostIgnored: !1,
                isAbsorbable: !1,
                receiverType: void 0,
                matkExponentialFactor: void 0,
                attachElementCoefficient: 100
            }, n);
            var r = t.Config.getInstance().get("DamageCalculator", "DAMAGE"),
                i = {
                    damage: 0,
                    canHit: !1
                };
            if (!this._lotCanMagicHit(n)) return i;
            var s = n.matkExponentialFactor ? Math.pow(n.matk, n.matkExponentialFactor / 100) : n.matk,
                o = n.defIgnored ? 1 : n.defBoostIgnored ? n.baseMdef : n.mdef,
                u = n.mnd,
                a = n.abilityDamageFactor,
                f = n.abilityMinDamageFactor,
                l = r.minDamage,
                c = r.magicBasePower,
                h = r.ratioMagicDefence,
                p = r.maxBasic,
                d = r.ratioPower,
                v = r.ratioPowerDefence,
                m = r.ratioCoefficient,
                g = r.maxRatio,
                y = r.randCoeffiecient,
                b = this._calculateCoefficientByElement(n),
                w = b.coefficient,
                E = this._calculateCoefficientByNumber(n),
                S = this._calculateCoefficientByDefense(n),
                x = n.matkElementMap[n.element] || 100,
                T = n.attachElementCoefficient,
                N = n.receiverType,
                C = 0;
            switch (n.exerciseType) {
                case t.Conf.EXERCISE_TYPE.BLACK_MAGIC:
                case t.Conf.EXERCISE_TYPE.BLUE_MAGIC:
                case t.Conf.EXERCISE_TYPE.INBORN:
                case t.Conf.EXERCISE_TYPE.NINJA:
                    C = N === "buddy" ? Math.floor(l + _.min([Math.pow(s, c), p]) * _.min([Math.pow(s / Math.pow(o, h), v) * m, g]) * a / 100) : Math.floor(l + _.min([Math.pow(s, c), p]) * _.min([Math.pow(s / o, d) * m, g]) * a / 100);
                    break;
                case t.Conf.EXERCISE_TYPE.WHITE_MAGIC:
                    C = N === "buddy" ? Math.floor(l + _.min([Math.pow(u, c), p]) * _.min([Math.pow(u / Math.pow(o, h), v) * m, g]) * a / 100) : Math.floor(l + _.min([Math.pow(u, c), p]) * _.min([Math.pow(u / o, d) * m, g]) * a / 100);
                    break;
                case t.Conf.EXERCISE_TYPE.SUMMON:
                    C = Math.floor(l + _.min([Math.pow(s, c), p]) * _.min([Math.pow(s / o, d) * m, g]) * a / 100), d = r.summonRatioPower, m = r.summonRatioCoefficient, C = _.max([C, Math.floor(l + _.min([Math.pow(1 / o, d) * m, g]) * f)]);
                    break;
                default:
                    throw new Error("invalid exercisetype.t=" + n.exerciseType)
            }
            var k = this.getAllowableDamage(Math.floor(C * (w / 10) * (E / 100) * (S / 10) * ((100 + (x - 100) + (T - 100)) / 100) * (1 + y * Math.pow(e.randomInt(100, 0), 2) / 1e6))),
                L = 0;
            return n.isAbsorbable && (L = this.getAllowableDamage(Math.min(-1 * Math.floor(k * n.abilityAbsorbHpFactor / 100), -1))), FF.logger.info("dmg", k, "matk", s, "mdef", o, "basicMagicalDamage", C, "damageFactor", a, "minDamage", l, "basePower", c, "ratioMagicDefence", h, "receiverType", N, "maxBasic", p, "ratioPower", d, "ratioPowerDefence", v, "ratioCoefficient", m, "maxRatio", g, "elementCoefficient", w, "multipleTargetCoefficient", E, "defenseCoefficient", S, "randCoeffiecient", y, "minDamageFactor", f, "matkElementCoefficient", x, "absorbHpDamage", L), i.damage = k, i.absorbHpDamage = L, i.canHit = !0, i.isRecovery = k < 0, i.isDamage = !0, i.isWeakness = b.isWeakness, i.advantage = b.advantage, i.element = n.element, i
        },
        _calculateHealValue: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {}
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability;
            FF.logger.info("HEAL", n.get("dispName"), n.get("hp"), "->", r.get("dispName"), r.get("hp"));
            var s = this.__calculateHealValue({
                mnd: n.get("mnd"),
                abilityFactor: i.get("factor"),
                isDead: r.isDead()
            });
            return s.ability = i, s.executer = n, s.receiver = r, _.extend(s, this.calculateHp(r, s.damage)), s
        },
        __calculateHealValue: function(n) {
            n = e.option({
                mnd: 0,
                abilityFactor: 1,
                isDead: !1
            }, n);
            var r = t.Config.getInstance().get("DamageCalculator", "HEAL"),
                i = r.a,
                s = r.b,
                o = n.mnd,
                u = n.abilityFactor;
            if (n.isDead) throw new Error("can not heal dead actor");
            var a = this.getAllowableDamage(-1 * Math.round(u * (i + Math.pow(o, .75) / 256 * s)));
            FF.logger.info("heal", a, "mnd", o, "factor", u, "a", i, "b", s);
            var f = {
                canHit: !0,
                isRecovery: !0,
                damage: a
            };
            return f
        },
        _calculateHealDeath: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                hitRate: 0,
                hpFactor: 0
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability,
                s = t.hitRate,
                o = t.hpFactor,
                u = r.get("maxHp");
            FF.logger.info("HEAL_DEATH", n.get("dispName"), n.get("hp"), "->", r.get("dispName"), r.get("hp"));
            var a = {
                executer: n,
                receiver: r,
                ability: i,
                canHit: !1,
                isRecovery: !0,
                damage: 0,
                healDeath: !0
            };
            if (r.isEnemy()) return a;
            if (!r.canHealDeath()) return a;
            if (!e.lotByFraction(s)) return a;
            var f = this.getAllowableDamage(-1 * Math.floor(u * o / 100));
            return a.canHit = !0, a.damage = f, _.extend(a, this.calculateHp(r, a.damage)), FF.logger.info("heal", f, "hpfactor", o, "can", a.canHit, "rate", s), a
        },
        _calculateDamageByFraction: function(t) {
            var n = t.type;
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                statusAilmentsId: 0,
                statusAilmentsFactor: 0,
                numerator: 0,
                forceHitWithoutSa: !1
            }, t);
            var r = t.executer,
                i = t.target.receiver,
                s = t.ability,
                o = s.get("damageRate") || 0,
                u = s.get("hitRate") || 0,
                a = i.get("defAttributeMap") || {},
                f = t.statusAilmentsId,
                l = t.statusAilmentsFactor,
                c = t.numerator,
                h = t.forceHitWithoutSa,
                p = i.isHittable(s.get("exerciseType"), n);
            FF.logger.info("FRACTION", r.get("dispName"), r.get("hp"), "->", i.get("dispName"), i.get("hp"), "id", s.get("abilityId"));
            var d = {
                damage: 0,
                canHit: !1,
                isCritical: !1,
                ability: s,
                executer: r,
                receiver: i,
                isDamage: !0
            };
            if (!p) return d;
            if (!h) {
                var v = {};
                v[f] = l;
                var m = this._calculateStatusAilments({
                    executer: r,
                    target: t.target,
                    atkStatusAilments: v,
                    ability: s
                });
                if (!m.canHit) return d.isNoeffect = m.isNoeffect, d
            }
            var g = this.getAllowableDamage(Math.floor(c * o / 100));
            return FF.logger.info("dmg", g, "numerator", c, "dmgrate", o, "said", f, "safactor", l), d.damage = g, d.canHit = !0, _.extend(d, this.calculateHp(i, d.damage)), d
        },
        _calculateDamageBySelfDestruction: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                statusAilmentsId: 0,
                statusAilmentsFactor: 0
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability,
                s = n.get("hp"),
                o = i.get("damageFactor") || 0,
                u = r.get("defAttributeMap") || {};
            FF.logger.info("SELF_DESTRUCTION", n.get("dispName"), n.get("hp"), "->", r.get("dispName"), r.get("hp"), "id", i.get("abilityId"));
            var a = {
                    damage: 0,
                    canHit: !0,
                    isCritical: !1,
                    ability: i,
                    executer: n,
                    receiver: r,
                    isDamage: !0
                },
                f = this.getAllowableDamage(Math.floor(s * o / 100));
            return FF.logger.info("dmg", f, "executerHp", s, "damageFactor", o), a.damage = f, _.extend(a, this.calculateHp(r, a.damage)), a
        },
        _calculateFixedDamage: function(t) {
            var n = t.type;
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                fixedDamage: 0,
                targetCount: 1,
                ignoreTargetCountDivision: !1
            }, t);
            var r = t.executer,
                i = t.target.receiver,
                s = t.ability,
                o = t.fixedDamage,
                u = t.targetCount,
                a = t.ignoreTargetCountDivision,
                f = i.isHittable(s.get("exerciseType"), n);
            FF.logger.info("FIXED_DAMAGE", r.get("dispName"), r.get("hp"), "->", i.get("dispName"), i.get("hp"), "id", s.get("abilityId"));
            var l = {
                damage: 0,
                canHit: !1,
                isCritical: !1,
                ability: s,
                executer: r,
                receiver: i,
                isDamage: !0
            };
            if (!f) return l;
            var c = o;
            a || (c = Math.floor(o / u));
            var h = this.getAllowableDamage(c);
            return FF.logger.info("dmg", h, "fixedDamage", o, "targetCount", u), l.damage = h, l.canHit = !0, _.extend(l, this.calculateHp(i, l.damage)), l
        },
        _calculateDamageByDamagedHp: function(t) {
            var r = t.type;
            t = e.option({
                executer: {},
                target: {},
                ability: {}
            }, t);
            var i = t.executer,
                s = t.target.receiver,
                o = t.ability,
                u = o.get("damageFactor") || 0,
                a = i.get("maxHp"),
                f = i.get("hp"),
                l = s.isHittable(o.get("exerciseType"), r),
                c = o.get("atkType") === n.ATK_TYPE.INDIRECT || i.get("atkType") === n.ATK_TYPE.INDIRECT ? n.ATK_TYPE.INDIRECT : n.ATK_TYPE.DIRECT;
            FF.logger.info("DAMAGED_HP", i.get("dispName"), i.get("hp"), "->", s.get("dispName"), s.get("hp"), "id", o.get("abilityId"));
            var h = {
                damage: 0,
                canHit: !1,
                isCritical: !1,
                ability: o,
                executer: i,
                receiver: s,
                isDamage: !0,
                atkType: c
            };
            if (!l) return h;
            var p = this.getAllowableDamage(Math.floor((a - f) * u / 100));
            return FF.logger.info("dmg", p, "maxHP", a, "currHP", f, "dmgFactor", u), h.damage = p, h.canHit = !0, _.extend(h, this.calculateHp(s, h.damage)), h
        },
        _lotCanMagicHit: function(e) {
            return e.forceMiss ? (FF.logger.info("HIT_RATE", "FORCE_MISS"), !1) : e.isHittable ? !0 : (FF.logger.info("HIT_RATE", "HITTABLE"), !1)
        },
        _lotCanAttackHit: function(n) {
            var r = t.Config.getInstance().get("DamageCalculator", "ACC");
            n = e.option({
                acc: 0,
                eva: 0,
                isDead: !1,
                isHittable: !0,
                forceHit: !1,
                forceMiss: !1,
                isBlinded: !1
            }, n);
            if (n.isDead) throw new Error("can not attack to dead actor");
            if (!n.isHittable) return FF.logger.info("HIT_RATE", "HITTABLE"), !1;
            if (n.forceMiss) return FF.logger.info("HIT_RATE", "FORCE_MISS"), !1;
            if (n.forceHit) return FF.logger.info("HIT_RATE", "FORCE_HIT"), !0;
            var i = n.acc,
                s = n.eva,
                o = r.a,
                u = r.b,
                a = r.c,
                f = r.d,
                l = n.isBlinded ? r.blinded : r.e,
                c = r.f,
                h = Math.floor(_.max([_.min([(o * i - u * s) / a + f, 100]) * (l / 100), c])),
                p = e.lotByFraction(h);
            return FF.logger.info("HIT_RATE", h, "canHit", p, "acc", i, "eva", s, "a", o, "b", u, "c", a, "d", f, "e", l, "f", c), p
        },
        _lotIsAttackCritical: function(t) {
            if (t.forceCritical) return FF.logger.info("FORCE_CRITICAL"), !0;
            var n = t.critical || 0;
            return e.lotByFraction(n)
        },
        _calculateCoefficientByNumber: function(e) {
            return e.targetRange === t.Conf.TARGET_RANGE.ALL ? 100 : _.max([100 - 10 * (e.targetNum - 1), 1])
        },
        _calculateCoefficientByElement: function(r) {
            r = e.option({
                element: "",
                defAttributeMap: {}
            }, r);
            var i = t.Config.getInstance().get("DamageCalculator", "ELEMENT_ADVANTAGE"),
                s = t.Config.getInstance().get("DamageCalculator", "ELEMENT_ADVANTAGE_DEFAULT"),
                o = r.defAttributeMap,
                u = o[r.element],
                a = i[u] || s,
                f = a[0],
                l = a[1],
                c = {
                    advantage: f,
                    coefficient: l,
                    isWeakness: f === n.ADVANTAGE.WEAK,
                    isVoid: f === n.ADVANTAGE.VOID,
                    isHalf: f === n.ADVANTAGE.HALF,
                    isAbsorption: f === n.ADVANTAGE.ABSORPTION
                };
            return FF.logger.info("element", "atk", r.element, "def", o, "ret", c), c
        },
        _calculateCoefficientByRow: function(r) {
            r = e.option({
                executerRow: n.ROW_TYPE.FRONT,
                receiverRow: n.ROW_TYPE.FRONT,
                atkType: n.ATK_TYPE.DIRECT
            }, r);
            var i = t.Config.getInstance().get("DamageCalculator", "ROW");
            return r.atkType === n.ATK_TYPE.INDIRECT ? i.DEFAULT : i[r.executerRow][r.receiverRow]
        },
        _calculateCoefficientByDefense: function(n) {
            n = e.option({
                isInDefense: !1
            }, n);
            var r = t.Config.getInstance().get("DamageCalculator", "DAMAGE", "defenseCoefficient");
            return r[n.isInDefense ? "defense" : "default"]
        },
        calculatePotion: function(t) {
            t = e.option({
                item: void 0,
                receiver: void 0
            }, t), FF.logger.info("POTION", t.item);
            var n = this._calculatePotion({
                type: t.item.type,
                maxHp: t.receiver.get("maxHp")
            });
            return n.receiver = t.receiver, _.extend(n, this.calculateHp(t.receiver, n.damage)), n
        },
        _calculatePotion: function(n) {
            n = e.option({
                type: void 0,
                maxHp: 0
            }, n);
            var r = n.type,
                i = n.maxHp,
                s = t.Config.getInstance().get("DamageCalculator", "DROP_ITEM"),
                o = s[r] || 0,
                u = this.getAllowableDamage(-1 * Math.round(i * o / 100));
            return FF.logger.info("heal", u, "type", r, "maxHp", i), {
                canHit: !0,
                isRecovery: !0,
                damage: u
            }
        },
        _calculateAbilityPanel: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                abilityPanel: {},
                damageFactor: 0,
                isDecrease: !0,
                hitRate: 0,
                isRemainingBase: !1
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability,
                s = t.abilityPanel,
                o = t.damageFactor,
                u = t.isDecrease,
                a = t.hitRate,
                f = t.isRemainingBase,
                l = {
                    damage: 0,
                    canHit: !1,
                    ability: i,
                    executer: n,
                    receiver: r,
                    abilityPanel: s
                };
            return e.lotByFraction(a) ? (_.extend(l, this.__calculateAbilityPanel({
                remainNum: t.abilityPanel.get("remainNum"),
                maxNum: t.abilityPanel.get("maxNum"),
                damageFactor: o,
                isDecrease: u,
                isInfinity: t.abilityPanel.isInfinity(),
                isRemainingBase: f
            })), _.extend(l, this.calculateAbilityPanelNum(l.damage, t.abilityPanel)), l) : l
        },
        calculateEther: function(n) {
            n = e.option({
                item: void 0,
                receiver: void 0,
                abilityPanel: void 0
            }, n);
            var r = n.receiver;
            FF.logger.info("ETHER", n.item, n.abilityPanel.get("abilityId"));
            var i = t.Config.getInstance().get("DamageCalculator", "DROP_ITEM"),
                s = i[n.item.type] || 0,
                o = this.__calculateAbilityPanel({
                    remainNum: n.abilityPanel.get("remainNum"),
                    maxNum: n.abilityPanel.get("maxNum"),
                    damageFactor: s,
                    isDecrease: !1,
                    isInfinity: n.abilityPanel.isInfinity(),
                    isRemainingBase: !1
                });
            return o.abilityPanel = n.abilityPanel, o.receiver = r, _.extend(o, this.calculateAbilityPanelNum(o.damage, n.abilityPanel)), o
        },
        __calculateAbilityPanel: function(t) {
            t = e.option({
                remainNum: 0,
                maxNum: 0,
                damageFactor: 0,
                isDecrease: !1,
                isInfinity: !1,
                isRemainingBase: !1
            }, t);
            var n = {
                canHit: !0,
                isAbilityPanel: !0,
                isDecrease: t.isDecrease,
                damage: 0,
                prev: t.remainNum,
                curr: t.remainNum,
                max: t.maxNum
            };
            if (t.isInfinity) return n;
            var r = t.remainNum,
                i = t.maxNum,
                s = t.damageFactor,
                o = t.isDecrease,
                u = o ? 1 : -1,
                a = t.isRemainingBase,
                f = a ? r : i,
                l = u * Math.ceil(f * s / 100);
            return n.damage = l, FF.logger.info("abilityPanel", l, "maxNum", i, "remainNum", r, "damageFactor", s, "isDecrease", o, "isRemainingBase", a, n), n
        },
        _calculateEntrustingSsPoint: function(n) {
            n = e.option({
                executer: {},
                target: {},
                ability: {}
            }, n);
            var r = n.executer,
                i = n.target.receiver,
                s = {
                    isSsPoint: !0,
                    ability: n.ability,
                    executer: r,
                    receiver: i
                };
            if (r.isEnemy() || r.isEnemy()) return s.canHit = !1, s;
            if (r.equals(i)) return s.canHit = !1, s;
            var o = t.Config.getInstance().get("SoulStrike", "maxSsPoint"),
                u = r.getSoulStrike(),
                a = i.getSoulStrike(),
                f = 0;
            return u.get("point") + a.get("point") < o ? f = u.get("point") : f = o - a.get("point"), s.canHit = f > 0 ? !0 : !1, s.ssPoint = f, s
        },
        _calculatePoison: function(t) {
            t = e.option({
                executer: {},
                receiver: {},
                ability: {}
            }, t);
            var n = t.executer,
                r = t.receiver,
                i = t.ability.get("damageFactor") || 0,
                s = this.getAllowableDamage(Math.round(n.get("maxHp") * i / 256));
            FF.logger.info("POISON/SAP", n.get("dispName"), n.get("hp"), "factor", i, "dmb", s);
            var o = {
                canHit: !0,
                damage: s,
                ability: t.ability,
                executer: n,
                receiver: r
            };
            return _.extend(o, this.calculateHp(r, o.damage)), o
        },
        _calculateRegen: function(t) {
            t = e.option({
                executer: {},
                receiver: {},
                ability: {}
            }, t);
            var n = t.executer,
                r = t.receiver,
                i = t.ability.get("damageFactor") || 0,
                s = this.getAllowableDamage(-1 * Math.round(n.get("maxHp") * i / 100));
            FF.logger.info("REGEN", n.get("dispName"), n.get("hp"), "dmg", s);
            var o = {
                canHit: !0,
                damage: s,
                ability: t.ability,
                executer: n,
                receiver: r
            };
            return _.extend(o, this.calculateHp(r, o.damage)), o
        },
        _calculatePhysicalStatusAilments: function(e) {
            var t = this._calculateStatusAilments(e),
                r = e.executer,
                i = e.ability;
            return t.atkType = i.get("atkType") === n.ATK_TYPE.INDIRECT || r.get("atkType") === n.ATK_TYPE.INDIRECT ? n.ATK_TYPE.INDIRECT : n.ATK_TYPE.DIRECT, t
        },
        _calculateStatusAilments: function(n) {
            var r = n.type;
            n = e.option({
                executer: {},
                target: {},
                atkStatusAilments: {},
                statusAilmentsOptions: {},
                ability: {},
                forceHit: !1,
                forceMiss: !1,
                damageObject: void 0
            }, n);
            var i = n.executer,
                s = n.target.receiver,
                o = n.ability;
            FF.logger.info("LOT_STATUS_AILMENTS", i.get("dispName"), "->", s.get("dispName"), "sa", n.atkStatusAilments);
            var u = this._lotCanAddStatusAilments({
                    atkStatusAilments: n.atkStatusAilments,
                    defAttributeMap: s.get("defAttributeMap"),
                    receiverType: s.isBuddy() ? "buddy" : "enemy",
                    forceHit: n.forceHit,
                    forceMiss: n.forceMiss,
                    isHittable: s.isHittable(o.get("exerciseType"), r)
                }),
                a = n.damageObject || t.util.DamageCalculator.makeDamageObject(i, s, o);
            return n.damageObject ? (a.statusAilments = u.statusAilments, a.appendedStatusAilments = u) : _.extend(a, u), a.statusAilmentsOptions = n.statusAilmentsOptions, a
        },
        _lotCanAddStatusAilments: function(n) {
            n = e.option({
                atkStatusAilments: {},
                defAttributeMap: {},
                receiverType: void 0,
                forceHit: !1,
                forceMiss: !1,
                isHittable: !0
            }, n);
            var r = t.Config.getInstance().get("DamageCalculator", "STATUS_AILMENTS"),
                i = r.a,
                s = r.b,
                o = {
                    hasAtkStatusAilments: _.size(n.atkStatusAilments) > 0,
                    canHit: !1,
                    isNoeffect: !1,
                    statusAilments: []
                };
            if (!!n.isHittable && !n.forceMiss)
                if (n.forceHit && n.receiverType === "enemy") _.each(n.atkStatusAilments, function(e, t) {
                    var r = n.defAttributeMap[t];
                    r ? o.isNoeffect = !0 : (FF.logger.info("STATUS_AILMENTS", "forceHit enemy"), o.statusAilments.push(t))
                });
                else if (n.forceHit && n.receiverType === "buddy") _.each(n.atkStatusAilments, function(e, t) {
                FF.logger.info("STATUS_AILMENTS", "forceHit buddy"), o.statusAilments.push(t)
            });
            else if (n.receiverType === "enemy") _.each(n.atkStatusAilments, function(t, r) {
                var i = !1,
                    s = n.defAttributeMap[r];
                s ? o.isNoeffect = !0 : i = e.lotByFraction(t), FF.logger.info("STATUS_AILMENTS", "can", i, "lot", t, "def", s), i && o.statusAilments.push(r)
            });
            else {
                if (n.receiverType !== "buddy") throw new Error("INVALID receiverType.t=" + n.receiverType);
                _.each(n.atkStatusAilments, function(t, r) {
                    var u = n.defAttributeMap[r] || 1,
                        f = i + t / u * s,
                        l = e.lotByFraction(f);
                    FF.logger.info("STATUS_AILMENTS", "can", l, "lot", f, "a", i, "b", s, "atk", t, "def", u), l && o.statusAilments.push(r)
                })
            }
            return o.statusAilments = _.uniq(o.statusAilments), o.statusAilments.length && (o.canHit = !0, o.isNoeffect = !1), o
        },
        _calculateHpBarter: function(t) {
            t = e.option({
                executer: {},
                receiver: {},
                ability: {}
            }, t);
            var n = t.executer,
                r = t.ability.get("barterRate"),
                i = n.get("maxHp"),
                s = n.get("hp"),
                o = Math.floor(i * r / 1e3),
                u = this.getAllowableDamage(o < s ? o : s - 1);
            return FF.logger.info("BARTER", "dmg", u, "rate", r), {
                canHit: !0,
                damage: u,
                ability: t.ability,
                executer: t.executer,
                receiver: t.receiver
            }
        },
        _calculateHealSa: function(n) {
            n = e.option({
                executer: {},
                target: {},
                ability: {},
                statusAilmentsIds: [],
                hitRate: 0
            }, n);
            var r = n.target,
                i = n.statusAilmentsIds,
                s = e.lotByFraction(n.hitRate),
                o = t.util.DamageCalculator.makeDamageObject(n.executer, r.receiver, n.ability, {
                    unsetStatusAilments: s ? i : void 0,
                    canHit: s
                });
            return FF.logger.info("HEAL_SA", "can", s, "ids", i, "rate", n.hitRate), o
        },
        _calculateHealByFractionValue: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                numerator: 0
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability,
                s = t.numerator;
            FF.logger.info("FRACTION_HEAL", n.get("dispName"), n.get("hp"), "->", r.get("dispName"), r.get("hp"));
            var o = {
                canHit: !0,
                isRecovery: !0,
                damage: this.getAllowableDamage(-1 * Math.floor(s * i.get("factor") / 100))
            };
            return o.ability = i, o.executer = n, o.receiver = r, _.extend(o, this.calculateHp(r, o.damage)), o
        },
        getAllowableDamage: function(e) {
            if (_.isNaN(e) || !_.isFinite(e) || !_.isNumber(e)) return 0;
            var n = t.Config.getInstance().get("DamageCalculator", "DAMAGE", "damageThreshold"),
                r = -n;
            return Math.max(Math.min(e, n), r)
        },
        ___getAtkForValiantAttack: function(e, t) {
            var n;
            return .3 < e ? n = t / .9 + (t / .9 * 1.07 - t / .9) * ((1 - e) / .7) : .2 < e && e <= .3 ? n = t / .9 * 1.07 + (t / .9 * 1.13 - t / .9 * 1.07) * ((1 - e - .7) / .1) : 0 < e && e <= .2 ? n = t / .9 * 1.13 + (t / .9 * 1.5 - t / .9 * 1.13) * Math.pow((1 - e - .8) / .2, 1.5) : n = t, _.min([n, t * 1.4])
        },
        __getAbilityDamageFactor: function(e, t) {
            if (e.has("targetSaIdsByAttackDependedOnSa")) {
                if (!e.has("damageFactorForMatchedSa")) throw new Error("no damageFactorForMatchedSa");
                if (!e.has("damageFactorForMismatchedSa")) throw new Error("no damageFactorForMismatchedSa");
                var n = e.get("targetSaIdsByAttackDependedOnSa"),
                    r = _.some(n, function(e) {
                        return t.statusAilments.has(e) ? !0 : !1
                    });
                return r ? e.get("damageFactorForMatchedSa") : e.get("damageFactorForMismatchedSa")
            }
            return e.get("damageFactor")
        }
    }
}), define("scenes/battle/util/DamageCalculateHook", ["lib/ClassBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = e.extend({
            shouldHook: function(e, t) {
                return !1
            },
            postCalculate: function(e, t) {
                throw new Error("override plz")
            }
        }),
        i = {};
    i[n.CALC_HOOK.REFRECTOR] = r.extend({
        shouldHook: function(e, t) {
            return !0
        },
        postCalculate: function(e, t) {
            var n = e && e.target && e.target.reflector;
            return t.reflector = n ? e.target.reflector : void 0, t
        }
    }), i[n.CALC_HOOK.COUNTER_ENABLE] = r.extend({
        shouldHook: function(e, t) {
            return !0
        },
        postCalculate: function(e, t) {
            var n = _.isFunction(e.ability.get) && !!e.ability.get("counterEnable");
            return t.counterEnable = n, t
        }
    }), i[n.CALC_HOOK.MATERIA] = r.extend({
        shouldHook: function(e, t) {
            return t.type === n.CALC_TYPE.STATUS_AILMENTS ? !1 : !0
        },
        postCalculate: function(e, n) {
            var r = n.executer;
            return r && r.materiaHolder.notify(t.Conf.MATERIA_NOTIFY_TYPE.DAMAGE_HOOK, {
                data: e,
                result: n
            }), n
        }
    }), i[n.CALC_HOOK.RECEIVER_SA] = r.extend({
        shouldHook: function() {
            return !0
        },
        postCalculate: function(e, t) {
            return t.receiver.statusAilments.processForDamageCalculateHook(t), t
        }
    }), i[n.CALC_HOOK.BRK_DEF] = r.extend({
        shouldHook: function(e, t) {
            return t.type !== n.CALC_TYPE.STATUS_AILMENTS && t.type !== n.CALC_TYPE.PHYSICAL_STATUS_AILMENTS ? !1 : t.statusAilments ? t.statusAilments.length < 1 ? !1 : !0 : !1
        },
        postCalculate: function(e, t) {
            var n = this.detectBreakableParamsFromResult(t),
                r = void 0,
                i = {};
            if (n.length > 0) {
                var s = this.makeReceiverBrkDefInfos(t.receiver);
                _.each(n, function(e) {
                    var t = s[e];
                    t && (r = t[0], i[e] = t[1])
                })
            }
            r && (t.advantage = r);
            var o = t.statusAilmentsOptions || {};
            return o.brkDefRates = i, t.statusAilmentsOptions = o, t
        },
        makeReceiverBrkDefInfos: function(e) {
            var n = e.get("defAttributeMap"),
                r = t.Config.getInstance().get("BrkDefConfig"),
                i = {};
            return _.each(n, function(e, t) {
                var n = r.PARAM_NAME[t];
                if (!n) return;
                var s = r.ADVANTAGE[e];
                if (!s) throw new Error("Invalid brkDefId: " + e);
                i[n] = s
            }), i
        },
        detectBreakableParamsFromResult: function(e) {
            var n = this,
                r = e.statusAilments || [],
                i = e.statusAilmentsOptions || {},
                s = [];
            return _.each(r, function(e) {
                var r = t.StatusAilmentsConfig.getParam(e),
                    o = n.detectBreakableParams(r, i);
                s = s.concat(o)
            }), _.uniq(s)
        },
        detectBreakableParams: function(e, t) {
            if (!e.boosts) return [];
            var n = [];
            return _.each(e.boosts, function(e) {
                if (_.isUndefined(e.rate)) return;
                if (e.rate < 0) n.push(e.paramName);
                else if (e.rate === 0) {
                    var r = t.boost && t.boost.rate ? t.boost.rate : 0;
                    r < 0 && n.push(e.paramName)
                }
            }), n
        }
    }), i[n.CALC_HOOK.FLIGHT_ATTACK] = r.extend({
        shouldHook: function(e, t) {
            var n = e.ability;
            if (n.get("isFlightAttack")) return !0;
            var r = [20080001, 20590001, 20830001, 20810005, 20830003];
            return _.contains(r, n.get("abilityId")) ? !0 : !1
        },
        postCalculate: function(e, t) {
            return _.extend(t, {
                isFlightAttack: !0
            }), t
        }
    }), i[n.CALC_HOOK.UNDEAD_CURE] = r.extend({
        shouldHook: function(e, r) {
            if (n.CALC_TYPE.HEAL !== e.type && n.CALC_TYPE.FRACTION_HEAL !== e.type) return !1;
            var i = e.target.receiver;
            if (!i.isUndeadBreed()) return !1;
            var s = e.ability;
            return s.get("exerciseType") !== t.Conf.EXERCISE_TYPE.WHITE_MAGIC ? !1 : !0
        },
        postCalculate: function(e, r) {
            var i = t.util.DamageCalculator.calculate(_.extend({}, e, {
                type: n.CALC_TYPE.MAGIC
            }));
            return i.counterEnable = !0, i
        }
    }), i[n.CALC_HOOK.UNDEAD_RAISE] = r.extend({
        shouldHook: function(e, r) {
            if (n.CALC_TYPE.HEAL_DEATH !== e.type) return !1;
            var i = e.target.receiver;
            if (!i.isUndeadBreed()) return !1;
            var s = e.ability;
            return s.get("exerciseType") !== t.Conf.EXERCISE_TYPE.WHITE_MAGIC ? !1 : !0
        },
        postCalculate: function(e, r) {
            var i = {};
            i[t.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH] = 1;
            var s = t.util.DamageCalculator.calculate(_.extend({}, e, {
                type: n.CALC_TYPE.STATUS_AILMENTS,
                atkStatusAilments: i,
                forceHit: !0
            }));
            return s.counterEnable = !0, s
        }
    }), i[n.CALC_HOOK.SEALING] = r.extend({
        targetStatusAilmentsIds: [t.Conf.STATUS_AILMENTS_TYPE.RUNIC, t.Conf.STATUS_AILMENTS_TYPE.GRAND_CROSS],
        shouldHook: function(e, t) {
            if (t.type === n.CALC_TYPE.ABILITY_PANEL) return !1;
            if (t.executer.isBuddy()) return !1;
            var r = e.ability.get("exerciseType");
            return t.reflector && this._shouldHook(r, t.reflector) ? !0 : this._shouldHook(r, t.receiver) ? !0 : !1
        },
        _shouldHook: function(e, t) {
            return t.isBuddy() ? _.some(this.targetStatusAilmentsIds, function(n) {
                if (!t.statusAilments.has(n)) return !1;
                var r = t.statusAilments.getSubstitutesById(n);
                return r && _.contains(r, e) ? !0 : !1
            }) : !1
        },
        postCalculate: function(e, r) {
            var i = void 0,
                s = e.ability.get("exerciseType");
            e.target.reflector && this._shouldHook(s, e.target.reflector) ? i = e.target.reflector : i = e.target.receiver;
            var o = void 0;
            o = t.util.PanelTargeting.search(i, {
                receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                remainNum: t.Conf.PANEL_TARGET_REMAIN_NUM.ANY,
                defaultReceptorId: t.Conf.RECEPTOR.PANEL_ATTACK
            });
            var u = t.util.DamageCalculator.calculate(_.extend({}, e, {
                type: n.CALC_TYPE.ABILITY_PANEL,
                target: {
                    receiver: i
                },
                abilityPanel: o,
                damageFactor: 1,
                isDecrease: !1,
                hitRate: 100
            }));
            return u
        }
    }), i[n.CALC_HOOK.PYRAMID] = r.extend({
        shouldHook: function(e, r) {
            var i = r.receiver;
            return i.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.PYRAMID) ? !r.canHit && r.damage >= 0 ? !1 : r.type === n.CALC_TYPE.HEAL_SA ? !1 : r.type === n.CALC_TYPE.STATUS_AILMENTS ? !1 : !0 : !1
        },
        postCalculate: function(e, r) {
            var i = r.type,
                s = e.ability.get("exerciseType");
            if (i === n.CALC_TYPE.ATTACK && s === t.Conf.EXERCISE_TYPE.PHYSICAL) {
                var o = t.util.DamageCalculator.calculate(_.extend({}, e, {
                    type: n.CALC_TYPE.HEAL_SA,
                    hitRate: 100,
                    statusAilmentsIds: [t.Conf.STATUS_AILMENTS_TYPE.PYRAMID]
                }));
                return _.extend(o, {
                    damage: 0,
                    fakeDamage: r.damage,
                    maxHp: r.maxHp,
                    currHp: r.prevHp,
                    prevHp: r.prevHp,
                    isCritical: r.isCritical
                }), o
            }
            return _.extend(r, {
                damage: 0,
                canHit: !1
            })
        }
    }), i[n.CALC_HOOK.FARAWAY] = r.extend({
        shouldHook: function(e, r) {
            var i = [n.CALC_TYPE.ATTACK, n.CALC_TYPE.DAMAGED_HP, n.CALC_TYPE.PHYSICAL_STATUS_AILMENTS];
            if (!_.contains(i, r.type)) return !1;
            if (e.ability.get("exerciseType") !== t.Conf.EXERCISE_TYPE.PHYSICAL) return !1;
            if (r.atkType !== n.ATK_TYPE.DIRECT) return !1;
            var s = r.receiver;
            return s.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.FARAWAY) ? !0 : !1
        },
        postCalculate: function(e, t) {
            return _.extend(t, e, {
                damage: 0,
                canHit: !1,
                statusAilments: [],
                unsetStatusAilments: [],
                isFaraway: !0
            }), t
        }
    }), i[n.CALC_HOOK.WATER_BALL] = r.extend({
        shouldHook: function(e, r) {
            var i = r.receiver;
            return i.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.WATER_BALL) ? i.isOpponent(e.executer) ? !1 : !r.canHit && r.damage >= 0 ? !1 : r.type === n.CALC_TYPE.HEAL_SA ? !1 : r.type === n.CALC_TYPE.STATUS_AILMENTS ? !1 : r.type === n.CALC_TYPE.POISON ? !1 : !0 : !1
        },
        postCalculate: function(e, r) {
            var i = r.type,
                s = e.ability.get("exerciseType"),
                o = e.ability.get("matkElement"),
                u = [t.Conf.EXERCISE_TYPE.WHITE_MAGIC, t.Conf.EXERCISE_TYPE.BLACK_MAGIC, t.Conf.EXERCISE_TYPE.BLUE_MAGIC];
            if (r.damage > 0 && _.contains(u, s) && i === n.CALC_TYPE.MAGIC && o !== n.ELEMENT_TYPE.POISON) {
                var a = t.util.DamageCalculator.calculate(_.extend({}, e, {
                    type: n.CALC_TYPE.HEAL_SA,
                    hitRate: 100,
                    statusAilmentsIds: [t.Conf.STATUS_AILMENTS_TYPE.WATER_BALL]
                }));
                return _.extend(a, {
                    damage: 0,
                    fakeDamage: r.damage,
                    maxHp: r.maxHp,
                    currHp: r.prevHp,
                    prevHp: r.prevHp,
                    isCritical: r.isCritical
                }), a
            }
            return _.extend(r, {
                damage: 0,
                canHit: !1
            })
        }
    }), i[n.CALC_HOOK.NON_DAMAGE] = r.extend({
        shouldHook: function(e, n) {
            var r = n.receiver;
            return !r.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.NON_DAMAGE) && !r.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.INDOMITABLENESS) && !r.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.ARM_CATCH) ? !1 : !n.canHit && n.damage >= 0 ? !1 : !0
        },
        postCalculate: function(e, t) {
            var n = t.type,
                r = {
                    damage: void 0,
                    absorbHp: void 0,
                    statusAilments: void 0,
                    unsetStatusAilments: void 0,
                    canHit: !1
                };
            return t.isAbilityPanel && _.extend(r, {
                currNum: t.prevNum,
                actualDamage: void 0
            }), _.extend(t, r)
        }
    }), i[n.CALC_HOOK.INVINCIBLE] = r.extend({
        shouldHook: function(e, t) {
            var n = t.receiver;
            return n.isInvincible() && t.canHit ? !0 : !1
        },
        postCalculate: function(e, t) {
            var n = t.type;
            return _.extend(t, {
                damage: void 0,
                absorbHp: void 0,
                statusAilments: void 0,
                unsetStatusAilments: void 0,
                canHit: !1
            })
        }
    }), i[n.CALC_HOOK.SWALLOWED] = r.extend({
        shouldHook: function(e, n) {
            var r = n.receiver,
                i = n.executer;
            return r.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.SWALLOWED) && (i.isBuddy() || i.isEnemy() && n.canHit && n.isDamage) ? !0 : !1
        },
        postCalculate: function(e, t) {
            return _.extend(t, {
                damage: void 0,
                statusAilments: void 0,
                unsetStatusAilments: void 0,
                canHit: !1
            })
        }
    }), i[n.CALC_HOOK.FURY] = r.extend({
        _allowExerciseTypes: [t.Conf.EXERCISE_TYPE.PHYSICAL, t.Conf.EXERCISE_TYPE.WHITE_MAGIC, t.Conf.EXERCISE_TYPE.BLACK_MAGIC, t.Conf.EXERCISE_TYPE.NINJA],
        _ignoreCalcTypes: [t.Conf.CALC_TYPE.HEAL_SA, t.Conf.CALC_TYPE.POISON, t.Conf.CALC_TYPE.STATUS_AILMENTS],
        shouldHook: function(e, n) {
            var r = n.receiver,
                i = e.ability;
            return r.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.FURY) ? r.isOpponent(e.executer) ? !1 : !n.canHit || !n.isDamage || (n.damage || 0) <= 0 ? !1 : _.contains(this._allowExerciseTypes, i.get("exerciseType")) ? _.contains(this._ignoreCalcTypes, e.type) ? !1 : !0 : !1 : !1
        },
        postCalculate: function(e, r) {
            var i = t.util.DamageCalculator.calculate(_.extend({}, e, {
                    type: n.CALC_TYPE.HEAL_SA,
                    hitRate: 100,
                    statusAilmentsIds: [t.Conf.STATUS_AILMENTS_TYPE.FURY]
                })),
                s = [].concat(r.unsetStatusAilments || [], i.unsetStatusAilments);
            return r.unsetStatusAilments = _.uniq(s), r
        }
    }), i[n.CALC_HOOK.IGNORE_GENERAL_DAMAGED_RATE_SCORE] = r.extend({
        shouldHook: function(e, t) {
            var n = e.ability;
            return t.executer.isEnemy() ? n.get("ignoreCalcDamagedRateScore") ? !0 : !1 : !1
        },
        postCalculate: function(e, t) {
            return t.ignoreCalcDamagedRateScore = !0, t
        }
    });
    var s = void 0,
        o = void 0,
        u = [n.CALC_HOOK.FLIGHT_ATTACK, n.CALC_HOOK.REFRECTOR, n.CALC_HOOK.COUNTER_ENABLE, n.CALC_HOOK.MATERIA, n.CALC_HOOK.RECEIVER_SA, n.CALC_HOOK.BRK_DEF],
        a = [n.CALC_HOOK.UNDEAD_CURE, n.CALC_HOOK.UNDEAD_RAISE, n.CALC_HOOK.SEALING, n.CALC_HOOK.PYRAMID, n.CALC_HOOK.FARAWAY, n.CALC_HOOK.WATER_BALL, n.CALC_HOOK.NON_DAMAGE, n.CALC_HOOK.SWALLOWED, n.CALC_HOOK.FURY, n.CALC_HOOK.IGNORE_GENERAL_DAMAGED_RATE_SCORE, n.CALC_HOOK.INVINCIBLE];
    FF.ns.battle.DamageCalculateHook = {
        postCalculate: function(e, t) {
            return (!s || !o) && this._init(), _.each(u, function(n) {
                var r = s[n];
                if (!r.shouldHook(e, t)) return;
                t = r.postCalculate(e, t)
            }, this), _.any(a, function(n) {
                var r = o[n];
                return r.shouldHook(e, t) ? (t = r.postCalculate(e, t), !0) : !1
            }, this), t
        },
        _init: function() {
            s = {}, o = {}, _.each(u, function(e) {
                var t = i[e];
                if (!t) throw new Error("unknown type. " + e);
                s[e] = new t
            }), _.each(a, function(e) {
                var t = i[e];
                if (!t) throw new Error("unknown type. " + e);
                o[e] = new t
            })
        }
    }
}), define("scenes/battle/util/DelayCallback", [], function() {
    var e = {},
        t = 1;
    return FF.ns.battle.util.DelayCallback = {
        update: function(t, n) {
            n = n || t;
            var r = [];
            _.each(e, function(e, i) {
                e.forBattle ? e.elapsedTime += n : e.elapsedTime += t, e.elapsedTime >= e.waitTime && (e.callback(), r.push(i))
            }), _.each(r, function(t) {
                delete e[t]
            })
        },
        register: function(n, r) {
            return e[t] = {
                waitTime: n,
                callback: r,
                elapsedTime: 0
            }, t++
        },
        registerForBattle: function(n, r) {
            return e[t] = {
                waitTime: n,
                callback: r,
                elapsedTime: 0,
                forBattle: !0
            }, t++
        },
        registerDeferred: function(e) {
            var t = $.Deferred();
            return this.register(e, function() {
                t.resolve()
            }), t
        },
        clear: function(t) {
            delete e[t]
        }
    }, FF.ns.battle.util.DelayCallback
}), define("scenes/battle/util/DropItem", ["util"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {};
    r[n.DROP_ITEM_TYPE.GIL] = "_giveGil", r[n.DROP_ITEM_TYPE.POTION] = "_givePotion", r[n.DROP_ITEM_TYPE.HI_POTION] = "_givePotion", r[n.DROP_ITEM_TYPE.X_POTION] = "_givePotion", r[n.DROP_ITEM_TYPE.ETHER] = "_giveEther", r[n.DROP_ITEM_TYPE.TURBO_ETHER] = "_giveEther", r[n.DROP_ITEM_TYPE.TREASURE] = "_giveTreasure", r[n.DROP_ITEM_TYPE.ORB] = "_giveOrb", r[n.DROP_ITEM_TYPE.EVENT_ITEM] = "_giveEventItem";
    var i = {};
    i[n.DROP_ITEM_TYPE.GIL] = "_applyGil", i[n.DROP_ITEM_TYPE.POTION] = "_applyPotion", i[n.DROP_ITEM_TYPE.HI_POTION] = "_applyPotion", i[n.DROP_ITEM_TYPE.X_POTION] = "_applyPotion", i[n.DROP_ITEM_TYPE.ETHER] = "_applyEther", i[n.DROP_ITEM_TYPE.TURBO_ETHER] = "_applyEther", i[n.DROP_ITEM_TYPE.TREASURE] = "_applyTreasure", i[n.DROP_ITEM_TYPE.ORB] = "_applyOrb", i[n.DROP_ITEM_TYPE.EVENT_ITEM] = "_applyEventItem";
    var s = void 0;
    FF.ns.battle.util.DropItem = {
        _resetTmpNumMap: function() {
            var e = t.BuddyPartyMgr.getInstance();
            s = {
                gil: e.get("gil"),
                orb: e.get("orb"),
                treasure: e.get("treasure"),
                eventItem: e.get("eventItem")
            }
        },
        give: function(e, n) {
            this._resetTmpNumMap();
            var r = {},
                i = {};
            _.each(e, function(e) {
                var t = e.container.containerUid;
                r[t] = r[t] || [], r[t].push(e), i[t] = e.container
            });
            var s = [];
            return _.each(i, function(e, t) {
                if (!e.isAllDead()) return;
                var n = r[t],
                    i = e.getDropItemList();
                for (var o = 0, u = i.length; o < u; o++) s.push({
                    executer: n[o % n.length],
                    dropItem: i[o]
                })
            }), n === t.Conf.JUDGE.VICTORY && _.each(t.BattleInfo.getInstance().getDropItemList(), function(t, n) {
                s.push({
                    executer: e[n % e.length],
                    dropItem: t
                })
            }), _.map(s, function(e) {
                return this._give(e)
            }, this)
        },
        applyResult: function(e) {
            _.each(e, function(e) {
                var t = e.item;
                FF.logger.debug("drop item apply. type: ", t.type);
                var n = this._getApplyFuncName(t.type);
                this[n](e)
            }, this)
        },
        _give: function(e) {
            var t = e.dropItem;
            FF.logger.debug("drop item. type: ", t.type);
            var n = this._getGiveFuncName(t.type);
            return {
                executer: e.executer,
                item: e.dropItem,
                dropItemObjects: this[n](e)
            }
        },
        _givePotion: function(e) {
            var n = e.dropItem,
                r = [],
                i = t.ActorMgr.getAliveBuddies();
            return _.map(i, function(r) {
                var i = r.get("hp"),
                    s = t.util.DamageCalculator.calculatePotion({
                        item: n,
                        receiver: r
                    });
                return s.executer = e.executer, s.item = e.dropItem, s
            }, this)
        },
        _applyPotion: function(e) {
            _.each(e.dropItemObjects, function(e) {
                e.receiver.applyDamageObject(e)
            })
        },
        _giveEther: function(e) {
            var n = e.dropItem,
                r = t.ActorMgr.getAliveBuddies();
            return _.map(r, function(r) {
                var i = this._lotAbilityPanelForEther(r),
                    s = t.util.DamageCalculator.calculateEther({
                        item: n,
                        receiver: r,
                        abilityPanel: i
                    });
                return s.executer = e.executer, s.item = e.dropItem, s
            }, this)
        },
        _applyEther: function(e) {
            _.each(e.dropItemObjects, function(e) {
                e.receiver.applyDamageObject(e)
            })
        },
        _lotAbilityPanelForEther: function(e) {
            return t.util.PanelTargeting.search(e, {
                receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                remainNum: t.Conf.PANEL_TARGET_REMAIN_NUM.ANY,
                defaultReceptorId: t.Conf.RECEPTOR.PANEL_ATTACK
            })
        },
        _giveGil: function(e) {
            var t = e.dropItem,
                n = t.amount;
            if (!n || n < 0) n = 0;
            var r = s.gil,
                i = r + n;
            return s.gil = i, [{
                executer: e.executer,
                item: e.dropItem,
                num: n,
                prevNum: r,
                currNum: i
            }]
        },
        _applyGil: function(e) {
            _.each(e.dropItemObjects, function(e) {
                t.BuddyPartyMgr.getInstance().giveGil(e.num)
            })
        },
        _giveTreasure: function(e) {
            var t = e.dropItem,
                n = t.num || 0,
                r = s.treasure,
                i = r + n;
            return s.treasure = i, [{
                executer: e.executer,
                item: e.dropItem,
                num: n,
                prevNum: r,
                currNum: i
            }]
        },
        _applyTreasure: function(e) {
            _.each(e.dropItemObjects, function(e) {
                t.BuddyPartyMgr.getInstance().giveTreasure(e.num)
            })
        },
        _giveOrb: function(e) {
            var t = e.dropItem,
                n = t.num || 0,
                r = s.orb,
                i = r + n;
            return s.orb = i, [{
                executer: e.executer,
                item: e.dropItem,
                num: n,
                prevNum: r,
                currNum: i
            }]
        },
        _applyOrb: function(e) {
            _.each(e.dropItemObjects, function(e) {
                t.BuddyPartyMgr.getInstance().giveOrb(e.num)
            })
        },
        _giveEventItem: function(e) {
            var t = e.dropItem,
                n = t.num || 0,
                r = s.eventItem,
                i = r + n;
            return s.eventItem = i, [{
                executer: e.executer,
                item: e.dropItem,
                num: n,
                prevNum: r,
                currNum: i
            }]
        },
        _applyEventItem: function(e) {
            _.each(e.dropItemObjects, function(e) {
                t.BuddyPartyMgr.getInstance().giveEventItem(e.num)
            })
        },
        _getGiveFuncName: function(e) {
            var t = r[e];
            if (!this[t]) throw new Error("invalid drop item type.t=" + e);
            return t
        },
        _getApplyFuncName: function(e) {
            var t = i[e];
            if (!this[t]) throw new Error("invalid drop item type.t=" + e);
            return t
        }
    }
}), define("scenes/battle/util/Targeting", ["underscore", "util"], function(e, t) {
    function s(e, t, r) {
        var s = void 0,
            o = {};
        switch (t) {
            case n.Conf.TARGET_METHOD.HP_RATIO_DESC:
                s = i.hpRatio, o.sign = -1;
                break;
            case n.Conf.TARGET_METHOD.HP_RATIO_ASC:
                s = i.hpRatio, o.sign = 1;
                break;
            case n.Conf.TARGET_METHOD.HP_DESC:
                s = i.hp, o.sign = -1;
                break;
            case n.Conf.TARGET_METHOD.HP_ASC:
                s = i.hp, o.sign = 1;
                break;
            case n.Conf.TARGET_METHOD.SA_RANDOM:
                s = i.sa, o.statusAilmentsId = r, o.has = !0;
                break;
            case n.Conf.TARGET_METHOD.DIS_SA_RANDOM:
                s = i.sa, o.statusAilmentsId = r, o.has = !1;
                break;
            case n.Conf.TARGET_METHOD.ESNA:
                s = i.saBundle, o.bundleId = n.Conf.STATUS_AILMENTS_BUNDLE.ESNA, o.sign = -1;
                break;
            case n.Conf.TARGET_METHOD.RANDOM:
                break;
            case n.Conf.TARGET_METHOD.NOTHING:
                break;
            case n.Conf.TARGET_METHOD.DISPEL:
                s = i.saBundle, o.bundleId = n.Conf.STATUS_AILMENTS_BUNDLE.DISPEL, o.sign = -1;
                break;
            default:
                throw new Error("unknown targetMethod. [" + t + "]")
        }
        return s ? s(e, o) : e[0]
    }

    function o(t, r) {
        switch (t) {
            case n.Conf.TARGET_DEATH.EXCLUDE_PURE_DEATH:
                return e.filter(r, function(e) {
                    return e.isAlive({
                        pureDeath: !0
                    })
                });
            case n.Conf.TARGET_DEATH.EXCLUDE:
                return e.filter(r, function(e) {
                    return e.isAlive()
                });
            case n.Conf.TARGET_DEATH.INCLUDE:
                return r;
            default:
                throw new Error("unknown targetDeath.[" + t + "]")
        }
    }

    function u(t, r, i) {
        switch (r) {
            case n.Conf.TARGET_SEGMENT.OPPONENT:
                return e.filter(i, function(e) {
                    return t.isOpponent(e)
                });
            case n.Conf.TARGET_SEGMENT.COLLEAGUE:
                return e.filter(i, function(e) {
                    return t.isColleague(e)
                });
            case n.Conf.TARGET_SEGMENT.BOTH:
                return i;
            case n.Conf.TARGET_SEGMENT.BOTH_EXCEPT_MYSELF:
                return e.filter(i, function(e) {
                    return !t.equals(e)
                });
            case n.Conf.TARGET_SEGMENT.COLLEAGUE_EXCEPT_MYSELF:
                return e.filter(i, function(e) {
                    return !t.equals(e) && t.isColleague(e)
                });
            default:
                throw new Error("unknown segment. [" + r + "]")
        }
    }

    function a(t) {
        return e.filter(t, function(e) {
            return e.isPossibleToTarget()
        })
    }

    function f(e, t, r) {
        var i = n.ActorMgr.getSubstituteTarget(e, t);
        return i && i.isColleague(r) && i.isPossibleToTarget() ? i : void 0
    }

    function l(e) {
        var t = e.executer,
            r = e.at,
            i = e.atMethod;
        if (!r) return void 0;
        if (!r.isPossibleToTarget()) return void 0;
        t.isEnemy() && (i = n.Conf.ACTIVE_TARGET_METHOD.BOTH_ENABLE);
        var s = !1;
        switch (i) {
            case n.Conf.ACTIVE_TARGET_METHOD.BOTH_DISABLE:
                break;
            case n.Conf.ACTIVE_TARGET_METHOD.OPPONENT_DISABLE:
                t.isColleague(r) && (s = !0);
                break;
            case n.Conf.ACTIVE_TARGET_METHOD.COLLEGUE_DISABLE:
                t.isOpponent(r) && (s = !0);
                break;
            case n.Conf.ACTIVE_TARGET_METHOD.BOTH_ENABLE:
                s = !0;
                break;
            default:
                throw new Error("unknown activeTargetMethod. [" + i + "]")
        }
        if (!s) return;
        var u = o(e.death, [r])[0];
        if (!u) return;
        var a = f(t, e.exerType, u);
        return a ? a : u
    }

    function c(e) {
        if (e.executer.isInConfusion() && !e.executer.shouldIgnoreIncontrollable()) return d(e);
        if (e.executer.isInBerserker() && !e.executer.shouldIgnoreIncontrollable()) return v(e);
        var t = l(e);
        if (t) return [t];
        switch (e.range) {
            case n.Conf.TARGET_RANGE.SINGLE:
                return p(e);
            case n.Conf.TARGET_RANGE.ALL:
                return h(e);
            case n.Conf.TARGET_RANGE.SELF:
                return [e.executer];
            default:
                throw new Error("unknown target_range. [" + e.range + "]")
        }
    }

    function h(e) {
        var t = u(e.executer, e.segment, e.actors);
        return t = a(t), o(e.death, t)
    }

    function p(e) {
        var t = u(e.executer, e.segment, e.actors);
        t = a(t), t = o(e.death, t);
        var n = s(t, e.method, e.saId);
        if (n) {
            var r = f(e.executer, e.exerType, n);
            return r ? [r] : [n]
        }
        return []
    }

    function d(e) {
        var t = u(e.executer, n.Conf.TARGET_SEGMENT.BOTH, e.actors);
        return t = a(t), t = o(n.Conf.TARGET_DEATH.EXCLUDE, t), [t[0]]
    }

    function v(e) {
        var t = u(e.executer, n.Conf.TARGET_SEGMENT.OPPONENT, e.actors);
        return t = a(t), t = o(n.Conf.TARGET_DEATH.EXCLUDE, t), [t[0]]
    }

    function m(t) {
        return e.map(t, function(e) {
            return {
                receiver: e,
                reflector: void 0
            }
        })
    }

    function g(e) {
        if (e.range === n.Conf.TARGET_RANGE.ALL) return !0;
        var t = n.Config.getInstance().get("ReflectionExerciseTypes");
        return t.indexOf(e.exerType) < 0 ? !0 : e.ignoresReflection ? !0 : !1
    }

    function y(t, r) {
        if (g(r)) return;
        var i = e.some(t, function(e) {
            var t = r.executer,
                i = e.receiver;
            if (!i.isReflected()) return !1;
            var s = t.isOpponent(i) ? n.Conf.TARGET_SEGMENT.COLLEAGUE : n.Conf.TARGET_SEGMENT.OPPONENT,
                o = c({
                    executer: r.executer,
                    range: n.Conf.TARGET_RANGE.SINGLE,
                    segment: s,
                    method: n.Conf.TARGET_METHOD.SA_RANDOM,
                    at: void 0,
                    atMethod: n.Conf.ACTIVE_TARGET_METHOD.BOTH_DISABLE,
                    death: r.death,
                    actors: r.actors
                });
            return o.length <= 0 ? !0 : (e.reflector = i, e.receiver = o[0], !1)
        });
        i && t.splice(0, t.length)
    }

    function b(r, i, s) {
        s = t.option({
            actors: void 0,
            ignoresReflection: !0
        }, s);
        var o = s.actors ? s.actors : n.ActorMgr.getAll();
        o = e.shuffle(o);
        var u = {
            executer: i,
            range: r.options.targetRange,
            segment: r.options.targetSegment,
            method: r.options.targetMethod,
            at: void 0,
            atMethod: r.options.activeTargetMethod,
            saId: r.options.statusAilmentsId,
            exerType: r.exerciseType,
            death: r.options.targetDeath,
            ignoresReflection: s.ignoresReflection,
            actors: o
        };
        return u
    }
    var n = FF.ns.battle,
        r = function(e, t) {
            e.sort(function(e, n) {
                var r, i;
                for (var s = 0, o = t.length; s < o; s++) {
                    r = t[s], i = r(e) - r(n);
                    if (i) return i
                }
                return 0
            })
        },
        i = {
            hpRatio: function(e, n) {
                var i = t.option({
                    sign: 1
                }, n);
                return r(e, [function(e) {
                    return i.sign * Math.floor(e.get("hp") / e.get("maxHp") * 100)
                }]), e[0]
            },
            hp: function(e, n) {
                var i = t.option({
                    sign: 1
                }, n);
                return r(e, [function(e) {
                    return i.sign * e.get("hp")
                }]), e[0]
            },
            sa: function(e, n) {
                var i = t.option({
                    statusAilmentsId: 0,
                    has: !0
                }, n);
                return r(e, [function(e) {
                    return i.has ? e.statusAilments.has(i.statusAilmentsId) ? 0 : 1 : e.statusAilments.has(i.statusAilmentsId) ? 1 : 0
                }]), e[0]
            },
            saBundle: function(i, s) {
                var o = t.option({
                        bundleId: 0,
                        sign: 1
                    }, s),
                    u = n.StatusAilmentsConfig.getBundle(o.bundleId),
                    a = {};
                return e.each(i, function(t) {
                    a[t.getUid()] = e.intersection(u, t.statusAilments.getRefs()).length
                }), r(i, [function(e) {
                    return o.sign * a[e.getUid()]
                }]), i[0]
            }
        };
    FF.ns.battle.util.Targeting = {
        search: function(r, i) {
            i = t.option({
                actors: void 0
            }, i);
            var s = i.actors ? i.actors : n.ActorMgr.getAll();
            s = e.shuffle(s);
            var o = {
                executer: r.executer,
                range: r.get("targetRange"),
                segment: r.get("targetSegment"),
                method: r.get("targetMethod"),
                at: r.get("activeTarget"),
                atMethod: r.get("activeTargetMethod"),
                saId: r.get("statusAilmentsId"),
                exerType: r.get("exerciseType"),
                death: r.get("targetDeath"),
                ignoresReflection: !!r.get("ignoresReflection"),
                actors: s
            };
            FF.logger.info("TARGET", o);
            var u = c(o),
                a = m(u);
            return y(a, o), a
        },
        makeResult: function(e) {
            var t = [];
            return e && (t = t.concat(e)), m(t)
        },
        searchByAbilityInfo: function(e, t, n) {
            var r = b(e, t, n);
            FF.logger.info("TARGET", r);
            var i = c(r),
                s = m(i);
            return y(s, r), s
        },
        getIgnoresReflectionByAbilityInfo: function(e, t, n) {
            var r = b(e, t, n);
            return g(r)
        }
    }
}), define("scenes/battle/util/EnemyTargeting", ["underscore", "util"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.ENEMY_TARGETING,
        i = function(e, t) {
            if (t) return !1;
            var r = e.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.REFLECTION);
            return r
        },
        s = function(t, n, r) {
            if (i(t, n)) return !1;
            var s = e.all(r, function(e) {
                return t.statusAilments.has(e)
            });
            return !s
        },
        o = function(t, n, r) {
            if (i(t, n)) return !1;
            var s = e.some(r, function(e) {
                return t.statusAilments.has(e)
            });
            return s
        },
        u = function(e, t, n) {
            if (i(e, t)) return !1;
            var r = e.getRemainingHpRate(),
                s = r <= n;
            return s
        },
        a = function(e, t, n, i, a, f) {
            var l = !0,
                c = !1;
            return !c && 0 <= e.indexOf(r.SET_SA) && (l = !1, c = s(t, n, i)), !c && 0 <= e.indexOf(r.UNSET_SA) && (l = !1, c = o(t, n, a)), !c && 0 <= e.indexOf(r.HEAL_HP) && (l = !1, c = u(t, n, f)), l || c
        },
        f = function(r, i, s) {
            var o = n.AbilityInfoMgr.getInstance(),
                u = o.getById(i),
                f = t.option({
                    healHpRate: 80,
                    forceIgnoresReflection: !0
                }, s);
            if (s) {
                var l = s[i];
                f = t.option(f, l)
            }
            var c = o.getEnemyTargeting(i);
            if (c.length === 0) return {
                isThereEnable: !0,
                targetInfoList: void 0
            };
            var h = o.getSaIdsForSetById(i),
                p = o.getSaIdsForUnsetById(i),
                d = f.healHpRate,
                v = f.forceIgnoresReflection;
            v || (v = n.util.Targeting.getIgnoresReflectionByAbilityInfo(u, r, {
                ignoresReflection: o.getIgnoresReflection(i)
            }));
            if (r.isIncontrollable()) throw new Error("cannot use in uncontrollable");
            var m = n.util.Targeting.searchByAbilityInfo(u, r, {}),
                g = e.map(m, function(e) {
                    var t = e.receiver,
                        n = a(c, t, v, h, p, d);
                    return {
                        isEnable: n,
                        targeting: e
                    }
                }),
                y = e.some(g, function(e) {
                    return e.isEnable
                }),
                b = {
                    isThereEnable: y,
                    targetInfoList: g
                };
            return b
        },
        l = function(e, t, n) {
            var r = f(e, t, n);
            return r
        };
    FF.ns.battle.util.EnemyTargeting = {
        getWithoutAbilityList: function(t, n, r) {
            var i = e.filter(n, function(e) {
                var n = this.isThereEnableAbilityTarget(t, e, r);
                return !n
            }, this);
            return i
        },
        isThereEnableAbilityTarget: function(e, t, n) {
            var r = this.getEnableAbilityTargetInfo(e, t, n);
            return r.isThereEnable
        },
        getEnableAbilityTargetInfo: function(e, t, r) {
            var i = n.AbilityInfoMgr.getInstance().getById(t),
                s;
            return i.options.targetRange === n.Conf.TARGET_RANGE.ALL ? s = l(e, t, r) : s = f(e, t, r), s
        }
    }
}), define("scenes/battle/util/PanelTargeting", ["underscore", "util"], function(e, t) {
    function r(e, t) {
        var r = !1;
        switch (t) {
            case n.Conf.PANEL_TARGET_RECEPTABLE.ENBALE:
                r = e.canRecept();
                break;
            case n.Conf.PANEL_TARGET_RECEPTABLE.DISABLE:
                r = !e.canRecept();
                break;
            case n.Conf.PANEL_TARGET_RECEPTABLE.ANY:
                r = !0;
                break;
            default:
                throw new Error("unknown receptable type. " + t)
        }
        return r
    }

    function i(e, t) {
        var r = !1;
        switch (t) {
            case n.Conf.PANEL_TARGET_REMAIN_NUM.EXISTS:
                r = e.get("remainNum") > 0;
                break;
            case n.Conf.PANEL_TARGET_REMAIN_NUM.EMPTY:
                r = e.get("remainNum") <= 0;
                break;
            case n.Conf.PANEL_TARGET_REMAIN_NUM.ANY:
                r = !0;
                break;
            default:
                throw new Error("unknown remainNum type. " + t)
        }
        return r
    }

    function s(e, t) {
        var r = !1;
        switch (t) {
            case n.Conf.PANEL_TARGET_USED_NUM.USED:
                r = e.get("remainNum") < e.get("maxNum");
                break;
            case n.Conf.PANEL_TARGET_USED_NUM.NOT_USED:
                r = e.get("remainNum") === e.get("maxNum");
                break;
            case n.Conf.PANEL_TARGET_USED_NUM.ANY:
                r = !0;
                break;
            default:
                throw new Error("unknown usedNum type. " + t)
        }
        return r
    }

    function o(o, u) {
        var a = [].concat(n.Config.getInstance().get("FlexibleAbilities"));
        u.includesAttack && a.push(n.Conf.RECEPTOR.PANEL_ATTACK), u.includesDefense && a.push(n.Conf.RECEPTOR.PANEL_DEFENSE), a = e.filter(a, function(e) {
            var t = o.getReceptorById(e);
            return t ? r(t, u.receptable) ? i(t, u.remainNum) ? s(t, u.usedNum) ? !0 : !1 : !1 : !1 : !1
        });
        if (a.length <= 0) {
            if (!u.defaultReceptorId) return void 0;
            a.push(u.defaultReceptorId)
        }
        var f = t.lot(a, function() {
            return 1
        });
        return o.getReceptorById(f)
    }
    var n = FF.ns.battle;
    FF.ns.battle.util.PanelTargeting = {
        search: function(e, r) {
            return r = t.option({
                receptable: n.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                remainNum: n.Conf.PANEL_TARGET_REMAIN_NUM.ANY,
                usedNum: n.Conf.PANEL_TARGET_USED_NUM.ANY,
                includesAttack: !1,
                includesDefense: !1,
                defaultReceptorId: void 0
            }, r), o(e, r)
        }
    }
}), define("scenes/battle/view/AbilityPanelView", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i) {
    var s = FF.ns.battle;
    FF.ns.battle.view.AbilityPanelView = i.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.posId = e.posId;
            var t = e.topNode,
                n = this.battleViewController.battleLayer;
            this._numText = "", this._name = void 0, this._enabled = void 0, this._iconAssetId = void 0, this._visible = !0, this.touchEnabled = !0, this._highlighted = !1, this.ab = {}, this.ab.panelNode = new r({
                name: sprintf("ability_panel_%s", this.posId),
                layer: n.layerName,
                duplicateFrom: "command_base_nul",
                duplicateFromOptions: {
                    visualParentLayer: n.layerName,
                    visualParentNode: "command_pos_nul_" + this.posId
                }
            }), this.ab.touchNode = t.createChildNode(sprintf("command_visible_touch_%s", this.posId)), this.ab.animNode = t.createChildNode(sprintf("command_anm_nul_%s", this.posId)), this.ab.panelColorNode = this.ab.panelNode.createChildNode("command_color_nul"), this.ab.panelParticleBurst = this.ab.panelNode.createChildNode("particle_burst"), this.flush()
        },
        setPanelInfo: function(e) {
            e.iconAssetId && this.setPanelImage(e.iconAssetId), this.setVisible(e.visible), this.setPanelEnabled(e.enabled), this.setPanelText(e.num), this.setPanelName(e.name), this.setHighlight(e.highlighted), this.flush()
        },
        setTouchEnded: function(e) {
            var n = this,
                r = s.DataConstructor.convPosIdToPanelNo(n.posId);
            this.ab.touchNode.addCallback("action_touch_ended", function() {
                if (!s.DataConstructor.canOperateBattle()) return;
                if (n._enabled === !1 || n.touchEnabled === !1) return;
                if (n._visible === !1) return;
                n.touchEnabled = !1, n.battleViewController.setCanStartPause(!1), n.ab.panelNode.play("command_tap_end"), n.ab.animNode.play("command_tap_end").processDeferred("action_stop").then(function() {
                    n.battleViewController.setCanStartPause(!0), e(r)
                })
            }), this.ab.touchNode.addCallback("action_touch_began", function() {
                if (!s.DataConstructor.canOperateBattle()) return;
                if (n._enabled === !1 || !n.touchEnabled) return;
                if (n._visible === !1) return;
                n.battleViewController.setCanStartPause(!1), n.ab.panelNode.play("command_tap_start").process(), n.ab.animNode.play("command_tap_start").process()
            }), this.ab.touchNode.addCallback("action_touch_enterd", function() {
                if (!s.DataConstructor.canOperateBattle()) return;
                if (n._enabled === !1 || !n.touchEnabled) return;
                if (n._visible === !1) return;
                n.battleViewController.setCanStartPause(!1), n.ab.panelNode.play("command_tap_start").process(), n.ab.animNode.play("command_tap_start").process()
            }), this.ab.touchNode.addCallback("action_touch_exited", function() {
                if (!s.DataConstructor.canOperateBattle()) return;
                if (n._enabled === !1 || !n.touchEnabled) return;
                t.when(n.ab.panelNode.play("command_tap_cancel").processDeferred("action_stop"), n.ab.animNode.play("command_tap_cancel").processDeferred("action_stop")).then(function() {
                    n.battleViewController.setCanStartPause(!0)
                })
            })
        },
        setPanelImage: function(e) {
            if (e === this._iconAssetId) return;
            var t = this.battleViewController.assetsManager.getAssetInfo(e);
            this.ab.panelNode.loadBundle(t.bundle).setImage("command_icon_img", t.assetPath), this._iconAssetId = e
        },
        setPanelEnabled: function(e) {
            if (e === this._enabled) return;
            var t = e ? "enabled" : "disabled";
            this.ab.panelColorNode.play(t), this._enabled = e
        },
        setPanelText: function(e) {
            if (this._numText === e) return;
            this.ab.panelNode.setText("command_num_txt", e), this._numText = e
        },
        setPanelName: function(e) {
            if (this._name === e) return;
            this.ab.panelNode.setText("command_name_txt", e), this._name = e
        },
        setVisible: function(e) {
            if (e === this._visible) return;
            this.ab.panelNode.setVisible(e).process(), this._visible = e
        },
        setTouchVisible: function(e) {
            this.ab.touchNode.setVisible(e).process()
        },
        isVisible: function() {
            return this._visible
        },
        commandInParticleBurstDeferred: function() {
            return this.ab.panelParticleBurst.play("command_change_in").processDeferred("action_stop")
        },
        commandOutParticleBurstDeferred: function() {
            return this.ab.panelParticleBurst.play("command_change_out").processDeferred("action_stop")
        },
        setHighlight: function(e) {
            if (this._highlighted === e) return;
            var t = e ? !0 : !1;
            this.ab.panelParticleBurst.setVisible(t).process(), this._highlighted = e
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            this.ab.panelNode.deleteNode().process()
        }
    })
}), define("scenes/battle/view/BackgroundView", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i) {
    var s = FF.ns.battle,
        o = "bg01_idle",
        u = "bg02_idle",
        a = "bg01",
        f = "bg02",
        l = "scene_change";
    return FF.ns.battle.view.BackgroundView = i.extend({
        initialize: function(e) {
            var t = this;
            this.battleViewController = e.battleViewController;
            var n = e.backgroundInfo || {},
                i = n.animationInfo.id,
                s = this.battleViewController.battleLayer,
                a = this.battleViewController.assetsManager.getAssetInfo(i);
            this.layerName = a.layerName, this.bgEffLayerNames = [], this.bgIdleTag = void 0, this.ab = {}, this.ab.bgNode = (new r({
                name: "bg_nul",
                layer: this.layerName,
                visualParentTo: "bg_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: s.layerName
                }
            })).setVisible(!0), this.ab.bg01Node = this.ab.bgNode.createChildNode("bg01_nul"), this.ab.bg01ScrollNode = this.ab.bgNode.createChildNode("bg01_scroll_nul"), this.ab.bg01IdleNode = this.ab.bg01ScrollNode.createChildNode("bg01_idle_nul"), this.ab.bg01EffPosNode = this.ab.bgNode.createChildNode("bg01_eff_pos_nul_02"), this.ab.bg02Node = this.ab.bgNode.createChildNode("bg02_nul"), this.ab.bg02ScrollNode = this.ab.bgNode.createChildNode("bg02_scroll_nul"), this.ab.bg02IdleNode = this.ab.bg02ScrollNode.createChildNode("bg02_idle_nul"), this.ab.bg02EffPosNode = this.ab.bgNode.createChildNode("bg02_eff_pos_nul_02"), this.ab.bg01IdleNode.play(o, {
                loop: !0
            }), this.ab.bg02IdleNode.play(u, {
                loop: !0
            }), this.ab.wipeNode = this.ab.bgNode.createChildNode("wipe"), this.ab.bgBlackNode = (new r({
                name: "bg_black_win",
                layer: s.layerName
            })).play("black_in");
            var f = n.animationInfo.bgEffectIds;
            this._setupBGEffect(f, s, this.layerName), this.flush()
        },
        _playDeferred: function(e, n, r) {
            r = r || {};
            var i = t.Deferred();
            return e.addCallbackOnce("action_stop", function() {
                i.resolve()
            }).play(n, r), i.promise()
        },
        _playTransitionDeferred: function(e) {
            var n = t.Deferred(),
                r = [];
            switch (e) {
                case a:
                    r.push(this.ab.bg01Node.play(e).processDeferred("action_stop")), r.push(this.ab.bg01ScrollNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg01EffPosNode.play(e).processDeferred("action_stop"));
                    break;
                case f:
                    r.push(this.ab.bg02Node.play(e).processDeferred("action_stop")), r.push(this.ab.bg02ScrollNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg02EffPosNode.play(e).processDeferred("action_stop"));
                    break;
                case l:
                    r.push(this.ab.wipeNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg01Node.play(e).processDeferred("action_stop")), r.push(this.ab.bg01ScrollNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg01EffPosNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg02Node.play(e).processDeferred("action_stop")), r.push(this.ab.bg02ScrollNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg02EffPosNode.play(e).processDeferred("action_stop"));
                    break;
                default:
                    throw new Error("unknown tag: " + e)
            }
            return this.flush(), this.bgIdleTag = void 0, t.when.apply(t, r)
        },
        _setupBGEffect: function(t, n, i) {
            var s = this;
            e.each(t, function(e) {
                var t = e.split("-"),
                    o = i + "-" + e;
                s.bgEffLayerNames.push(o);
                var u = (new r({
                    name: "bg_effect_nul",
                    layer: o,
                    visualParentTo: "bg" + t[0] + "_eff_pos_nul_" + t[1],
                    visualParentToOptions: {
                        visualParentLayer: t[1] >= 10 ? n.layerName : i
                    }
                })).play("play").process()
            })
        },
        playBackgroundIdle: function(e) {
            var t = e ? u : o;
            if (t === this.bgIdleTag) return;
            this._playIdleTag(t), this.bgIdleTag = t
        },
        _playIdleTag: function(e) {
            switch (e) {
                case o:
                    this.ab.bg01Node.setVisible(!0), this.ab.bg01ScrollNode.setVisible(!0), this.ab.bg02Node.setVisible(!1), this.ab.bg02ScrollNode.setVisible(!1);
                    break;
                case u:
                    this.ab.bg01Node.setVisible(!1), this.ab.bg01ScrollNode.setVisible(!1), this.ab.bg02Node.setVisible(!0).play(e), this.ab.bg02ScrollNode.setVisible(!0).play(e);
                    break;
                default:
                    throw new Error("unknown idle tag: " + e)
            }
            this.flush()
        },
        playScrollTransitionDeferred: function() {
            this.ab.bgBlackNode.play("black_out");
            var e = this.bgIdleTag === u ? f : a;
            return this._playTransitionDeferred(e)
        },
        suspendTransition: function() {
            this.ab.bgBlackNode.play("black_in"), this.flush()
        },
        playChangeTransitionDeferred: function() {
            return this._playTransitionDeferred(l)
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {}
    }), FF.ns.battle.view.BackgroundView
}), define("scenes/battle/view/BuddyView", ["underscore", "jquery", "backbone", "sprintf", "util", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle;
    return FF.ns.battle.view.BuddyView = o.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.nodePrefix = "player", this.spritePrefix = "character", this.commonAssetId = this.battleViewController.buddyCommonAssetId, this.buddyInfo = e.buddyInfo, this.posId = this.buddyInfo.posId, this.baseSpriteId = "buddy-" + this.buddyInfo.buddyAnimationInfo.path, this.baseAssetInfo = this.battleViewController.assetsManager.getAssetInfo(this.commonAssetId), this._isDead = !1, this._isTargeted = !1, this._isFingerPointed = !1, this._isCursorPointed = !1, this._isSpecialReady = !1, this._isSupporterReady = !1, this._playTag = void 0, this._spriteAssetId = void 0, this._currHp = void 0, this._uid = void 0, this._atbRate = void 0, this._castRate = void 0, this._isAtbFull = !1, this._row = void 0, this._isInAnimation = !1, this._isInAnimationList = [];
            var t = this.battleViewController.battleLayer,
                n = t.layerName,
                i = this.battleViewController.assetsManager.getAssetInfo("status_eff"),
                o = this.battleViewController.assetsManager.getAssetInfo("elemental_aura"),
                a = this.battleViewController.assetsManager.getAssetInfo("txt_eff"),
                f = this.battleViewController.assetsManager.getAssetInfo("back_eff");
            this.ab = {}, this.ab.playerNode = new s({
                name: r("player_nul_%s", this.posId),
                layer: n
            }), this.ab.playerEffNode = new s({
                name: r("player_eff_nul_%s", this.posId),
                layer: n
            }), this.ab.playerGaugeNode = new s({
                name: r("player_gauge_nul_%s", this.posId),
                layer: n
            }), this.ab.playerCursorNode = new s({
                name: r("player_cursor_pos_nul_%s", this.posId),
                layer: n
            }), this.ab.playerInfoNode = new s({
                name: r("player_info_nul_%s", this.posId),
                layer: n
            }), this.ab.playerSightNode = new s({
                name: r("player_sight_nul_%s", this.posId),
                layer: n
            }), this.ab.cursorNode = new s({
                name: r("%s_cursor_%s", this.nodePrefix, this.posId),
                layer: n,
                topNodeName: "cursor_center_nul",
                duplicateFrom: "cursor_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_cursor_nul_%s", this.nodePrefix, this.posId)
                }
            });
            var l = r("%s_visible_touch_nul_%s", this.nodePrefix, this.posId);
            this.ab.characterNode = new s({
                name: r("%s_character_%s", this.nodePrefix, this.posId),
                layer: this.baseAssetInfo.layerName,
                touchNodeName: l,
                duplicateFrom: "character_nul",
                duplicateFromOptions: {
                    visualParentLayer: n,
                    visualParentNode: r("%s_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this._addCustomActionCallbacks(this.ab.characterNode), this.ab.touchNode = t.createNode(l).setVisible(!0), this.ab.targetNode = new s({
                name: r("%s_target_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "target_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_sight_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.hpDamageNode = new s({
                name: r("%s_hp_damage_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "hp_damage_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.hpRecoveryNode = new s({
                name: r("%s_hp_recovery_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "hp_recovery_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.mpDamageNode = new s({
                name: r("%s_mp_damage_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "mp_damage_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.mpRecoveryNode = new s({
                name: r("%s_mp_recovery_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "mp_recovery_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.gaugeNode = new s({
                name: r("%s_gauge_%s", this.nodePrefix, this.posId),
                layer: n,
                parentNodeName: r("%s_gauge_nul_%s", this.nodePrefix, this.posId),
                duplicateFrom: "gauge_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_gauge_nul_%s", this.nodePrefix, this.posId)
                }
            });
            var c = this.ab.gaugeNode;
            this.ab.hpGaugeNode = c.createChildNode("hp_gauge_bar_img"), this.ab.hpGaugeRedNode = c.createChildNode("hp_gauge_bar_red_img"), this.ab.atbGaugeNode = c.createChildNode("atb_gauge_bar_img"), this.ab.castGaugeNode = c.createChildNode("atb2_gauge_bar_img"), this.ab.atbFullNode = c.createChildNode("atb_full_bar_img").setVisible(!1), this.ab.statusAilmentsBalloon = new s({
                name: r("%s_status_icon_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "status_icon_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_eff_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.statusAilmentsDoom = new s({
                name: r("%s_death_num_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "death_num_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_eff_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.statusAilmentsAura = new s({
                name: r("%s_character_eff_front_nul_%s", this.nodePrefix, this.posId),
                layer: i.layerName,
                duplicateFrom: "character_eff_front_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.ab.statusAilmentsOverlayAura = new s({
                name: r("%s_character_eff_overlay_nul_%s", this.nodePrefix, this.posId),
                layer: i.layerName,
                duplicateFrom: "character_eff_front_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.ab.statusAilmentsElementalAura = new s({
                name: r("%s_character_elemental_aura_%s", this.nodePrefix, this.posId),
                layer: o.layerName,
                duplicateFrom: "character_elemental_aura",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_back_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.ab.statusAilmentsMirage = this.ab.characterNode.createChildNode("cloning_nul"), this.ab.statusAilmentsBackAura = new s({
                name: r("%s_character_eff_back_nul_%s", this.nodePrefix, this.posId),
                layer: f.layerName,
                duplicateFrom: "character_eff_back_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_back_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.statusAilmentsView = new u.view.StatusAilmentsView(this), this.ab.colorChangeLoopNode = this.ab.characterNode.createChildNode("character_color_change_loop_nul"), this.ab.colorChangeNode = this.ab.colorChangeLoopNode.createChildNode("character_color_change_nul"), this.ab.colorChangeAddNode = this.ab.colorChangeLoopNode.createChildNode("character_color_change_nul_add"), this.ab.colorChangeSinglePosNode = this.ab.characterNode.createChildNode("character_color_change_single_pos_nul"), this.ab.colorChangeLoopSingleNode = new s({
                name: r("%s_character_color_change_loop_nul_%s", this.nodePrefix, this.posId),
                layer: this.ab.characterNode.layer,
                duplicateFrom: "character_color_change_loop_nul",
                duplicateFromOptions: {
                    parentNode: this.ab.colorChangeSinglePosNode.name,
                    parentTopNode: this.ab.characterNode.name
                }
            }), this.ab.characterNode.setParam({
                color_change_parent: this.ab.colorChangeLoopSingleNode.name
            }), this.ab.colorChangeSingleNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_color_change_nul"), this.ab.colorChangeSingleAddNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_color_change_nul_add"), this.ab.leftArmColorChangeLoopNode = this.ab.characterNode.createChildNode("left_arm_color_change_loop_nul"), this.ab.leftArmColorChangeNode = this.ab.leftArmColorChangeLoopNode.createChildNode("left_arm_color_change_nul"), this.ab.leftArmColorChangeAddNode = this.ab.leftArmColorChangeLoopNode.createChildNode("left_arm_color_change_nul_add"), this.ab.leftArmColorChangeSinglePosNode = this.ab.characterNode.createChildNode("left_arm_color_change_single_pos_nul"), this.ab.leftArmColorChangeLoopSingleNode = new s({
                name: r("%s_left_arm_color_change_loop_nul_%s", this.nodePrefix, this.posId),
                layer: this.ab.characterNode.layer,
                duplicateFrom: "left_arm_color_change_loop_nul",
                duplicateFromOptions: {
                    parentNode: this.ab.leftArmColorChangeSinglePosNode.name,
                    parentTopNode: this.ab.characterNode.name
                }
            }), this.ab.characterNode.setParam({
                color_change_arm_parent: this.ab.leftArmColorChangeLoopSingleNode.name
            }), this.ab.leftArmColorChangeSingleNode = this.ab.leftArmColorChangeLoopSingleNode.createChildNode("left_arm_color_change_nul"), this.ab.leftArmColorChangeSingleAddNode = this.ab.leftArmColorChangeLoopSingleNode.createChildNode("left_arm_color_change_nul_add"), this.ab.txtEffNode = new s({
                name: r("%s_txt_eff_%s", this.nodePrefix, this.posId),
                layer: a.layerName,
                duplicateFrom: "txt_eff_nul",
                duplicateFromOptions: {
                    visualParentLayer: t.layerName,
                    visualParentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this._addCustomActionCallbacks(this.ab.txtEffNode), this.ab.specialReadyNode = (new s({
                name: r("special_ready_nul_%s", this.posId),
                layer: "layer_chara_aura",
                duplicateFrom: "special_ready_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            })).setVisible(!1), this.ab.supporterReadyNode = (new s({
                name: r("social_special_ready_nul_%s", this.posId),
                layer: "layer_social_aura",
                duplicateFrom: "special_ready_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            })).setVisible(!1), this.replaceBuddyInfo(this.buddyInfo), this.flush()
        },
        getTargetPositionDeferred: function() {
            var e = this.battleViewController;
            return e.getScreenPositionDeferred(this.ab.targetNode)
        },
        replaceBuddyInfo: function(e) {
            var t = e.buddyAnimationInfo,
                n = e.weaponAnimationInfo || {},
                r = e.handedness,
                i = "buddy-" + t.path,
                s = [t.left1OffsetX, t.left1OffsetY],
                o = [t.left2OffsetX, t.left2OffsetY],
                a = [t.right1OffsetX, t.right1OffsetY],
                f = [t.right2OffsetX, t.right2OffsetY];
            this.weaponEquipNodes = [], this.weaponEquipType = void 0, this.weaponAttackTag = void 0, this.canWeaponMove = n.canMove ? !0 : !1, n.equipType === u.Conf.WEAPON_EQUIP_TYPE.FREE ? r === "left" ? (this.weaponEquipType = u.Conf.WEAPON_EQUIP_TYPE.LEFT, this.weaponAttackTag = "attack_2") : (this.weaponEquipType = u.Conf.WEAPON_EQUIP_TYPE.RIGHT, this.weaponAttackTag = "attack") : (this.weaponEquipType = n.equipType, this.weaponAttackTag = n.attackTag);
            if (n.id) {
                var l = this.battleViewController.assetsManager.getAssetInfo("weapon-" + n.id);
                this._setupWeaponEquipNodes(l, this.baseAssetInfo)
            }
            this.ab.characterNode.setParam({
                weapon_right_1_offset_x: a[0],
                weapon_right_1_offset_y: a[1],
                weapon_right_2_offset_x: f[0],
                weapon_right_2_offset_y: f[1],
                weapon_left_1_offset_x: s[0],
                weapon_left_1_offset_y: s[1],
                weapon_left_2_offset_x: o[0],
                weapon_left_2_offset_y: o[1]
            }), this.setSprite(i), this.statusBonusFlgOf = e.statusBonusFlgOf, this.statusBonusTypeOf = e.statusBonusTypeOf, this._setupStatusBonusNodes(this.baseAssetInfo)
        },
        _createWeaponEquipNode: function(e, t, n) {
            return new s({
                name: r("weapon_%s_%s", e, this.posId),
                layer: t.layerName,
                duplicateFrom: "weapon_nul",
                duplicateFromOptions: {
                    visualParentLayer: n.layerName,
                    visualParentNode: r("weapon_%s_pos_nul", e),
                    visualParentTopNode: this.ab.characterNode.name
                }
            })
        },
        _setupWeaponEquipNodes: function(t, n) {
            var r = ["weaponRightNode", "weaponLeftNode"];
            e.each(r, function(e) {
                this.ab[e] && (this.ab[e].deleteNode().process(), delete this.ab[e])
            }, this), this.weaponEquipNodes = [];
            switch (this.weaponEquipType) {
                case u.Conf.WEAPON_EQUIP_TYPE.RIGHT:
                    this.ab.weaponRightNode = this._createWeaponEquipNode("right", t, n), this.weaponEquipNodes.push(this.ab.weaponRightNode);
                    break;
                case u.Conf.WEAPON_EQUIP_TYPE.LEFT:
                    this.ab.weaponLeftNode = this._createWeaponEquipNode("left", t, n), this.weaponEquipNodes.push(this.ab.weaponLeftNode);
                    break;
                case u.Conf.WEAPON_EQUIP_TYPE.BOTH:
                    this.ab.weaponRightNode = this._createWeaponEquipNode("right", t, n), this.ab.weaponLeftNode = this._createWeaponEquipNode("left", t, n), this.weaponEquipNodes.push(this.ab.weaponRightNode), this.weaponEquipNodes.push(this.ab.weaponLeftNode);
                    break;
                default:
            }
        },
        _setupStatusBonusNodeByType: function(e, t, n) {
            var i = void 0,
                o = void 0,
                a = void 0;
            switch (e) {
                case u.Conf.STATUS_BONUS_PARTS.BUDDY:
                    i = "statusBonusBuddyNode", o = "chara", a = "back";
                    break;
                case u.Conf.STATUS_BONUS_PARTS.WEAPON:
                    i = "statusBonusWeaponNode", o = "attack", a = "back";
                    break;
                case u.Conf.STATUS_BONUS_PARTS.ARMOR:
                    i = "statusBonusArmorNode", o = "defense", a = "front";
                    break;
                case u.Conf.STATUS_BONUS_PARTS.ACCESSORY:
                    return;
                default:
                    throw new Error("invalid type " + e)
            }
            var f = this.battleViewController.assetsManager.getAssetInfo(r("%s_eff_%s", n, o));
            this.ab[i] = new s({
                name: r("status_bonus_eff_%s_%s", o, this.posId),
                layer: f.layerName,
                duplicateFrom: r("status_bonus_eff_%s_nul", o),
                duplicateFromOptions: {
                    visualParentLayer: t.layerName,
                    visualParentNode: r("status_bonus_eff_%s_pos_nul", a),
                    visualParentTopNode: this.ab.characterNode.name
                }
            })
        },
        _setupStatusBonusNodes: function(t) {
            var n = ["statusBonusBuddyNode", "statusBonusWeaponNode", "statusBonusArmorNode"],
                r = this._getStatusBonusAssetName();
            e.each(n, function(e) {
                this.ab[e] && (this.ab[e].deleteNode().process(), delete this.ab[e])
            }, this), e.each(u.Conf.STATUS_BONUS_PARTS, function(e) {
                if (!this.statusBonusFlgOf[e]) return;
                this._setupStatusBonusNodeByType(e, t, r)
            }, this), this.statusBonusFlgOf[u.Conf.STATUS_BONUS_PARTS.BUDDY] ? this.setStatusBonusBuddyVisible(!0) : this.setStatusBonusBuddyVisible(!1)
        },
        _getStatusBonusAssetName: function() {
            var e = {};
            return e[u.Conf.STATUS_BONUS_TYPE.SERIES] = "series", e[u.Conf.STATUS_BONUS_TYPE.ROLE] = "role", e[this.statusBonusTypeOf]
        },
        _addCustomActionCallbacks: function(e) {
            var t = this;
            e.setParam({
                layer_battle_field: this.battleViewController.battleLayer.layerName
            }), e.addCallback("action_shake_part", function() {
                t.battleViewController.startShakeBackground()
            }), e.addCallback("action_shake_part_stop", function() {
                t.battleViewController.stopShakeBackground()
            }), e.addCallback("action_flash", function() {
                t.battleViewController.playFlash()
            }), e.addCallback("action_shake_all", function() {
                t.battleViewController.startShakeField()
            }), e.addCallback("action_shake_all_stop", function() {
                t.battleViewController.stopShakeField()
            })
        },
        playTagWithPriority: function(t) {
            var n = u.Config.getInstance().get("BuddyTagPriority"),
                r = e.filter(t, function(e) {
                    return !n[e]
                });
            if (r.length !== 0) throw new Error("invalid tagList [" + t.join(",") + "]");
            var i = e.min(t, function(e) {
                return n[e]
            });
            this.playLoop(i)
        },
        setBuddyInfo: function(e) {
            this.setATBGauge(e.atbRate), this.setCastGauge(e.castRate);
            if (this.isInAnimation()) {
                this.flush();
                return
            }
            this.setRow(e.row || u.Conf.ROW_TYPE.FRONT), this.setLifeGauge(e.hp, e.maxHp), this.statusAilmentsView.update(e), this.playTagWithPriority(e.playTagList), this.setSpecialReady(e), this.setSupporterReady(e.isSupporterReady), e.isDead ? e.isForceEscaped ? this.forceEscapedMotion() : this.deadMotion() : this.aliveMotion(), this._uid = e.uid, this.flush()
        },
        setSprite: function(e) {
            if (e === this._spriteAssetId) return;
            var t = this.battleViewController.assetsManager.getAssetInfo(e);
            this.ab.colorChangeLoopNode.loadBundle(t.bundle).setSpriteAnimeByNode(r("sprite_%s_base", this.spritePrefix), t.assetPath).setSpriteAnimeByNode(r("sprite_%s_add", this.spritePrefix), t.assetPath), this.ab.colorChangeLoopSingleNode.loadBundle(t.bundle).setSpriteAnimeByNode(r("sprite_%s_base", this.spritePrefix), t.assetPath).setSpriteAnimeByNode(r("sprite_%s_add", this.spritePrefix), t.assetPath);
            var n = r("%s_left_arm", e),
                i = this.battleViewController.assetsManager.getAssetInfo(n, {
                    error: !1
                });
            i && (this.ab.leftArmColorChangeLoopNode.loadBundle(i.bundle).setSpriteAnimeByNode("sprite_left_arm_base", i.assetPath).setSpriteAnimeByNode("sprite_left_arm_add", i.assetPath), this.ab.leftArmColorChangeLoopSingleNode.loadBundle(i.bundle).setSpriteAnimeByNode("sprite_left_arm_base", i.assetPath).setSpriteAnimeByNode("sprite_left_arm_add", i.assetPath)), this.ab.statusAilmentsMirage.loadBundle(t.bundle).setSpriteAnimeByNode("sprite_character_cloning_01", t.assetPath).setSpriteAnimeByNode("sprite_character_cloning_02", t.assetPath).setSpriteAnimeByNode("sprite_character_cloning_03", t.assetPath), this._playTag && this.ab.characterNode.play(this._playTag), this._spriteAssetId = e
        },
        setRow: function(e) {
            if (e === this._row) return;
            e === u.Conf.ROW_TYPE.BACK ? (this.ab.playerNode.play("rearguard_pos"), this.ab.playerEffNode.play("rearguard_pos"), this.ab.playerGaugeNode.play("rearguard_pos"), this.ab.playerCursorNode.play("rearguard_pos"), this.ab.playerInfoNode.play("rearguard_pos"), this.ab.playerSightNode.play("rearguard_pos")) : (this.ab.playerNode.play("vanguard_pos"), this.ab.playerEffNode.play("vanguard_pos"), this.ab.playerGaugeNode.play("vanguard_pos"), this.ab.playerCursorNode.play("vanguard_pos"), this.ab.playerInfoNode.play("vanguard_pos"), this.ab.playerSightNode.play("vanguard_pos")), this._row = e
        },
        setSpecialReady: function(e) {
            var t = e.isSpecialReady;
            if (t === this._isSpecialReady) return;
            if (t) {
                var n = e.specialAuraType === u.Conf.SPECIAL_AURA_TYPE.HAS_PARAM_BOOSTER ? "play_color_01" : "play";
                this.ab.specialReadyNode.setVisible(!0).play(n)
            } else this.ab.specialReadyNode.setVisible(!1);
            this._isSpecialReady = t
        },
        setSupporterReady: function(e) {
            if (e === this._isSupporterReady) return;
            e ? this.ab.supporterReadyNode.setVisible(!0).play("play") : this.ab.supporterReadyNode.setVisible(!1), this._isSupporterReady = e
        },
        hideSpecialReady: function() {
            this._isSpecialReady && (this.setSpecialReady(!1), this.flush()), this._isSupporterReady && (this.setSupporterReady(!1), this.flush())
        },
        playWalkDeferred: function(e) {
            var n = this,
                i = e === "front",
                s = i ? "attack" : "back",
                o = i ? !1 : !0,
                u = new t.Deferred,
                a = this.battleViewController.battleLayer,
                f = this.ab.playerNode.createChildNode("player_action_nul_" + this.posId),
                l = this.ab.playerEffNode.createChildNode("player_eff_action_nul_" + this.posId);
            return this.ab.statusAilmentsMirage.setVisible(o), this.ab.characterNode.play("walk"), this.ab.playerEffNode.play(s, {
                node: r("player_eff_action_nul_%s", this.posId),
                isPlayChild: !1
            }), this.ab.playerInfoNode.play(s, {
                node: r("player_info_action_nul_%s", this.posId),
                isPlayChild: !1
            }), this.ab.playerSightNode.play(s, {
                node: r("player_sight_action_nul_%s", this.posId),
                isPlayChild: !1
            }), f.addCallbackOnce("action_stop", function() {
                n.playDeferred("idle"), u.resolve()
            }).play(s).process(), this.flush(), u.promise()
        },
        playInDeferred: function(e, n) {
            var r = t.Deferred();
            return this._isCursorPointed && this.ab.cursorNode.setVisible(!0).process(), this._setVisibleForCharaInOut(!0), this.playDeferred(e).then(function() {
                n && n(), r.resolve()
            }), r.promise()
        },
        playOutDeferred: function(e) {
            return this._isCursorPointed && this.ab.cursorNode.setVisible(!1).process(), this.hideSpecialReady(), this._setVisibleForCharaInOut(!1), this.playDeferred(e)
        },
        _setVisibleForCharaInOut: function(e) {
            if (this._isDead) return;
            if (this._isForceEscaped) return;
            this.ab.gaugeNode.setVisible(e), this.ab.statusAilmentsBalloon.setVisible(e), this.ab.statusAilmentsAura.setVisible(e), this.ab.statusAilmentsOverlayAura.setVisible(e), this.ab.statusAilmentsElementalAura.setVisible(e), this.ab.statusAilmentsBackAura.setVisible(e), this.ab.statusAilmentsDoom.setVisible(e), this.ab.statusAilmentsMirage.setVisible(e), this.ab.statusAilmentsTranceAura && this.ab.statusAilmentsTranceAura.setVisible(e), this.setStatusBonusBuddyVisible(e), this.flush()
        },
        setVisibleForReplacingSupporter: function(e) {
            this.ab.gaugeNode.setVisible(e), this.statusAilmentsView.reset()
        },
        playWalk: function() {
            this._isInAnimation = !0, this.hideSpecialReady(), this.ab.characterNode.play("walk").process()
        },
        playIdle: function() {
            this._isInAnimation = !1, this.hideSpecialReady(), this.ab.characterNode.play("idle").process()
        },
        setATBGauge: function(e) {
            if (e === this._atbRate) return;
            e === 100 ? (this.ab.atbFullNode.play("bar_light_loop", {
                loop: !0
            }).setVisible(!0).process(), this._isAtbFull = !0) : (this.ab.atbGaugeNode.playFrame("bar", e, e).process(), this._isAtbFull && (this.ab.atbFullNode.setVisible(!1).process(), this._isAtbFull = !1)), this._atbRate = e
        },
        setCastGauge: function(e) {
            if (e === this._castRate) return;
            this._isAtbFull && (this.ab.atbFullNode.setVisible(!1).process(), this._isAtbFull = !1), this.ab.castGaugeNode.playFrame("bar", e, e).process(), this._castRate = e
        },
        setCursorEnabled: function(e) {
            if (e === this._isCursorPointed) return;
            e ? this.ab.cursorNode.setVisible(!0).play("cursor_open") : this._isForceEscaped || this.ab.cursorNode.setVisible(!0).play("cursor_close"), this._isCursorPointed = e
        },
        setTargetEnabled: function(e) {
            if (e === this._isTargeted) return;
            e ? this.ab.targetNode.play("target_in") : this.ab.targetNode.play("target_out"), this._isTargeted = e
        },
        setTouchEnded: function(e) {
            this.setTouchEvent("action_touch_ended", e)
        },
        setTouchBegan: function(e) {
            this.setTouchEvent("action_touch_began", e)
        },
        setTouchEvent: function(e, t) {
            var n = this;
            this.ab.characterNode.addCallback(e, function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                t(n._uid)
            }, {
                layer: this.ab.characterNode.visualParentLayer,
                node: this.ab.characterNode.touchNodeName
            })
        },
        removeAllCallback: function() {
            this.ab.characterNode.removeAllCallback()
        },
        getCurrHP: function() {
            return this._currHp
        },
        setLifeGauge: function(t, n) {
            if (!e.isNumber(t) || !e.isNumber(n)) throw new Error("invalid life gauge param");
            if (t === this._currHp) return;
            var r = Math.floor((n - t) / n * 100);
            r <= 100 && (this.ab.hpGaugeNode.playFrame("bar", r, r).process(), this.ab.hpGaugeRedNode.playFrame("bar", r, r).process()), this._currHp = t
        },
        setLifeGaugeMotionDeferred: function(t, n, r) {
            if (!e.isNumber(t) || !e.isNumber(n) || !e.isNumber(r)) throw new Error("invalid life gauge param");
            if (n === this._currHp) return;
            var i = this,
                s, o, u, a;
            return t > n ? (s = "bar", o = Math.floor((r - t) / r * 100), u = Math.floor((r - n) / r * 100)) : (s = "bar_reverse", o = Math.floor(t / r * 100), u = Math.floor(n / r * 100)), a = e.max([Math.abs(o - u) / 20, 1]), this._currHp = n, this.ab.hpGaugeNode.playFrame(s, o, u, {
                speed: a
            }).processDeferred("action_stop", {
                node: i.ab.hpGaugeNode.name,
                topNode: i.ab.gaugeNode.name
            }).then(function() {
                return i.ab.hpGaugeRedNode.playFrame(s, o, u, {
                    speed: a
                }).processDeferred("action_stop", {
                    node: i.ab.hpGaugeRedNode.name,
                    topNode: i.ab.gaugeNode.name
                })
            })
        },
        setDamageMotionDeferred: function(e, n, r, i, s, o, u, a) {
            var f = this;
            a = a || {};
            if (!e) return t.Deferred().resolve().promise();
            var l = void 0,
                c = void 0,
                h = this._playTag;
            if (s >= 0) {
                l = "" + s, c = o || "damage";
                var p = this.playDeferred(c).then(function() {
                        return t.when(f.playDeferred(h), f.playHpDamageDeferred(l, a), f.setLifeGaugeMotionDeferred(n, r, i))
                    }),
                    d = this._playDamageOptionalDeferred();
                return t.when(p, d)
            }
            return l = "" + -1 * s, c = u || "eff_recover", this.playColorChangeDeferred(c).then(function() {
                return t.when(f.playHpRecoveryDeferred(l, a), f.setLifeGaugeMotionDeferred(n, r, i))
            })
        },
        playMpDamageMotionDeferred: function(e, n, r) {
            r = r || {};
            if (!e) return t.Deferred().resolve().promise();
            var i = void 0;
            return n >= 0 ? (i = "" + n, this.playMpDamageDeferred(i)) : (i = "" + -1 * n, this.playMpRecoveryDeferred(i))
        },
        playDeferred: function(e, n) {
            var r = this;
            n = n || {};
            var i = t.Deferred();
            return this.ab.characterNode.addCallbackOnce("action_stop", function() {
                r._playTag = e, i.resolve()
            }).play(e, n).process(), i.promise()
        },
        playColorChangeDeferred: function(n, r) {
            var i = this;
            r = r || {};
            var s = t.Deferred(),
                o = t.Deferred(),
                u = e.extend({
                    isPlayChild: !1
                }, r);
            return this.ab.colorChangeSinglePosNode.play(n, u).addCallbackOnce("action_stop", function() {
                i.ab.colorChangeSinglePosNode.play("stop", u).setVisible(!1).process(), s.resolve()
            }), this.ab.colorChangeSingleNode.play(n, u), this.ab.colorChangeSingleAddNode.play(n, u), this.ab.leftArmColorChangeSinglePosNode.play(n, u).addCallbackOnce("action_stop", function() {
                i.ab.leftArmColorChangeSinglePosNode.play("stop", u).setVisible(!1).process(), o.resolve()
            }), this.ab.leftArmColorChangeSingleNode.play(n, u), this.ab.leftArmColorChangeSingleAddNode.play(n, u), this.flush(), t.when(s.promise(), o.promise())
        },
        playAttackDeferred: function(e, t) {
            var n = this;
            return t = t || {}, this._playPreAttackDeferred(t).then(function() {
                var r = e.atkMotion;
                return r ? n.playDeferred(r, t) : n.playWeaponAttackDeferred(t)
            })
        },
        _playPreAttackDeferred: function(e) {
            return this.statusBonusFlgOf[u.Conf.STATUS_BONUS_PARTS.WEAPON] ? this.ab.statusBonusWeaponNode.play("play").processDeferred("action_next") : t.Deferred().resolve().promise()
        },
        playWeaponAttackDeferred: function(t) {
            var n = this;
            return this.canWeaponMove && e.each(this.weaponEquipNodes, function(e) {
                e.play(this.weaponAttackTag, t).process()
            }, this), this.ab.characterNode.play(this.weaponAttackTag, t).processDeferred("action_attack_next")
        },
        _playDamageOptionalDeferred: function() {
            return this.statusBonusFlgOf[u.Conf.STATUS_BONUS_PARTS.ARMOR] ? this.ab.statusBonusArmorNode.play("play").processDeferred("action_stop") : t.Deferred().resolve().promise()
        },
        playLoop: function(e) {
            if (e === this._playTag) return;
            e === "dead" ? this.ab.characterNode.setParam({
                normal: "dead",
                white: "dead_white"
            }) : e === "fatal" ? this.ab.characterNode.setParam({
                normal: "fatal",
                white: "fatal_white"
            }) : this.ab.characterNode.setParam({
                normal: "idle",
                white: "idle_white"
            }), this.ab.characterNode.play(e), this._playTag = e
        },
        playHpDamageDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.hpDamageNode, "hp_damage", e, t)
        },
        playHpRecoveryDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.hpRecoveryNode, "hp_recovery", e, t)
        },
        playMpDamageDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.mpDamageNode, "mp_damage", e, t)
        },
        playMpRecoveryDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.mpRecoveryNode, "mp_recovery", e, t)
        },
        playDigitsDeferred: function(n, i, s, o) {
            var u = t.Deferred();
            o = o || {};
            var a = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7],
                f = String(s).split("").reverse();
            return e.each(a, function(e, t) {
                var s = f[t] || "";
                n.setText(r("%s_%d_txt", i, e), s)
            }), n.addCallbackOnce("action_stop", function() {
                u.resolve()
            }).play("hp_text", o).process(), u.promise()
        },
        playCriticalDeferred: function() {
            return this.ab.txtEffNode.play("critical").processDeferred("action_stop")
        },
        playWeaknessDeferred: function() {
            return this.ab.txtEffNode.play("weakness").processDeferred("action_stop")
        },
        playDefenseDeferred: function() {
            return this.ab.txtEffNode.play("defense").processDeferred("action_stop")
        },
        playAbsorbDeferred: function() {
            return this.ab.txtEffNode.play("absorb").processDeferred("action_stop")
        },
        playResistDeferred: function() {
            return this.ab.txtEffNode.play("resist").processDeferred("action_stop")
        },
        playMissDeferred: function() {
            return this.ab.txtEffNode.play("miss").processDeferred("action_stop")
        },
        playNoeffectDeferred: function() {
            return this.ab.txtEffNode.play("noeffect").processDeferred("action_stop")
        },
        aliveMotion: function() {
            if (!this._isDead) return;
            this._isDead = !1, this.ab.gaugeNode.setVisible(!0), this.setStatusBonusBuddyVisible(!0)
        },
        deadMotion: function() {
            if (this._isDead) return;
            this._isDead = !0, this.ab.gaugeNode.setVisible(!1), this.ab.cursorNode.setVisible(!1), this.hideSpecialReady(), this.setStatusBonusBuddyVisible(!1), this.flush()
        },
        forceEscapedMotion: function() {
            if (this._isForceEscaped) return;
            this._isForceEscaped = !0, this.setVisible(!1), this.ab.gaugeNode.setVisible(!1), this.ab.cursorNode.setVisible(!1), this.ab.targetNode.setVisible(!1), this.ab.statusAilmentsDoom.setVisible(!1), this.hideSpecialReady(), this.flush()
        },
        handsUpMotion: function() {
            this._isInAnimation = !0, this.hideSpecialReady(), this.ab.statusAilmentsMirage.setVisible(!1), this.ab.characterNode.play("hands_up"), this.ab.gaugeNode.setVisible(!1), this.setCursorEnabled(!1), this.flush()
        },
        setVisible: function(e) {
            this.ab.characterNode.setVisible(e).process()
        },
        setStatusBonusBuddyVisible: function(e) {
            if (!this.statusBonusFlgOf[u.Conf.STATUS_BONUS_PARTS.BUDDY]) return;
            if (e === this._isShowingStatusBonusBuddy) return;
            e ? this.ab.statusBonusBuddyNode.play("play") : this.ab.statusBonusBuddyNode.play("stop"), this._isShowingStatusBonusBuddy = e
        },
        getAbilityNodeDuplicateOptions: function(e) {
            var t = {
                visualParentLayer: this.battleViewController.battleLayer.layerName,
                visualParentNode: r("%s_%s_pos_nul_%s", this.nodePrefix, e, this.posId)
            };
            return t
        },
        setAbilityShotAttractor: function(e) {
            e.setAttractor("shot_particle", r("%s_attractor_%s", this.nodePrefix, this.posId), {
                attractorLayer: this.battleViewController.battleLayer.layerName
            })
        },
        setTouchVisible: function(e) {
            this.ab.touchNode.setVisible(e), this.flush()
        },
        getUid: function() {
            return this._uid
        },
        registerIsInAnimation: function() {
            this._isInAnimationList.push(!0)
        },
        unregisterIsInAnimation: function() {
            this._isInAnimationList.shift()
        },
        isInAnimation: function() {
            return this._isInAnimation || this._isInAnimationList.length > 0
        },
        getStatusAilmentsTranceAura: function(e) {
            e = e || {};
            if (!!e.shouldCreateIfNotExists && !this.ab.statusAilmentsTranceAura) {
                var t = this.battleViewController.assetsManager.getAssetInfo("back_eff");
                this.ab.statusAilmentsTranceAura = new s({
                    name: r("%s_character_eff_trance_nul_%s", this.nodePrefix, this.posId),
                    layer: t.layerName,
                    duplicateFrom: "character_eff_back_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.ab.characterNode.layer,
                        visualParentNode: "character_eff_back_pos_nul",
                        visualParentTopNode: this.ab.characterNode.name
                    }
                })
            }
            return this.ab.statusAilmentsTranceAura
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush(), this.weaponEquipNodes = null
        }
    }), FF.ns.battle.view.BuddyView
}), define("scenes/battle/view/CommandView", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/EventBase"], function(e, t, n, r, i, s) {
    var o = FF.ns.battle;
    return FF.ns.battle.view.CommandView = s.extend({
        initialize: function(t) {
            this.battleViewController = t.battleViewController;
            var n = this.battleViewController.battleLayer;
            this.commandSet = {}, this.selector = void 0, this.isAnimating = !1, this.visible = !1, this.skipTouchEnabled = !0, this.canSkip = !1, this._isInAuto = !1, this._autoButtonEnabled = !0, this.ab = {}, this.ab.footerBaseNode = n.createNode("menu_footer_nul").setVisible(!0), this.ab.footerBgNode = this.ab.footerBaseNode.createChildNode("image_footer_bg").play("command_change_out").setVisible(!0), this.ab.skipButtonNode = this.ab.footerBaseNode.createChildNode("skip_nul").setVisible(!1), this.ab.skipVisibleTouchNode = this.ab.skipButtonNode.createChildNode("skip_visible_touch"), this.ab.commandNode = this.ab.footerBaseNode.createChildNode("command_nul").setVisible(!1), this.ab.criticalNode = this.ab.footerBaseNode.createChildNode("critical_nul").setVisible(!1), this.ab.criticalSelectNode = this.ab.footerBaseNode.createChildNode("critical_select").setVisible(!1), this.ab.charaNameNode = this.ab.footerBaseNode.createChildNode("chr_name_txt").setVisible(!1), this.ab.autoButtonNode = this.ab.footerBaseNode.createChildNode("auto_nul").setVisible(!0), this.ab.autoCancelButtonNode = this.ab.footerBaseNode.createChildNode("auto_cancel_nul").setVisible(!0), this.ab.autoTextNode = this.ab.footerBaseNode.createChildNode("auto_text_nul").setVisible(!0), this.ab.autoVisibleTouchNode = this.ab.autoButtonNode.createChildNode("auto_visible_touch"), this.ab.autoCancelVisibleTouchNode = this.ab.autoCancelButtonNode.createChildNode("auto_cancel_visible_touch"), this.ab.autoButtonNode.play("command_change_in").process();
            var r = o.DataConstructor.getAllPanelPosIds();
            e.each(r, function(e) {
                this.commandSet[e] = new o.view.AbilityPanelView({
                    battleViewController: this.battleViewController,
                    posId: e,
                    topNode: this.ab.footerBaseNode
                })
            }, this), this.specialCommand = new o.view.SoulStrikeView({
                battleViewController: this.battleViewController,
                topNode: this.ab.footerBaseNode
            }), this.listenTo(this.specialCommand, o.view.SoulStrikeView.EVENTS.SOUL_STRIKE_SELECTOR_SHOWN, e.bind(this._handleSoulStrikeSelectorEvent, this)), this.listenTo(this.specialCommand, o.view.SoulStrikeView.EVENTS.SOUL_STRIKE_SELECTOR_HIDDEN, e.bind(this._handleSoulStrikeSelectorEvent, this)), this._skipButtonVisible = void 0, this._commandSetTouchEnabled = void 0, this.flush()
        },
        showCommands: function(t) {
            var n = t.panelInfoArray,
                r = t.specialInfo,
                i = [];
            e.each(n, function(e) {
                this.commandSet[e.posId].setPanelInfo(e), i.push(e.posId)
            }, this), e.each(this.commandSet, function(t, n) {
                e.contains(i, n) || t.setVisible(!1)
            }, this), this.showSkipButton(t.canSkip), this.specialCommand.setSoulStrikeInfo(r)
        },
        showAutoButton: function(e) {
            e ? this._isInAuto || (this.ab.autoButtonNode.play("command_change_out").process(), this.ab.autoCancelButtonNode.play("command_change_in").process(), this.ab.autoTextNode.play("command_change_in").process(), this._isInAuto = !0, this.battleViewController.setCanStartPause(!0)) : this._isInAuto && (this.ab.autoCancelButtonNode.play("command_change_out").process(), this.ab.autoButtonNode.play("command_change_in").process(), this.ab.autoTextNode.play("command_change_out").process(), this._isInAuto = !1, this.battleViewController.setCanStartPause(!0))
        },
        setAutoButtonEnabled: function(e) {
            e = !!e, this._autoButtonEnabled !== e && (this._autoButtonEnabled = e, this._updateAutoButtonEnabled())
        },
        _updateAutoButtonEnabled: function() {
            var e = this._autoButtonEnabled && !this.specialCommand.isSoulStrikeSelectorMenuShown();
            this.ab.autoCancelButtonNode.setVisible(e).process(), this.ab.autoButtonNode.setVisible(e).process(), this.ab.autoTextNode.setVisible(e).process()
        },
        showSkipButton: function(e) {
            if (e === this.canSkip) return;
            this.canSkip = e, this._updateSkipButtonVisible()
        },
        resetSpecialCommand: function() {
            this.specialCommand.resetTag()
        },
        setTouch: function(t) {
            var n = this;
            e.each(this.commandSet, function(e) {
                e.setTouchEnded(function(e) {
                    if (!n._isSpecialCommandUIBusy()) return;
                    var r = n.getCurrentSelectorUid();
                    t(r, e)
                })
            })
        },
        setSpecialTouch: function(e) {
            var t = this;
            this.specialCommand.setTouchEnded(function() {
                var n = t.getCurrentSelectorUid();
                e(n)
            })
        },
        setSpecialPanelTouch: function(e) {
            var t = this;
            this.specialCommand.setSpecialPanelTouch(function(n) {
                var r = t.getCurrentSelectorUid();
                e(r, n)
            })
        },
        setAutoTouch: function(e) {
            var t = this;
            this.ab.autoVisibleTouchNode.addCallback("action_touch_began", function() {
                if (!t._isSpecialCommandUIBusy()) return;
                t._isInAuto || e()
            }), this.ab.autoCancelVisibleTouchNode.addCallback("action_touch_began", function() {
                if (!t._isSpecialCommandUIBusy()) return;
                t._isInAuto && e()
            })
        },
        setSkipTouch: function(e) {
            function n() {
                return o.DataConstructor.canOperateBattle() ? t.skipTouchEnabled ? t._isSpecialCommandUIBusy() ? !0 : !1 : !1 : !1
            }
            var t = this;
            this.ab.skipVisibleTouchNode.addCallback("action_touch_ended", function() {
                if (!n()) return;
                t.skipTouchEnabled = !1, t.battleViewController.setCanStartPause(!1), t.ab.skipButtonNode.play("command_tap_end").processDeferred("action_stop").then(function() {
                    t.battleViewController.setCanStartPause(!0);
                    var n = t.getCurrentSelectorUid();
                    e(n)
                })
            }), this.ab.skipVisibleTouchNode.addCallback("action_touch_began", function() {
                if (!n()) return;
                t.battleViewController.setCanStartPause(!1), t.ab.skipButtonNode.play("command_tap_start").process()
            }), this.ab.skipVisibleTouchNode.addCallback("action_touch_enterd", function() {
                if (!n()) return;
                t.battleViewController.setCanStartPause(!1), t.ab.skipButtonNode.play("command_tap_start").process()
            }), this.ab.skipVisibleTouchNode.addCallback("action_touch_exited", function() {
                if (!n()) return;
                t.ab.skipButtonNode.play("command_tap_cancel").processDeferred("action_stop").then(function() {
                    t.battleViewController.setCanStartPause(!0)
                })
            }), this.flush()
        },
        setSoulStrikeSelectorVisibleChangeHandler: function(e) {
            this._soulStrikeSelectorVisibleChangeHandler = e
        },
        setSpecialGauge: function(e) {
            this.specialCommand.setSoulStrikeGauge(e)
        },
        commandInDeferred: function(n, r) {
            var i = this,
                s = t.Deferred();
            return this.selector && n.uid === this.selector.uid ? (this.showCommands(r), s.resolve().promise()) : this.isAnimating || this.visible ? s.resolve().promise() : (this.selector = n, this.showCommands(r), this.isAnimating = !0, this.battleViewController.toggleCursor(n.uid), this.ab.commandNode.setVisible(!0).process(), this.ab.criticalNode.play("command_change_in", {
                node: "critical_btn_anm_nul",
                isPlayChild: !1
            }), this.ab.criticalNode.play("command_change_in", {
                node: "critical_gauge_anm_nul",
                isPlayChild: !0
            }), this.ab.criticalNode.setVisible(!0).process(), this.ab.criticalSelectNode.play("command_change_in", {
                node: "critical_select_gauge_anm",
                isPlayChild: !0
            }), this.ab.criticalSelectNode.setVisible(!0).process(), this.specialCommand.showSoulStrikePanel(), this.specialCommand.updateGaugeCursorVisible(), this._updateSkipButtonVisible(), this._updateAutoButtonEnabled(), this._updateCommandSetTouchEnabled(), this.ab.charaNameNode.setVisible(!0).play("command_change_in").process(), this.ab.footerBgNode.play("command_change_in").process(), this.ab.commandNode.play("command_change_in").processDeferred("action_stop").then(function() {
                i.isAnimating = !1, i.visible = !0, i.setTouchEnabled(!0)
            }), e.each(this.commandSet, function(e) {
                e.commandInParticleBurstDeferred()
            }, this), s.promise())
        },
        commandOutDeferred: function(n) {
            var r = this;
            n = n || {};
            var i = t.Deferred();
            return this.isAnimating || !this.visible ? i.resolve().promise() : (this.isAnimating = !0, r.setTouchEnabled(!1), this.ab.criticalNode.play("command_change_out", {
                node: "critical_btn_anm_nul",
                isPlayChild: !1
            }), this.ab.criticalNode.play("command_change_out", {
                node: "critical_gauge_anm_nul",
                isPlayChild: !0
            }), this.ab.criticalNode.process(), this.ab.criticalSelectNode.play("command_change_out", {
                node: "critical_select_gauge_anm",
                isPlayChild: !0
            }), this.ab.criticalSelectNode.setVisible(!0).process(), n.keepCurrentMenu || this.specialCommand.hideSoulStrikePanelMenu(), this.specialCommand.hideSoulStrikePanel(), this.ab.charaNameNode.play("command_change_out").process(), this.ab.footerBgNode.play("command_change_out").process(), this.showSkipButton(!1), this._updateSkipButtonVisible(), this._updateAutoButtonEnabled(), this._updateCommandSetTouchEnabled(), this.ab.commandNode.play("command_change_out").processDeferred("action_stop").then(function() {
                r.isAnimating = !1, r.visible = !1, r.selector = void 0, r.specialCommand.reset()
            }), e.each(this.commandSet, function(e) {
                e.commandOutParticleBurstDeferred()
            }, this), i.promise())
        },
        cancelSoulStrikePanelTouch: function() {
            this.setTouchEnabled(!0)
        },
        setTouchEnabled: function(e) {
            this._commandSetTouchEnabled = e, this._updateCommandSetTouchEnabled(), this.skipTouchEnabled = e, this.specialCommand.setTouchEnabled(e)
        },
        _updateCommandSetTouchEnabled: function() {
            var t = this;
            e.each(this.commandSet, function(e) {
                e.touchEnabled = t._commandSetTouchEnabled && !t.specialCommand.isSoulStrikeSelectorMenuShown()
            })
        },
        setTouchVisible: function(t) {
            e.each(this.commandSet, function(e) {
                e.setTouchVisible(t)
            }), this.specialCommand.setTouchVisible(t), this.ab.skipVisibleTouchNode.setVisible(t), this.flush()
        },
        _updateSkipButtonVisible: function() {
            var e = this.canSkip && !this.specialCommand.isSoulStrikeSelectorMenuShown();
            if (this._skipButtonVisible === e) return;
            this._skipButtonVisible = e, this._skipButtonVisible ? this.ab.skipButtonNode.setVisible(!0).play("command_change_in").process() : this.ab.skipButtonNode.play("command_change_out").setVisible(!1).process()
        },
        _handleSoulStrikeSelectorEvent: function() {
            this._updateSkipButtonVisible(), this._updateAutoButtonEnabled(), this._updateCommandSetTouchEnabled(), this._soulStrikeSelectorVisibleChangeHandler && this._soulStrikeSelectorVisibleChangeHandler()
        },
        _isSpecialCommandUIBusy: function() {
            return this.specialCommand.resetMenuButtons(), !this.specialCommand.isSoulStrikeSelectorMenuShown() && !this.specialCommand.isMenuUILocked()
        },
        isSoulStrikeSelectorMenuShown: function() {
            return this.specialCommand && this.specialCommand.isSoulStrikeSelectorMenuShown()
        },
        isChangedSelector: function(e) {
            return this.selector && e.uid !== this.selector.uid
        },
        getCurrentSelectorUid: function() {
            return this.selector && this.selector.uid
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            this.stopListening()
        }
    }), FF.ns.battle.view.CommandView
}), define("scenes/battle/view/MateriaDropView", ["underscore", "jquery", "backbone", "lib/ab/ABLayer", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i, s) {
    return FF.ns.battle.view.MateriaDropView = s.extend({
        initialize: function(e) {
            var t = this;
            this.battleViewController = e.battleViewController, this.ab = {};
            var n = this.battleViewController.battleLayer,
                r = this.battleViewController.assetsManager.getAssetInfo("materia_get");
            this.ab.node = new i({
                name: "cutin_nul",
                layer: r.layerName,
                visualParentTo: "cutin_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: n.layerName
                }
            });
            var s = this.ab.node.createChildNode("cutin_bt_nul_01");
            s.addCallback("action_touch_began", function() {
                if (!t._touchEnabled) return;
                s.play("tap_start").process()
            }), s.addCallback("action_touch_ended", function() {
                if (!t._touchEnabled) return;
                s.play("tap_end").process(), t._touchDeferred && t._touchDeferred.resolve()
            }), s.process(), this._touchDeferred = void 0, this._touchEnabled = !1
        },
        showDeferred: function(e) {
            var n = this,
                r = e.name,
                i = {
                    posId: e.buddyPos
                },
                s = sprintf("item-%d", e.itemId);
            this.battleViewController.setCanStartPause(!1);
            var o = this.ab.node;
            o.setText("cutin_body_txt", r);
            var u = this.battleViewController.assetsManager.getAssetInfo(s);
            o.loadBundle(u.bundle).setImage("materia_img", u.assetPath);
            var a = this.battleViewController.getActorView(i),
                f = this.battleViewController.assetsManager.getAssetInfo(a.baseSpriteId);
            o.loadBundle(f.bundle).setSpriteAnimeByNode("chara_sprite", f.assetPath);
            var l = this._enableTouchDeferred();
            return t.Deferred().resolve().then(function() {
                var e = o.createChildNode("cutin_bg_nul");
                return e.play("scale_window_1", {
                    autoRemove: !1
                }).processDeferred("action_stop")
            }).then(function() {
                return o.play("in").processDeferred("action_stop")
            }).then(function() {
                return n._waitAnyDeferred([o.play("loop").processDeferred("action_stop"), l])
            }).then(function() {
                return o.play("out").processDeferred("action_stop")
            }).then(function() {
                return n.battleViewController.setCanStartPause(!0), n._disableTouchDeferred()
            })
        },
        _enableTouchDeferred: function() {
            var e = t.Deferred();
            return this._touchDeferred = e, this._touchEnabled = !0, e.promise()
        },
        _disableTouchDeferred: function() {
            this._touchDeferred = void 0, this._touchEnabled = !1
        },
        _waitAnyDeferred: function(e) {
            var n = t.Deferred(),
                r = function() {
                    n.resolve()
                };
            for (var i = 0, s = e.length; i < s; i++) e[i].then(r);
            return n.promise()
        }
    }), FF.ns.battle.view.MateriaDropView
}), define("scenes/battle/view/DropItemView", ["underscore", "jquery", "backbone", "lib/ClassBase", "lib/ab/ABNode"], function(e, t, n, r, i) {
    var s = FF.ns.battle,
        o = s.Conf,
        u = {};
    u[o.DROP_ITEM_TYPE.POTION] = "_setCureNode", u[o.DROP_ITEM_TYPE.HI_POTION] = "_setCureNode", u[o.DROP_ITEM_TYPE.X_POTION] = "_setCureNode", u[o.DROP_ITEM_TYPE.ETHER] = "_setCureNode", u[o.DROP_ITEM_TYPE.TURBO_ETHER] = "_setCureNode", u[o.DROP_ITEM_TYPE.TREASURE] = "_setTreasureNode", u[o.DROP_ITEM_TYPE.ORB] = "_setOrbNode";
    var a = {
        DROP_GIL_SOUND: "se_battle_101026"
    };
    FF.ns.battle.view.DropItemView = r.extend({
        initialize: function(e) {
            this.posId = e.posId, this.childPosId = e.childPosId || "1", this.battleViewController = e.battleViewController;
            var t = this.battleViewController.battleLayer,
                n = this.battleViewController.getActorView({
                    isEnemy: !0,
                    posId: this.posId,
                    childPosId: this.childPosId
                });
            this.hasCureItem = void 0, this.dropItemNode = new i({
                name: sprintf("enemy_drop_item_nul_%s_%s", this.posId, this.childPosId),
                layer: t.layerName,
                duplicateFrom: "drop_item_nul",
                duplicateFromOptions: {
                    visualParentLayer: n.ab.characterEffNode.layer,
                    visualParentNode: "character_eff",
                    visualParentTopNode: n.ab.characterEffNode.name
                }
            })
        },
        dropItemDeferred: function(t) {
            var n = this,
                r = [],
                i = !1;
            return e.each(t, function(e) {
                e.type === s.Conf.DROP_ITEM_TYPE.GIL ? i = !0 : r.push(e)
            }), i || this.dropItemNode.setVisible(!1, {
                node: "drop_item_gil_particle",
                topNode: this.dropItemNode.name
            }), this.dropItemNode.setVisible(!1, {
                node: "drop_item_anm_nul_01",
                topNode: this.dropItemNode.name
            }), this.dropItemNode.setVisible(!1, {
                node: "drop_item_anm_nul_02",
                topNode: this.dropItemNode.name
            }), e.each(r, function(e) {
                var t = n.battleViewController.assetsManager.getAssetInfo(e.assetId),
                    r = n._getDropPos(e.type);
                n.dropItemNode.setVisible(!0, {
                    node: sprintf("drop_item_anm_nul_%s", r),
                    topNode: n.dropItemNode.name
                }), n._adjustParticleByRarity(e), n.dropItemNode.loadBundle(t.bundle).setImage(sprintf("drop_item_img_%s", r), t.assetPath);
                var i = n._getFuncName(e.type);
                if (!n[i]) throw new Error("invalid drop item type.t=" + e.type);
                n[i](e)
            }), i && this.battleViewController.battleLayer.createNode("gil_nul").addCallbackOnce("action_se_gil", function() {
                FF.SoundMgr.playEffect(a.DROP_GIL_SOUND)
            }).play("drop_item").process(), this.dropItemNode.play("drop_item").processDeferred("action_stop")
        },
        _adjustParticleByRarity: function(e) {
            var t = this._getDropPos(e.type);
            e.rarity <= 2 && this.dropItemNode.setVisible(!1, {
                node: sprintf("drop_item_eff_particle_%s_02", t),
                topNode: this.dropItemNode.name
            }), e.rarity <= 1 && this.dropItemNode.setVisible(!1, {
                node: sprintf("drop_item_eff_particle_%s_01", t),
                topNode: this.dropItemNode.name
            }), e.rarity >= 5 && e.type === s.Conf.DROP_ITEM_TYPE.ORB && this.dropItemNode.setVisible(!0, {
                node: "drop_item_front_eff_particle",
                topNode: this.dropItemNode.name
            })
        },
        _getDropPos: function(e) {
            return e === s.Conf.DROP_ITEM_TYPE.TREASURE || e === s.Conf.DROP_ITEM_TYPE.ORB ? "01" : "02"
        },
        _getFuncName: function(e) {
            var t = u[e];
            if (!t) throw new Error("invalid drop item type.t=" + e);
            return t
        },
        _setCureNode: function(e) {
            this.hasCureItem = !0
        },
        _setTreasureNode: function(e) {
            var t = this.battleViewController.assetsManager.getAssetInfo(e.assetId);
            this._itemName = "treasure", this.dropItemNode.setVisible(!0, {
                node: "drop_item_treasure_particle_01",
                topNode: this.dropItemNode.name
            }), this.dropItemNode.loadBundle(t.bundle).setParticleTexture("drop_item_treasure_particle_01", t.assetPath, {
                descendant: !0
            })
        },
        _setOrbNode: function(e) {
            var t = this.battleViewController.assetsManager.getAssetInfo(e.assetId);
            this._itemName = "orb", this.dropItemNode.setVisible(!0, {
                node: "drop_item_orb_particle_01",
                topNode: this.dropItemNode.name
            }), this.dropItemNode.loadBundle(t.bundle).setParticleTexture("drop_item_orb_particle_01", t.assetPath, {
                descendant: !0
            })
        },
        workDeferred: function() {
            var e = this,
                n = [];
            if (this._itemName) {
                var r = t.Deferred(),
                    i = t.Deferred(),
                    s = this._itemName,
                    o = this.battleViewController.battleLayer.createNode(s + "_nul");
                this.dropItemNode.play("drop_item_close", {
                    node: "drop_item_anm_nul_01",
                    topNode: this.dropItemNode.name
                }).addCallbackOnce("action_particle_disappear", function() {
                    i.resolve()
                }, {
                    node: sprintf("drop_item_%s_particle_01", s),
                    topNode: this.dropItemNode.name
                }).addCallbackOnce("action_stop", function() {
                    r.resolve()
                }, {
                    tag: "drop_item_close",
                    node: "drop_item_anm_nul_01",
                    topNode: this.dropItemNode.name
                }), o.play("drop_item_close").process(), n.push(i.promise()), n.push(r.promise())
            }
            if (this.hasCureItem) {
                var u = t.Deferred();
                this.dropItemNode.play("drop_item_cure", {
                    node: "drop_item_anm_nul_02",
                    topNode: this.dropItemNode.name
                }).addCallbackOnce("action_stop", function() {
                    u.resolve()
                }, {
                    tag: "drop_item_cure",
                    node: "drop_item_anm_nul_02",
                    topNode: this.dropItemNode.name
                }), n.push(u.promise())
            }
            return this.dropItemNode.process(), t.when.apply(null, n)
        },
        dispose: function() {
            this.dropItemNode.deleteNode().process()
        }
    })
}), define("scenes/battle/view/EnemyContainer", ["underscore", "jquery", "backbone", "sprintf", "lib/ClassBase", "lib/ab/ABNode", "lib/ab/ABLayer"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle;
    return FF.ns.battle.view.EnemyContainer = i.extend({
        initialize: function(e) {
            this.enemyViews = {}, this.posId = e.posId, this.usesFixPos = e.usesFixPos, this.viewController = e.battleViewController, this.mainAssetId = e.mainAssetId, this._isVisualized = void 0, this._posArray = [], this._posArrayDead = []
        },
        _updatePosArray: function(t) {
            var n = e.difference(this._posArray, this._posArrayDead),
                r = e.difference(t, n),
                i = e.difference(n, t);
            return this._posArray = t, this._posArrayDead = [], {
                posArrayIn: r,
                posArrayOut: i
            }
        },
        playDeformDeferred: function(n, r, i, s) {
            var o = [],
                u = this,
                a = this._updatePosArray(r),
                f = a.posArrayIn,
                l = a.posArrayOut;
            return this.hideHpGauge(l), n === "in" && this.visualize(!0), o.push(this.mainNode.play(n).processDeferred("action_stop")), i && (o.push(this.mainEffNode.play(n).processDeferred("action_stop"), this.mainSightNode.play(n).processDeferred("action_stop"), this.mainInfoNode.play(n).processDeferred("action_stop")), o.push(this.viewController.closeTargetArrowOnDeformStartingDeferred())), e.each(this.enemyViews, function(t, i) {
                e.contains(r, i) && t.ab.characterPositionNode.setVisible(!0), o.push(t.ab.characterNode.play(n).processDeferred("action_stop")), t.setPlayTag("idle", s.isRandom), t.ab.colorChangeLoopNode.setVisible(!1), t.ab.colorChangeSinglePosNode.setVisible(!0), t.ab.touchNode.setVisible(!1), e.contains(l, i) && t.setVisibleSurrounding(!1), t.flush()
            }), t.when.apply(null, o).then(function() {
                i && u.viewController.openTargetArrowOnDeformFinishing(), e.each(r, function(t) {
                    var n = u.enemyViews[t];
                    n.ab.touchNode.setVisible(!0), e.contains(f, t) && n.setVisibleSurrounding(!0), n.ab.colorChangeLoopNode.setVisible(!0), n.ab.colorChangeSinglePosNode.setVisible(!1), n.flush()
                }), u.showHpGauge(f, s.invisibleHpGaugePosArray)
            })
        },
        updatePosArray: function(t) {
            var n = e.uniq([].concat(this._posArray, t)),
                r = e.difference(n, this._posArray),
                i = e.difference(n, t);
            this._posArray = t, e.each(this.enemyViews, function(t, n) {
                e.contains(i, n) ? (t.ab.touchNode.setVisible(!1), t.setVisibleSurrounding(!1)) : e.contains(r, n) && (t.ab.touchNode.setVisible(!0), t.setVisibleSurrounding(!0)), t.flush()
            }), this.showEnemyName(2e3), this.setHpGaugeEnabled(!0)
        },
        showEnemyName: function(t) {
            var n = this;
            e.each(this._posArray, function(e) {
                n.enemyViews[e].setNameEnabled(!0), u.util.DelayCallback.register(t, function() {
                    var t = n.enemyViews[e];
                    t && t.setNameEnabled(!1)
                })
            })
        },
        showEnemyNameDeferred: function(n) {
            var r = this,
                i = [];
            return e.each(this._posArray, function(e) {
                var s = t.Deferred();
                r.enemyViews[e].setNameEnabled(!0), i.push(s.promise()), u.util.DelayCallback.register(n, function() {
                    var t = r.enemyViews[e];
                    t ? t.setNameEnabledDeferred(!1).then(function() {
                        s.resolve()
                    }) : s.resolve()
                })
            }), t.when.apply(t, i)
        },
        setHpGaugeEnabled: function(t) {
            var n = this;
            e.each(this._posArray, function(e) {
                n.enemyViews[e].setHpGaugeEnabled(t)
            })
        },
        showHpGauge: function(t, n) {
            var r = this,
                i = e.difference(t, n);
            FF.logger.debug("showHpGauge", i), e.each(i, function(e) {
                r.enemyViews[e].setHpGaugeEnabled(!0)
            })
        },
        hideHpGauge: function(t) {
            var n = this;
            FF.logger.debug("hideHpGauge", t), e.each(t, function(e) {
                n.enemyViews[e].setHpGaugeEnabled(!1)
            })
        },
        cnt: 0,
        updateEnemyInfo: function(e) {
            this.cnt++;
            var t = this,
                n = e.childPosId || 1;
            if (e.mainAssetId && !this.mainNode) {
                this.visualize(!1);
                var i = this.usesFixPos ? this.posId + "_fix" : this.posId;
                this.mainNode = (new s({
                    name: "character_group_nul",
                    layer: "layer_" + e.mainAssetId,
                    visualParentTo: r("enemy_pos_nul_%s", i),
                    visualParentToOptions: {
                        visualParentLayer: this.viewController.battleLayer.layerName
                    }
                })).setParam({
                    layer_battle_field: this.viewController.battleLayer.layerName,
                    layer_bg: this.viewController.backgroundView.layerName
                }).process(), this.mainEffNode = (new s({
                    name: "character_eff_group_nul",
                    layer: this.mainNode.layer,
                    duplicateFrom: "character_group_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.mainNode.visualParentLayer,
                        visualParentNode: r("enemy_eff_pos_nul_%s", i)
                    }
                })).process(), this.mainSightNode = (new s({
                    name: "character_sight_group_nul",
                    layer: this.mainNode.layer,
                    duplicateFrom: "character_group_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.mainNode.visualParentLayer,
                        visualParentNode: r("enemy_sight_pos_nul_%s", i)
                    }
                })).process(), this.mainInfoNode = (new s({
                    name: "character_info_group_nul",
                    layer: this.mainNode.layer,
                    duplicateFrom: "character_group_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.mainNode.visualParentLayer,
                        visualParentNode: r("enemy_info_pos_nul_%s", i)
                    }
                })).process()
            }
            this.enemyViews[n] || (this.enemyViews[n] = new u.view.EnemyView({
                posId: this.posId,
                childPosId: n,
                battleViewController: this.viewController,
                mainAssetId: e.mainAssetId,
                subAssetId: e.subAssetId,
                offset: e.offset,
                scale: e.scale,
                hpGaugeSize: e.hpGaugeSize
            })), this.enemyViews[n].setEnemyInfo(e), e.isSpEnemy || (this.visualize(!0), this._posArray = [n]), this.enemyViews[n].flush()
        },
        addPosArrayDead: function(e) {
            this._posArrayDead.push("" + e)
        },
        setTouchBegan: function(t) {
            e.each(this.enemyViews, function(e) {
                e.setTouchBegan(t)
            })
        },
        setTouchEnded: function(t) {
            e.each(this.enemyViews, function(e) {
                e.setTouchEnded(t)
            })
        },
        visualize: function(e) {
            if (e === this._isVisualized) return;
            var t = this.usesFixPos ? new s({
                name: "enemy_fix_nul",
                layer: this.viewController.battleLayer.layerName,
                topNodeName: "chr_fix_nul"
            }) : new s({
                name: r("enemy_nul_%s", this.posId),
                layer: this.viewController.battleLayer.layerName,
                topNodeName: "enemy_nul"
            });
            t.setVisible(e).process(), this._isVisualized = e
        },
        dispose: function() {
            e.each(this.enemyViews, function(e, t) {
                e.dispose(), delete this.enemyViews[t]
            }, this), this.visualize(!1)
        }
    }), FF.ns.battle.view.EnemyContainer
}), define("scenes/battle/view/EnemyView", ["underscore", "jquery", "backbone", "sprintf", "lib/ab/ABNode", "lib/ClassBase", "util"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle;
    return FF.ns.battle.view.EnemyView = s.extend({
        initialize: function(e) {
            var t = this;
            this.posId = e.posId, this.offset = e.offset, this.scale = e.scale, this.childPosId = e.childPosId, this.nodePrefix = "enemy", this.spritePrefix = "enemy", this.battleViewController = e.battleViewController, this.ab = {}, this._isTargeted = !1, this._spriteAssetId = void 0, this._currHp = void 0, this._playTag = void 0, this._uid = void 0, this._name = void 0, this._nameHistory = [], this._isInAnimationList = [], this._hpGaugeSize = e.hpGaugeSize;
            var n = this.battleViewController.battleLayer,
                s = n.layerName;
            this._isSpEnemy = e.mainAssetId ? !0 : !1;
            var o = this._isSpEnemy ? e.mainAssetId : r("%s_common_%s", this.nodePrefix, this.posId.charAt(0)),
                a = this.battleViewController.assetsManager.getAssetInfo(o);
            if (!a) throw new Error(r("enemy main asset not found.id=%s", o));
            var f = this.battleViewController.assetsManager.getAssetInfo("status_eff"),
                l = this.battleViewController.assetsManager.getAssetInfo("txt_eff");
            if (this._isSpEnemy) {
                var c = e.subAssetId,
                    h = this.battleViewController.assetsManager.getAssetInfo(c);
                this.ab.characterNode = new i({
                    name: r("character_nul_%s", this.childPosId),
                    layer: h.layerName,
                    touchNodeName: "character_visible_touch",
                    duplicateFrom: "character_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_group_nul"
                    }
                }), this.ab.characterEffNode = new i({
                    name: r("eff_nul_%s", this.childPosId),
                    layer: h.layerName,
                    duplicateFrom: "eff_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_eff_group_nul"
                    }
                }), this.ab.characterSightNode = new i({
                    name: r("sight_nul_%s", this.childPosId),
                    layer: h.layerName,
                    duplicateFrom: "sight_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_sight_group_nul"
                    }
                }), this.ab.characterInfoNode = new i({
                    name: r("info_nul_%s", this.childPosId),
                    layer: h.layerName,
                    duplicateFrom: "info_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_info_group_nul"
                    }
                }), this.ab.characterGaugeNode = new i({
                    name: r("gauge_nul_%s", this.childPosId),
                    layer: h.layerName,
                    duplicateFrom: "gauge_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_gauge_group_nul"
                    }
                }), this.ab.txtEffInfoNode = new i({
                    name: r("%s_txt_eff_info_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                    layer: h.layerName,
                    duplicateFrom: "character_eff",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_info_group_nul"
                    }
                }), this.ab.txtEffNode = new i({
                    name: r("%s_txt_eff_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                    layer: l.layerName,
                    duplicateFrom: "txt_eff_nul",
                    duplicateFromOptions: {
                        visualParentLayer: h.layerName,
                        visualParentNode: this.ab.txtEffInfoNode.name
                    }
                })
            } else this.ab.characterNode = (new i({
                name: r("character_nul_%s", this.posId),
                layer: a.layerName,
                touchNodeName: "character_visible_touch",
                duplicateFrom: "character_nul",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_pos_nul_%s", this.nodePrefix, this.posId)
                }
            })).play("idle"), this.ab.characterEffNode = new i({
                name: r("eff_nul_%s", this.posId),
                layer: a.layerName,
                duplicateFrom: "eff_nul",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_eff_pos_nul_%s", this.nodePrefix, this.posId),
                    visualParentTopNode: "eff_center_nul"
                }
            }), this.ab.characterSightNode = new i({
                name: r("sight_nul_%s", this.posId),
                layer: a.layerName,
                duplicateFrom: "sight_nul",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_sight_pos_nul_%s", this.nodePrefix, this.posId),
                    visualParentTopNode: "sight_center_nul"
                }
            }), this.ab.characterInfoNode = new i({
                name: r("info_nul_%s", this.posId),
                layer: a.layerName,
                duplicateFrom: "info_nul",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId),
                    visualParentTopNode: "info_center_nul"
                }
            }), this.ab.characterGaugeNode = new i({
                name: r("gauge_nul_%s", this.posId),
                layer: a.layerName,
                duplicateFrom: "gauge_nul",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_sight_pos_nul_%s", this.nodePrefix, this.posId),
                    visualParentTopNode: "sight_center_nul"
                }
            }), this.ab.txtEffInfoNode = new i({
                name: r("%s_txt_eff_info_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: a.layerName,
                duplicateFrom: "character_eff",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId),
                    visualParentTopNode: "info_center_nul"
                }
            }), this.ab.txtEffNode = new i({
                name: r("%s_txt_eff_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: l.layerName,
                duplicateFrom: "txt_eff_nul",
                duplicateFromOptions: {
                    visualParentLayer: a.layerName,
                    visualParentNode: this.ab.txtEffInfoNode.name
                }
            });
            this._addCustomActionCallbacks(this.ab.characterNode);
            var p = this.ab.characterNode,
                d = this.ab.characterEffNode,
                v = this.ab.characterInfoNode,
                m = this.ab.characterSightNode,
                g = this.ab.characterGaugeNode;
            this.ab.characterPositionNode = p.createChildNode("character_position_nul"), this.ab.characterActionNode = p.createChildNode("character_action_nul"), this.ab.colorChangeLoopNode = p.createChildNode("character_color_change_loop_nul"), this.ab.colorChangeNode = this.ab.colorChangeLoopNode.createChildNode("character_color_change_nul"), this.ab.colorChangeAddNode = this.ab.colorChangeLoopNode.createChildNode("character_color_change_nul_add"), this.ab.colorChangeSinglePosNode = p.createChildNode("character_color_change_single_pos_nul"), this.ab.colorChangeLoopSingleNode = new i({
                name: r("%s_character_color_change_loop_nul_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: p.layer,
                duplicateFrom: "character_color_change_loop_nul",
                duplicateFromOptions: {
                    parentNode: this.ab.colorChangeSinglePosNode.name,
                    parentTopNode: p.name
                }
            }), this.ab.colorChangeSingleNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_color_change_nul"), this.ab.colorChangeSingleAddNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_color_change_nul_add"), this.ab.characterNode.setParam({
                color_change_parent: this.ab.colorChangeLoopSingleNode.name,
                character_nul: p.name
            }), this.ab.effFrontPosNode = this.ab.characterNode.createChildNode("character_eff_front_pos_nul"), this.ab.effBackPosNode = this.ab.characterNode.createChildNode("character_eff_back_pos_nul"), this._isSpEnemy ? (this.ab.motionNode = p.createChildNode("character_motion_nul"), this.ab.motionAddNode = p.createChildNode("character_motion_nul_add"), this.ab.motionSingleNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_motion_nul"), this.ab.motionSingleAddNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_motion_nul_add")) : this.initPositionScale(), this.ab.nameNode = new i({
                name: r("%s_name_nul_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "enemy_name_nul",
                duplicateFromOptions: {
                    visualParentLayer: v.layer,
                    visualParentNode: "character_info",
                    visualParentTopNode: v.name
                }
            }), this.ab.touchNode = p.createChildNode("character_visible_touch"), this.ab.targetNode = new i({
                name: r("%s_target_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "target_enemy_nul",
                duplicateFromOptions: {
                    visualParentLayer: m.layer,
                    visualParentNode: "character_sight",
                    visualParentTopNode: m.name
                }
            }), this.ab.hpDamageNode = new i({
                name: r("%s_hp_damage_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "hp_damage_nul",
                duplicateFromOptions: {
                    visualParentLayer: v.layer,
                    visualParentNode: "character_info",
                    visualParentTopNode: v.name
                }
            }), this.ab.hpRecoveryNode = new i({
                name: r("%s_hp_recovery_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "hp_recovery_nul",
                duplicateFromOptions: {
                    visualParentLayer: v.layer,
                    visualParentNode: "character_info",
                    visualParentTopNode: v.name
                }
            });
            if (this.isHpGaugeVisible()) {
                this.ab.gaugeNode = (new i({
                    name: r("%s_gauge_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                    layer: "layer_enemy_gauge",
                    duplicateFrom: r("enemy_gauge_nul_%02d", this._hpGaugeSize),
                    duplicateFromOptions: {
                        visualParentLayer: g.layer,
                        visualParentNode: "character_gauge",
                        visualParentTopNode: g.name
                    }
                })).setVisible(!1);
                var y = this.ab.gaugeNode;
                this.ab.hpGaugeNode = y.createChildNode(r("hp_gauge_bar_img_%02d", this._hpGaugeSize)), this.ab.hpGaugeRedNode = y.createChildNode(r("hp_gauge_bar_red_img_%02d", this._hpGaugeSize))
            }
            this.ab.statusAilmentsBalloon = new i({
                name: r("%s_status_icon_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "status_icon_nul",
                duplicateFromOptions: {
                    visualParentLayer: d.layer,
                    visualParentNode: "character_eff",
                    visualParentTopNode: d.name
                }
            }), this.ab.statusAilmentsDoom = new i({
                name: r("%s_death_num_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "death_num_nul",
                duplicateFromOptions: {
                    visualParentLayer: d.layer,
                    visualParentNode: "character_eff",
                    visualParentTopNode: d.name
                }
            }), this.ab.statusAilmentsAura = new i({
                name: r("%s_character_eff_front_nul_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: f.layerName,
                duplicateFrom: "character_eff_front_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.ab.statusAilmentsAura.setScale([-1, 1]), this.ab.statusAilmentsOverlayAura = new i({
                name: r("%s_character_eff_overlay_nul_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: f.layerName,
                duplicateFrom: "character_eff_front_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.ab.statusAilmentsOverlayAura.setScale([-1, 1]), this.statusAilmentsView = new u.view.StatusAilmentsView(this), this._addCustomActionCallbacks(this.ab.txtEffNode), this._isHpGaugeVisualized = !1, this._previousIsInvisible = !1, this.flush()
        },
        _addCustomActionCallbacks: function(e) {
            var t = this;
            e.setParam({
                layer_battle_field: this.battleViewController.battleLayer.layerName,
                layer_bg: this.battleViewController.backgroundView.layerName
            }), e.addCallback("action_shake_part", function() {
                t.battleViewController.startShakeBackground()
            }), e.addCallback("action_shake_part_stop", function() {
                t.battleViewController.stopShakeBackground()
            }), e.addCallback("action_flash", function() {
                t.battleViewController.playFlash()
            }), e.addCallback("action_shake_all", function() {
                t.battleViewController.startShakeField()
            }), e.addCallback("action_shake_all_stop", function() {
                t.battleViewController.stopShakeField()
            })
        },
        initPositionScale: function() {
            this.ab.spriteBaseNode = this.ab.characterNode.createChildNode("sprite_enemy_base"), this.ab.spriteAddNode = this.ab.characterNode.createChildNode("sprite_enemy_add"), this.ab.spriteSingleBaseNode = this.ab.colorChangeLoopSingleNode.createChildNode("sprite_enemy_base"), this.ab.spriteSingleAddNode = this.ab.colorChangeLoopSingleNode.createChildNode("sprite_enemy_add"), this.ab.spriteBaseNode.setPosition(this.offset), this.ab.spriteAddNode.setPosition(this.offset), this.ab.spriteSingleBaseNode.setPosition(this.offset), this.ab.spriteSingleAddNode.setPosition(this.offset), this.ab.shadowScaleNode = this.ab.characterNode.createChildNode("shadow_scale_nul"), this.ab.effFrontPosNode.setScale([this.scale, this.scale]), this.ab.shadowScaleNode.setScale([this.scale, this.scale])
        },
        getTargetPositionDeferred: function() {
            var e = this.battleViewController;
            return e.getScreenPositionDeferred(this.ab.targetNode)
        },
        setEnemyInfo: function(e) {
            if (this.isInAnimation()) return;
            e.spriteAssetId && this.setSprite(e.spriteAssetId), this.setDispName(e.dispName), this.statusAilmentsView.update(e), this._setEffNode(), this._setHpGaugeInfo(e), this._uid = e.uid, this.flush()
        },
        _setEffNode: function() {
            this.ab.effFrontPosNode.setVisible(!0), this.ab.effBackPosNode.setVisible(!0)
        },
        _setHpGaugeInfo: function(e) {
            if (!this.isHpGaugeVisible()) return;
            !e.isInvisible && this._previousIsInvisible && this.showNameAndShowHpGauge(), e.isInvisible && this.setHpGaugeEnabled(!1), this._previousIsInvisible = e.isInvisible, this.setLifeGauge(e.hp, e.maxHp)
        },
        setDispName: function(e) {
            if (e === this._name) return;
            this.ab.nameNode.setText("enemy_name_txt", e), this._name = e
        },
        setNameEnabled: function(t) {
            if (e.contains(this._nameHistory, this._name)) return;
            t ? this.ab.nameNode.setVisible(!0).play("text_in") : (this._nameHistory.push(this._name), this.ab.nameNode.play("text_out")), this.flush()
        },
        setNameEnabledDeferred: function(n) {
            return e.contains(this._nameHistory, this._name) ? t.Deferred().resolve().promise() : n ? this.ab.nameNode.setVisible(!0).play("text_in").processDeferred("action_stop") : (this._nameHistory.push(this._name), this.ab.nameNode.play("text_out").processDeferred("action_stop"))
        },
        setHpGaugeEnabled: function(e) {
            if (!this.isHpGaugeVisible()) return;
            e ? (this._isHpGaugeVisualized || this.ab.gaugeNode.setVisible(!0).play("bar_open"), this._isHpGaugeVisualized = !0) : (this._isHpGaugeVisualized && this.ab.gaugeNode.setVisible(!1), this._isHpGaugeVisualized = !1), this.flush()
        },
        showNameAndShowHpGauge: function() {
            var t = this;
            e.contains(this._nameHistory, this._name) ? this.setHpGaugeEnabled(!0) : (this.setNameEnabled(!0), this.setHpGaugeEnabled(!0), u.util.DelayCallback.register(2e3, function() {
                t.setNameEnabled(!1)
            }))
        },
        setSprite: function(e) {
            if (e === this._spriteAssetId) return;
            var t = this.battleViewController.assetsManager.getAssetInfo(e);
            this.ab.colorChangeLoopNode.loadBundle(t.bundle).setSpriteAnimeByNode(r("sprite_%s_base", this.spritePrefix), t.assetPath).setSpriteAnimeByNode(r("sprite_%s_add", this.spritePrefix), t.assetPath), this.ab.colorChangeLoopSingleNode.loadBundle(t.bundle).setSpriteAnimeByNode(r("sprite_%s_base", this.spritePrefix), t.assetPath).setSpriteAnimeByNode(r("sprite_%s_add", this.spritePrefix), t.assetPath), this._spriteAssetId = e
        },
        setPlayTag: function(e, t) {
            if (!this._isSpEnemy) return;
            if (e === this._playTag) return;
            var n = 0;
            t && (n = o.random()), this.ab.motionNode.play(e, {
                startRatio: n
            }), this.ab.motionAddNode.play(e, {
                startRatio: n
            }), this.ab.motionSingleNode.play(e, {
                startRatio: n
            }), this.ab.motionSingleAddNode.play(e, {
                startRatio: n
            }), this._playTag = e
        },
        setTargetEnabled: function(e) {
            if (e === this._isTargeted) return;
            e ? this.ab.targetNode.play("target_in_enemy") : this.ab.targetNode.play("target_out_enemy"), this.flush(), this._isTargeted = e
        },
        setTouchBegan: function(e) {
            this.setTouchEvent("action_touch_began", e)
        },
        setTouchEnded: function(e) {
            this.setTouchEvent("action_touch_ended", e)
        },
        setTouchEvent: function(e, t) {
            var n = this;
            this.ab.characterNode.addCallback(e, function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                t(n._uid)
            }, {
                layer: this.ab.characterNode.layer,
                topNode: this.ab.characterNode.name,
                node: this.ab.characterNode.touchNodeName
            })
        },
        removeAllCallback: function() {
            this.ab.characterNode.removeAllCallback()
        },
        getCurrHP: function() {
            return this._currHp
        },
        setLifeGauge: function(t, n) {
            if (!this.isHpGaugeVisible()) return;
            if (!e.isNumber(t) || !e.isNumber(n)) throw new Error("invalid life gauge param");
            if (t === this._currHp) return;
            var r = Math.floor((n - t) / n * 100);
            r <= 100 && (this.ab.hpGaugeNode.playFrame("bar", r, r).process(), this.ab.hpGaugeRedNode.playFrame("bar", r, r).process()), this._currHp = t
        },
        setDamageMotionDeferred: function(e, n, r, i, s, o, u, a) {
            a = a || {};
            if (!e) return t.Deferred().resolve().promise();
            var f = void 0,
                l = void 0;
            return s >= 0 ? (f = "" + s, l = o || "damage_red", t.when(this.playDeferred(l), this.playHpDamageDeferred(f, a), this.setLifeGaugeMotionDeferred(n, r, i))) : (f = "" + -1 * s, l = u || "eff_recover", t.when(this.playDeferred(l), this.playHpRecoveryDeferred(f, a), this.setLifeGaugeMotionDeferred(n, r, i)))
        },
        playDeferred: function(n, r) {
            var i = this;
            r = r || {};
            var s = t.Deferred(),
                o = e.extend({
                    isPlayChild: !1
                }, r);
            return this.ab.colorChangeLoopNode.setVisible(!1), this.ab.colorChangeSinglePosNode.setVisible(!0).play(n, o).addCallbackOnce("action_stop", function() {
                i.ab.colorChangeLoopNode.setVisible(!0), i.ab.colorChangeSinglePosNode.setVisible(!1), i.flush(), s.resolve()
            }), this.ab.colorChangeSingleNode.play(n, o), this.ab.colorChangeSingleAddNode.play(n, o), this.flush(), s.promise()
        },
        playHpDamageDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.hpDamageNode, "hp_damage", e, t)
        },
        playHpRecoveryDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.hpRecoveryNode, "hp_recovery", e, t)
        },
        playDigitsDeferred: function(n, i, s, o) {
            var u = t.Deferred();
            o = o || {};
            var a = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7],
                f = String(s).split("").reverse();
            return e.each(a, function(e, t) {
                var s = f[t] || "";
                n.setText(r("%s_%d_txt", i, e), s)
            }), n.addCallbackOnce("action_stop", function() {
                u.resolve()
            }).play("hp_text", o).process(), u.promise()
        },
        playCriticalDeferred: function() {
            return this.ab.txtEffNode.play("critical").processDeferred("action_stop")
        },
        playWeaknessDeferred: function() {
            return this.ab.txtEffNode.play("weakness").processDeferred("action_stop")
        },
        playDefenseDeferred: function() {
            return this.ab.txtEffNode.play("defense").processDeferred("action_stop")
        },
        playAbsorbDeferred: function() {
            return this.ab.txtEffNode.play("absorb").processDeferred("action_stop")
        },
        playResistDeferred: function() {
            return this.ab.txtEffNode.play("resist").processDeferred("action_stop")
        },
        playMissDeferred: function() {
            return this.ab.txtEffNode.play("miss").processDeferred("action_stop")
        },
        playNoeffectDeferred: function() {
            return this.ab.txtEffNode.play("noeffect").processDeferred("action_stop")
        },
        setLifeGaugeMotionDeferred: function(n, r, i) {
            if (!this.isHpGaugeVisible()) return t.Deferred().resolve().promise();
            if (!e.isNumber(n) || !e.isNumber(r) || !e.isNumber(i)) return t.Deferred().resolve().promise();
            if (r === this._currHp) return;
            var s = this,
                o, u, a, f;
            return n > r ? (o = "bar", u = Math.floor((i - n) / i * 100), a = Math.floor((i - r) / i * 100)) : (o = "bar_reverse", u = Math.floor(n / i * 100), a = Math.floor(r / i * 100)), f = e.max([Math.abs(u - a) / 20, 1]), this._currHp = r, this.ab.hpGaugeNode.playFrame(o, u, a, {
                speed: f
            }).processDeferred("action_stop", {
                node: s.ab.hpGaugeNode.name,
                topNode: s.ab.gaugeNode.name
            }).then(function() {
                return s.ab.hpGaugeRedNode.playFrame(o, u, a, {
                    speed: f
                }).processDeferred("action_stop", {
                    node: s.ab.hpGaugeRedNode.name,
                    topNode: s.ab.gaugeNode.name
                })
            })
        },
        setDeadInfo: function(e) {
            e = o.option({
                isApparentDead: !1
            }, e), e.isApparentDead ? this.hideVisibleSurrounding() : this.hide();
            var t = this.battleViewController.enemyContainers[this.posId];
            t.addPosArrayDead(this.childPosId)
        },
        hide: function() {
            this.ab.characterPositionNode.setVisible(!1), this.ab.touchNode.setVisible(!1), this.ab.statusAilmentsAura.setVisible(!1), this.ab.statusAilmentsBalloon.setVisible(!1), this.ab.statusAilmentsDoom.setVisible(!1), this.flush()
        },
        hideVisibleSurrounding: function() {
            this.setVisibleSurrounding(!1), this.flush()
        },
        getAbilityNodeDuplicateOptions: function(e) {
            var t = {
                visualParentLayer: this.ab.characterEffNode.layer,
                visualParentNode: r("character_%s", e),
                visualParentTopNode: this.ab.characterEffNode.name
            };
            return t
        },
        setAbilityShotAttractor: function(e) {
            e.setAttractor("shot_particle", "character_attractor", {
                attractorLayer: this.ab.characterEffNode.layer,
                attractorTopNode: this.ab.characterEffNode.name
            })
        },
        playInDeferred: function(e) {
            return this.setVisibleSurrounding(!0), this.flush(), this.ab.characterNode.play(e).processDeferred("action_stop")
        },
        playOutDeferred: function(e) {
            return this.setVisibleSurrounding(!1), this.flush(), this.ab.characterNode.play(e).processDeferred("action_stop")
        },
        setVisibleSurrounding: function(e) {
            this.ab.targetNode.setVisible(e), this.ab.statusAilmentsAura.setVisible(e), this.ab.statusAilmentsBalloon.setVisible(e), this.ab.statusAilmentsDoom.setVisible(e)
        },
        setTouchVisible: function(e) {
            this.ab.touchNode.setVisible(e), this.flush()
        },
        getUid: function() {
            return this._uid
        },
        registerIsInAnimation: function() {
            this._isInAnimationList.push(!0)
        },
        unregisterIsInAnimation: function() {
            this._isInAnimationList.shift()
        },
        isInAnimation: function() {
            return this._isInAnimationList.length > 0
        },
        isHpGaugeVisible: function() {
            return this._hpGaugeSize > 0
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush()
        }
    }), FF.ns.battle.view.EnemyView
}), define("scenes/battle/view/MenuWindowView", ["underscore", "jquery", "backbone", "sprintf", "lib/BattleConfig", "lib/ab/ABNode", "lib/EventBase"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle,
        a = {
            CLOSE: "close",
            PAUSE: "pause",
            RETIRE: "retire",
            ESCAPE: "escape",
            GAMEOVER: "gameover",
            POWER_UP: "power_up",
            POWER_SELECT: "power_select",
            CONTINUE: "continue",
            FREE_CONFIRM: "system_1",
            FREE_ALERT: "system_2",
            BALANCE_ERROR: "buy_check",
            VC_LIST: "buy_select",
            GEM_AND_MITHRIL_HELP: "gem_and_mithril_help"
        },
        f = {
            PAUSE: "MenuWindowView::pause",
            BACK: "MenuWindowView::back",
            ESCAPE: "MenuWindowView::escape",
            RETIRE: "MenuWindowView::retire",
            CONTINUED: "MenuWindowView::continued",
            CONTINUE_BY_SOUL_PIECE: "MenuWindowView::continueBySoulPiece",
            CONTINUE_BY_COIN: "MenuWindowView::continueByCoin",
            FREE_LEFT: "MenuWindowView::freeLeft",
            FREE_RIGHT: "MenuWindowView::freeRight",
            BALANCE_ERROR_CANCEL: "MenuWindowView::balanceErrorCancel",
            TO_VC_LIST: "MenuWindowView::toVCList",
            BUY_VC: "MenuWindowView::buyVC",
            BUY_VC_CLOSE: "MenuWindowView::buyVCClose",
            GEM_AND_MITHRIL_HELP: "MenuWindowView::gemAndMithrilHelp"
        };
    return FF.ns.battle.view.MenuWindowView = o.extend({
        initialize: function(t) {
            this.battleViewController = t.battleViewController, this.ab = {}, this._listeningEvents = [];
            var n = this.battleViewController.battleLayer,
                r = n.layerName,
                i = this.battleViewController.assetsManager.getAssetInfo("menu_window");
            this.layerName = i.layerName, this.ab.windowMainNode = new s({
                name: "window_main_nul",
                layer: this.layerName,
                visualParentTo: "sys_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: r
                }
            }), FF.env.isTutorial() || (this.ab.frameWaitNode = this._createNode("frame_wait_nul"), this.ab.frameWaitNode.setVisible(!0).process()), this.touchBeganDeferred = void 0, this.btnEnableInfo = {}, this._isOpeningWindow = !1, this._isJustOpeningWindow = !1, this._isJustClosingWindow = !1, this._tappingBtnName = void 0, this._prepareBtnEvent(), this._registerFixedEvent(), this.battleViewController.addIngoreSupendLayers(this.ab.windowMainNode.layer), FF.env.isTutorial() ? this.WINDOW_TAG = e.extend({}, a, {
                PAUSE: "pause_tutorial"
            }) : this.WINDOW_TAG = a
        },
        _prepareBtnEvent: function() {
            var t = this;
            this.ab.pauseToBackNode = this._createBtnNode("pause_bt_1_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t.setInvisible(), t.trigger(f.BACK)
                })
            }), this.ab.pauseToEscapeNode = this._createBtnNode("pause_bt_2_nul", function() {
                t.closeWindowDeferred().then(function() {
                    u.DataConstructor.judgePauseOrEscapeAvailable() ? (t._showWindowDeferred(a.ESCAPE), t.flush()) : t._showEscapeAlertWindow()
                })
            }), this._pauseToBattleSpeedNodes = {}, FF.env.isTutorial() || e.each(i.getBattleSpeedCandidates(), function(e, n) {
                var i = this._createNode(r("wait_toggle_nul_0%d", +n));
                i.addCallback("action_touch_ended", function() {
                    FF.SoundMgr.playChooseEffect(), t._showBattleSpeed(n)
                }), this._pauseToBattleSpeedNodes[n] = i, this.ab[r("pauseToBattleSpeedNode%d", +n)] = i
            }, this), this.ab.escapeYesNode = this._createBtnNode("escape_bt_2_nul", function() {
                t.closeWindowDeferred().then(function() {
                    u.DataConstructor.judgePauseOrEscapeAvailable() ? t.trigger(f.ESCAPE) : t._showEscapeAlertWindow()
                })
            }), this.ab.escapeNoNode = this._createBtnNode("escape_bt_1_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t.setInvisible(), t.trigger(f.BACK)
                })
            }), this.ab.gameoverItemNode = this._createBtnNode("gameover_bt_1_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t.battleViewController.showSystemWindow(u.Conf.SYSTEM_WINDOW.CONFIRM_CONTINUE, function() {
                        t.trigger(f.CONTINUE_BY_SOUL_PIECE)
                    }, function() {
                        t._playBtnEnable(t.ab.gameoverItemNode), t._showWindowDeferred(t.WINDOW_TAG.GAMEOVER)
                    })
                })
            }), this.ab.gameoverCoinNode = this._createBtnNode("gameover_bt_2_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t.trigger(f.CONTINUE_BY_COIN)
                })
            }), this.ab.gameorverRetireNode = this._createBtnNode("gameover_bt_3_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t._showWindowDeferred(t.WINDOW_TAG.RETIRE), t.flush()
                })
            }), this.ab.gameorverTokushouNode = this._createBtnNode("gameover_bt_4_nul", function() {
                kickmotor.platform.resetMobageDashboardListener(), kickmotor.platform.setMobageDashboardListener(function() {}, function() {
                    t._unlockBtnTap(), kickmotor.platform.resetMobageDashboardListener()
                }, function(e) {}), kickmotor.platform.mobageLegal()
            }), this.ab.retireNoNode = this._createBtnNode("retire_bt_2_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t._playBtnEnable(t.ab.gameoverItemNode), t._showWindowDeferred(t.WINDOW_TAG.GAMEOVER)
                })
            }), this.ab.retireYesNode = this._createBtnNode("retire_bt_1_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t.trigger(f.RETIRE)
                })
            }), this.ab.continueBackNode = this._createBtnNode("continue_bt_1_nul", function() {
                var e = t.getContinueBonusView();
                e.setBaseCharaVisible(!1), t.closeWindowDeferred().then(function() {
                    e.deleteNodes(), t.clearContinueBonusView(), t.setInvisible(), t.trigger(f.CONTINUED)
                })
            }), this.ab.freeRightNode = this._createBtnNode("system_bt_nul_01", function() {
                t.closeWindowDeferred().then(function() {
                    t.setInvisible(), t.trigger(f.FREE_RIGHT)
                })
            }), this.ab.freeLeftNode = this._createBtnNode("system_bt_nul_02", function() {
                t.closeWindowDeferred().then(function() {
                    t.setInvisible(), t.trigger(f.FREE_LEFT)
                })
            }), FF.env.isWWRegion() && this._prepareBtnEventWW()
        },
        _prepareBtnEventWW: function() {
            var e = this;
            this.ab.toVCListNode = this._createBtnNode("buy_check_bt_1_nul", function() {
                e.closeWindowDeferred().then(function() {
                    e.setInvisible(), e.trigger(f.TO_VC_LIST)
                })
            }), this.ab.balanceErrorCancelNode = this._createBtnNode("buy_check_bt_2_nul", function() {
                e.closeWindowDeferred().then(function() {
                    e.setInvisible(), e.trigger(f.BALANCE_ERROR_CANCEL)
                })
            }), this.ab.buyVCCloseNode = this._createBtnNode("buy_select_close_nul", function() {
                if (e._vcListView.isSelected) {
                    e.ab.buyVCCloseNode.play("reset").process(), e.touchBeganDeferred = void 0, e._unlockBtnTap();
                    return
                }
                e.closeWindowDeferred().then(function() {
                    e.setInvisible(), e.trigger(f.BUY_VC_CLOSE)
                })
            }), this.ab.gemAndMithrilHelpNode = this._createBtnNode("buy_select_link_nul", function() {
                e.ab.gemAndMithrilHelpCloseNode.setVisible(!0);
                if (e._vcListView.isSelected) {
                    e.ab.gemAndMithrilHelpNode.play("reset").process(), e.touchBeganDeferred = void 0, e._unlockBtnTap();
                    return
                }
                e.closeWindowDeferred().then(function() {
                    e.setInvisible(), e.trigger(f.GEM_AND_MITHRIL_HELP)
                })
            }), this.ab.gemAndMithrilHelpCloseNode = this._createBtnNode("help_select_close_nul", function() {
                e.closeWindowDeferred().then(function() {
                    e.setInvisible(), e.trigger(f.TO_VC_LIST)
                })
            })
        },
        showFreeWindow: function(t) {
            t = e.extend({
                title: "",
                description: "",
                buttons: [{
                    title: "",
                    callback: function() {}
                }]
            }, t), this._setText("system_title_txt", t.title), this._setText("system_txt", t.description);
            var n = void 0;
            e.each(t.buttons, function(e, t) {
                if (t === 0) this._setText("system_bt_txt_01", e.title), this.addCallback(f.FREE_RIGHT, e.callback), n = this.WINDOW_TAG.FREE_ALERT;
                else {
                    if (t !== 1) throw new Error("lots of button info");
                    this._setText("system_bt_txt_02", e.title), this.addCallback(f.FREE_LEFT, e.callback), n = this.WINDOW_TAG.FREE_CONFIRM
                }
            }, this);
            if (!n) throw new Error("button info empty");
            this.flush(), this._showWindowDeferred(n)
        },
        getContinueBonusView: function() {
            if (!this._continueBonusView) {
                var e = this.battleViewController.assetsManager.getAssetInfo("menu_window"),
                    t = new u.view.ContinueBonusView({
                        battleViewController: this.battleViewController,
                        menuLayerInfo: e,
                        windowNode: this.ab.windowMainNode
                    });
                t.setup(), this._continueBonusView = t
            }
            return this._continueBonusView
        },
        clearContinueBonusView: function() {
            this._continueBonusView = void 0
        },
        _registerFixedEvent: function() {
            this.addCallback(f.PAUSE, function() {
                FF.scene.suspend()
            }), this.addCallback(f.BACK, function() {
                FF.scene.resume()
            }), this.addCallback(f.ESCAPE, function() {
                FF.scene.escape()
            }), FF.env.isWWRegion() && this._registerFixedEventWW()
        },
        _registerFixedEventWW: function() {
            var e = this;
            this.addCallback(f.BALANCE_ERROR_CANCEL, function() {
                e._clearBalanceErrorButtons(), e._rejectBalanceErrorWindow()
            }), this.addCallback(f.BUY_VC_CLOSE, function() {
                e._clearVCListView(), e._rejectBalanceErrorWindow(), e.ab.gemAndMithrilHelpNode && e.ab.gemAndMithrilHelpNode.setVisible(!1)
            }), this.addCallback(f.TO_VC_LIST, function() {
                e._clearBalanceErrorButtons(), e.ab.gemAndMithrilHelpCloseNode && e.ab.gemAndMithrilHelpCloseNode.setVisible(!1), e.ab.gemAndMithrilHelpNode && e.ab.gemAndMithrilHelpNode.setVisible(!0), e.setInvisible(), e._showVCListWindowDeferred()
            }), this.addCallback(f.GEM_AND_MITHRIL_HELP, function() {
                e.ab.buyVCCloseNode && e.ab.buyVCCloseNode.setVisible(!1), e.flush(), e._showWindowDeferred(e.WINDOW_TAG.GEM_AND_MITHRIL_HELP)
            })
        },
        _setText: function(e, t) {
            this.ab.windowMainNode.setText(e, t).process()
        },
        _createNode: function(e) {
            var t = this.ab.windowMainNode.createChildNode(e);
            return t
        },
        _createBtnNode: function(e, t) {
            var n = this,
                r = this._createNode(e);
            return this._setBtnEnable(r, !0), r.addCallback("action_touch_began", function() {
                if (!n._isBtnEnable(r)) return;
                if (!n._lockBtnTap(r)) return;
                n.touchBeganDeferred = r.play("tap").processDeferred("action_stop")
            }), r.addCallback("action_touch_ended", function() {
                if (!n._isLockedBtnTap(r) || !n.touchBeganDeferred) return;
                n.touchBeganDeferred.then(function() {
                    FF.SoundMgr.playChooseEffect(), n.touchBeganDeferred = void 0, t()
                })
            }), r.addCallback("action_touch_exited", function() {
                if (!n._isLockedBtnTap(r) || !n.touchBeganDeferred) return;
                n.touchBeganDeferred.then(function() {
                    r.play("reset").process(), n.touchBeganDeferred = void 0, n._unlockBtnTap()
                })
            }), r
        },
        _setBtnEnable: function(e, t) {
            this.btnEnableInfo[e.name] = t
        },
        _isBtnEnable: function(e) {
            return this.btnEnableInfo[e.name] ? !0 : !1
        },
        _playBtnEnable: function(e) {
            this._isBtnEnable(e) ? e.play("reset", {
                autoRemove: !1
            }) : e.play("bt_disable", {
                autoRemove: !1
            }), this.flush()
        },
        _lockBtnTap: function(e) {
            return this._tappingBtnName ? !1 : (this._tappingBtnName = e.name, !0)
        },
        _isLockedBtnTap: function(e) {
            return !!this._tappingBtnName && this._tappingBtnName === e.name
        },
        _unlockBtnTap: function() {
            this._tappingBtnName = void 0
        },
        addCallback: function(t, n) {
            e.contains(this._listeningEvents, t) && this.stopListening(this, t), this.listenTo(this, t, n), this._listeningEvents.push(t), this._listeningEvents = e.uniq(this._listeningEvents)
        },
        startPause: function() {
            var e = this;
            this._showBattleSpeed(), this._showWindowDeferred(this.WINDOW_TAG.PAUSE).then(function() {
                e.flush(), e.trigger(f.PAUSE)
            })
        },
        showGameOverWindow: function(e, t, n, r) {
            var i = this;
            this._setGameOverInfo(e), this.addCallback(f.CONTINUE_BY_SOUL_PIECE, t), this.addCallback(f.CONTINUE_BY_COIN, n), this.addCallback(f.RETIRE, r), this._showWindowDeferred(this.WINDOW_TAG.GAMEOVER)
        },
        _setGameOverInfo: function(e) {
            var t = u.TextMaster.getInstance(),
                n = u.Conf.CONTINUE_TYPE,
                i = Math.floor(e.untilExpire / 3600),
                s = Math.floor(e.untilExpire % 3600 / 60),
                o = r(t.get("B10210"), i, s);
            this._setText("notice_txt", o);
            var a = t.get("mithril");
            this._setText("gameover_bt_1_sub_key_txt", r(t.get("B10180"), a)), this._setText("gameover_bt_1_sub_value_txt", e[n.SOUL_PIECE].balance), this._setText("gameover_bt_1_txt", r(t.get("B10190"), a)), this._setText("gameover_bt_1_num_txt", r(t.get("B10200"), e[n.SOUL_PIECE].payCost)), this._setBtnEnable(this.ab.gameoverItemNode, !!e[n.SOUL_PIECE].canConsume), this._playBtnEnable(this.ab.gameoverItemNode), this._setText("gameover_bt_2_sub_key_txt", r(t.get("B10180"), this._detectCurrencyUnit())), this._setText("gameover_bt_2_sub_value_txt", e[n.COIN].balance), this._setText("gameover_bt_2_txt", r(t.get("B10190"), this._detectCurrencyUnit()));
            var f = FF.env.isWWRegion() ? " " : "";
            this._setText("gameover_bt_2_num_txt", e[n.COIN].payCost + f + this._detectCurrencyUnit())
        },
        showPowerUpWindow: function(e, t) {
            var n = this,
                r = this.getContinueBonusView();
            this.ab.windowMainNode.addCallbackOnce("action_next", function() {
                r.showPreRaise()
            }), this.ab.windowMainNode.addCallbackOnce("action_raise", function() {
                r.showPostRaise()
            }), this._showWindowDeferred(this.WINDOW_TAG.POWER_SELECT).then(function() {
                r.registerCardTouch(e, t)
            })
        },
        showContinueDoneWindow: function(t, n) {
            var i = this,
                s = n.lastBonusId,
                o = n.bonusAmount,
                a = u.TextMaster.getInstance(),
                l = u.Config.getInstance().get("ContinueBonus", s);
            this.ab.stUpColorNode || (this.ab.stUpColorNode = this.ab.windowMainNode.createChildNode("status_up_color_win")), this.ab.stUpColorNode.play(l.colorTag, {
                autoRemove: !1
            }), this._setText("status_up_txt", r(a.get(l.descTextId), "+" + l.boostFactor));
            var c = [];
            e.each(u.Config.getInstance().get("ContinueBonusIds"), function(e) {
                var t = o[e];
                if (!t) return;
                var n = u.Config.getInstance().get("ContinueBonus", e),
                    i = n.boostFactor * t;
                c.push(r(a.get(n.descTextId), i))
            }, this), this._setText("continue_sub_txt", c.join("{n}")), this.addCallback(f.CONTINUED, t), this.flush();
            var h = this.getContinueBonusView();
            h.setBaseCharaVisible(!1), i.closeWindowDeferred().then(function() {
                return h.showPostRaise(), i._showWindowDeferred(i.WINDOW_TAG.CONTINUE)
            })
        },
        _showEscapeAlertWindow: function() {
            var e = this;
            this.battleViewController.showSystemWindow(u.Conf.SYSTEM_WINDOW.ALERT_ESCAPE, function() {
                e.setInvisible(), e.trigger(f.BACK)
            })
        },
        closeWindowDeferred: function() {
            var e = this,
                n = t.Deferred();
            return this._isJustClosingWindow = !0, this.ab.windowMainNode.play(this.WINDOW_TAG.CLOSE).processDeferred("action_stop").then(function() {
                e._isJustClosingWindow = !1, n.resolve()
            }), n.promise()
        },
        _showWindowDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            return this._unlockBtnTap(), this.setOpeningWindow(!0), this._isJustOpeningWindow = !0, this.ab.windowMainNode.setVisible(!0).play(e).processDeferred("action_stop").then(function() {
                n._isJustOpeningWindow = !1, r.resolve()
            }), r.promise()
        },
        _showBattleSpeed: function(e) {
            if (FF.env.isTutorial()) return;
            e || (e = u.DataConstructor.getBattleSpeedIndex()), this._currBattleSpeedIdx && this._pauseToBattleSpeedNodes[this._currBattleSpeedIdx].play("disable").process(), this._pauseToBattleSpeedNodes[e].play("enable").process();
            var t = u.TextMaster.getInstance().get("B15240");
            this.ab.windowMainNode.setText("wait_title_txt", r(t, +e)).process(), this._currBattleSpeedIdx = e, this._callBattleSpeedTouch(e)
        },
        setBattleSpeedTouch: function(t) {
            if (!e.isFunction(t)) throw new TypeError("Argument 1 must be type of Function");
            this._battleSpeedTouch = t
        },
        setInvisible: function() {
            this.setOpeningWindow(!1), this.ab.windowMainNode.setVisible(!1), this.flush()
        },
        _callBattleSpeedTouch: function(e) {
            if (!this._battleSpeedTouch) {
                FF.logger.warn("Undefined property _battleSpeedTouch");
                return
            }
            this._battleSpeedTouch(e)
        },
        _detectCurrencyUnit: function() {
            return u.TextMaster.getInstance().getMobacoinUnit()
        },
        prepareForTutorial: function() {
            var e = this.ab.pauseToEscapeNode;
            this._setBtnEnable(e, !1), this._playBtnEnable(e), this.ab.tutorialText || (this.ab.tutorialText = this.ab.windowMainNode.createChildNode("tutorial_txt")), this.ab.tutorialText.setVisible(!0), this.flush()
        },
        setOpeningWindow: function(e) {
            this._isOpeningWindow = e
        },
        isOpeningWindow: function() {
            return this._isOpeningWindow
        },
        isJustAnimatingWindow: function() {
            return this._isJustOpeningWindow || this._isJustClosingWindow
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush(), this._battleSpeedTouch = void 0
        },
        _rejectBalanceErrorWindow: function() {
            if (this._balanceErrorD) {
                var e = this._balanceErrorD;
                this._balanceErrorD = void 0, e.reject()
            }
        },
        _clearBalanceErrorButtons: function() {
            this.ab.balanceErrorCancelNode && this.ab.balanceErrorCancelNode.setVisible(!1), this.ab.toVCListNode && this.ab.toVCListNode.setVisible(!1)
        },
        _showBalanceErrorButtons: function() {
            this.ab.balanceErrorCancelNode && this.ab.balanceErrorCancelNode.setVisible(!0), this.ab.toVCListNode && this.ab.toVCListNode.setVisible(!0), this.flush()
        },
        _clearVCListView: function() {
            this.ab.buyVCCloseNode && this.ab.buyVCCloseNode.setVisible(!1), this._vcListView && (this._vcListView.setButtonVisibility(!1), this._vcListView.deleteNodes()), this._vcListView = void 0
        },
        showBalanceErrorWindowDeferred: function(e, n) {
            var i = this;
            this._balanceErrorD = t.Deferred();
            var s = u.TextMaster.getInstance(),
                o = r(s.get("B30000"), n - e);
            return this._showBalanceErrorButtons(), this._setText("buy_check_owned_num", e), this._setText("buy_check_needed_num", n), this._setText("buy_check_word_needed", o), this._showWindowDeferred(this.WINDOW_TAG.BALANCE_ERROR).then(function() {
                i.flush()
            }), this._balanceErrorD.promise()
        },
        confirmWithUserDeferred: function(e, n) {
            var i = t.Deferred(),
                s = u.TextMaster.getInstance(),
                o = r(s.get("BWW15161"), n, e),
                a = {
                    title: s.get("BWW15151"),
                    description: o,
                    buttons: [{
                        title: s.get("yes"),
                        callback: function() {
                            i.resolve()
                        }
                    }, {
                        title: s.get("no"),
                        callback: function() {
                            i.reject()
                        }
                    }]
                };
            return this.showFreeWindow(a), i.promise()
        },
        _showVCListWindowDeferred: function() {
            var e = this,
                n = t.Deferred();
            return this.ab.buyVCCloseNode && this.ab.buyVCCloseNode.setVisible(!0), this.flush(), this._setupVCListViewDeferred().then(function() {
                return e._showWindowDeferred(e.WINDOW_TAG.VC_LIST)
            }).then(function() {
                e.flush(), n.resolve()
            }), n.promise()
        },
        _setupVCListViewDeferred: function() {
            var e = this,
                n = t.Deferred();
            if (this._vcListView) return setTimeout(function() {
                n.resolve()
            }, 0), n.promise();
            var r = this.battleViewController.battleLayer,
                i = r.layerName,
                s = this.battleViewController.assetsManager.getAssetInfo("menu_window"),
                o = new u.view.VCListView({
                    windowMainNode: this.ab.windowMainNode,
                    menuLayerInfo: s,
                    battleLayerName: i
                });
            return o.setupDeferred().done(function() {
                n.resolve(), e._vcListView = o
            }).fail(function() {
                n.reject(), e.battleViewController.showSystemWindow(u.Conf.SYSTEM_WINDOW.NETWORK)
            }), n.promise()
        },
        endPause: function() {
            var e = this;
            e.closeWindowDeferred().then(function() {
                e.setInvisible(), e.trigger(f.BACK)
            })
        }
    }), FF.ns.battle.view.MenuWindowView
}), define("scenes/battle/view/LoadingView", ["underscore", "jquery", "sprintf", "lib/ab/ABNode", "lib/EventBase"], function(e, t, n, r, i) {
    var s = FF.ns.battle;
    return FF.ns.battle.view.LoadingView = i.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.ab = {};
            var t = this.battleViewController.battleLayer,
                n = this.battleViewController.assetsManager.getAssetInfo("loading");
            this.ab.loadingNode = new r({
                name: "loading_nul",
                layer: n.layerName,
                visualParentTo: "loading_bottom_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: t.layerName
                }
            }), this.ab.loadingNode.setVisible(!1).process(), this._isOpening = !1, this.battleViewController.addIngoreSupendLayers(this.ab.loadingNode.layer)
        },
        open: function() {
            this.ab.loadingNode.setVisible(!0).play("play"), this.flush(), this._isOpening = !0
        },
        close: function() {
            this.ab.loadingNode.setVisible(!1), this.flush(), this._isOpening = !1
        },
        isOpening: function() {
            return this._isOpening
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush()
        }
    }), FF.ns.battle.view.LoadingView
}), define("scenes/battle/view/MessageView", ["underscore", "jquery", "backbone", "lib/ClassBase"], function(e, t, n, r) {
    return FF.ns.battle.view.MessageView = r.extend({
        initialize: function(e) {
            var t = e.battleViewController.battleLayer;
            this.headerTextNode = t.createNode("header_text_nul")
        },
        show: function(e) {
            this.headerTextNode.setText("header_txt", e), this.headerTextNode.setVisible(!0).process()
        },
        hide: function() {
            this.headerTextNode.setText("header_txt", ""), this.headerTextNode.setVisible(!1).process()
        },
        showForever: function(e) {
            this.headerTextNode.setText("header_txt", e), this.headerTextNode.setVisible(!0).process()
        }
    }), FF.ns.battle.view.MessageView
}), define("scenes/battle/view/SoulStrikeView", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/ab/ABNodeButton", "lib/EventBase"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle,
        a = {
            SOUL_STRIKE_SELECTOR_SHOWN: "ssSelectorShown",
            SOUL_STRIKE_SELECTOR_HIDDEN: "ssSelectorHidden"
        };
    return FF.ns.battle.view.SoulStrikeView = o.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.topNode = e.topNode, this._charaAssetId = void 0, this._enabled = void 0, this._touchEnabled = !0, this._soulStrikeCount = 1, this.touchEndedCallback = void 0, this.touchEndedCallbackWithSlot = void 0, this.ab = {}, this.ab.criticalNode = this.topNode.createChildNode("critical_nul"), this.ab.criticalSelectNode = this.topNode.createChildNode("critical_select"), this.normalSoulStrikeGauge = new FF.ns.battle.view.SoulStrikeGauge(this.ab.criticalNode, "normal"), this.selectorSoulStrikeGauge = new FF.ns.battle.view.SoulStrikeGauge(this.ab.criticalSelectNode, "selector"), this.ab.charaTextNode = this.topNode.createChildNode("chr_name_txt").setVisible(!0), this.ab.textNode = this.ab.criticalNode.createChildNode("critical_text_nul").setVisible(!0), this.ab.buttonNode = this.ab.criticalNode.createChildNode("critical_btn_nul"), this.ab.buttonTouchNode = this.ab.criticalNode.createChildNode("critical_btn_visible_touch"), this._initSoulStrikeSelectorView(), this._switchUI(), this.flush()
        },
        _initSoulStrikeSelectorView: function() {
            var e = this;
            this.ssSelectorView = new FF.ns.battle.view.SoulStrikeSelectorView(this.topNode, this.battleViewController);
            var t = this.ssSelectorView,
                n = FF.ns.battle.view.SoulStrikeSelectorView.EVENTS;
            t.setVisible(!0), t.on(n.OPEN_TOUCHED, function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (!e._touchEnabled) return;
                t.showMenu(), e.trigger(a.SOUL_STRIKE_SELECTOR_SHOWN)
            }), t.on(n.CLOSE_TOUCHED, function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (!e._touchEnabled) return;
                t.hideMenu(), e.trigger(a.SOUL_STRIKE_SELECTOR_HIDDEN)
            }), t.on(n.SLOT_SELECTED, function(t, r) {
                FF.logger.debug(n.SLOT_SELECTED, "soulStrikeInfo:", t, r);
                if (!u.DataConstructor.canOperateBattle()) return;
                if (e._enabled === !1 || !e._touchEnabled) return;
                e._touchEnabled = !1, e.battleViewController.setCanStartPauseBySoulStrikeSelector(!0), e._executeTouchEndCallback(r)
            }), t.on(n.SLOT_TOUCH_START, function(t, n) {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (e._enabled === !1 || !e._touchEnabled) return;
                e.battleViewController.setCanStartPauseBySoulStrikeSelector(!1)
            }), t.on(n.SLOT_TOUCH_CANCEL, function(t, n) {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (e._enabled === !1 || !e._touchEnabled) return;
                e.battleViewController.setCanStartPauseBySoulStrikeSelector(!0)
            }), t.hideAll()
        },
        _isSoulStrikeSelectorMode: function() {
            return this._soulStrikeCount > 1
        },
        setSoulStrikeInfo: function(e) {
            this._soulStrikeCount = e.length || 1;
            var t = !1;
            if (!this._isSoulStrikeSelectorMode()) this._setSoulStrikeInfo(e[0]);
            else {
                var n;
                for (n = 0; n < 4; n++) this._setSoulStrikeInfoToSlot(n + 1, e[n - (4 - this._soulStrikeCount)]);
                for (n = 0; n < this._soulStrikeCount; n++) {
                    var r = e[n];
                    if (r && r.enabled) {
                        t = !0;
                        break
                    }
                }
            }
            this.setSoulStrikeGauge(e[0].point, e[0].consumePoint), this._setCharaName(e[0]), t ? this.ssSelectorView.showOpenBtnEffect() : this.ssSelectorView.hideOpenBtnEffect(), this.flush()
        },
        isSoulStrikeSelectorShown: function() {
            return this.ssSelectorView.isShown()
        },
        isSoulStrikeSelectorMenuShown: function() {
            return this.ssSelectorView.isMenuShown()
        },
        resetMenuButtons: function() {
            this.ssSelectorView.resetMenuButtons()
        },
        isMenuUILocked: function() {
            return this.ssSelectorView.isUILocked()
        },
        _switchUI: function() {
            this._isSoulStrikeSelectorMode() ? (this.ssSelectorView.setVisible(!0), this.ab.buttonNode.setVisible(!1)) : (this.ssSelectorView.setVisible(!1), this.ab.buttonNode.setVisible(!0))
        },
        _setSoulStrikeInfoToSlot: function(e, t) {
            if (t) {
                var n = this.battleViewController.assetsManager.getAssetInfo(t.assetId);
                this.ssSelectorView.setSoulStrikeInfo(e, t, n)
            } else this.ssSelectorView.resetSoulStrikeInfo(e)
        },
        _setSoulStrikeInfo: function(e) {
            this.setSoulStrikeEnabled(e.enabled);
            if (e.charaAssetId === this._charaAssetId) return;
            var t = this.battleViewController.assetsManager.getAssetInfo(e.assetId),
                n = e.soulStrikeDispName ? e.soulStrikeDispName : e.soulStrikeName;
            this.ab.buttonNode.loadBundle(t.bundle).setImage("critical_btn_pos_img", t.assetPath), this.ab.textNode.setText("critical_name_txt", n), this._charaAssetId = e.charaAssetId
        },
        _setCharaName: function(e) {
            this.ab.charaTextNode.setText("chr_name_txt", e.charaName)
        },
        setSoulStrikeEnabled: function(e) {
            if (e === this._enabled) return;
            var t = e ? "enabled_special" : "disabled_special";
            this.ab.buttonNode.play(t).process(), this._enabled = e
        },
        showSoulStrikePanel: function() {
            this.ssSelectorView.hideOpenBtnEffect(), this.ssSelectorView.showAll(), this._switchUI()
        },
        hideSoulStrikePanelMenu: function() {
            this.ssSelectorView.hideMenu(), this.trigger(a.SOUL_STRIKE_SELECTOR_HIDDEN), this.battleViewController.setCanStartPauseBySoulStrikeSelector(!0)
        },
        hideSoulStrikePanel: function() {
            this.ssSelectorView.hideAll(), this.battleViewController.setCanStartPauseBySoulStrikeSelector(!0)
        },
        resetTag: function() {
            var e = this._enabled ? "enabled_special" : "disabled";
            this.ab.buttonNode.play(e).process(), this.ssSelectorView.resetTag()
        },
        setTouchEnabled: function(e) {
            this._touchEnabled = e
        },
        setTouchEnded: function(e) {
            this.touchEndedCallback = e;
            var t = this;
            this.ab.buttonTouchNode.addCallback("action_touch_ended", function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (t._enabled === !1 || !t._touchEnabled) return;
                t._touchEnabled = !1, t.battleViewController.setCanStartPauseBySoulStrikeView(!1), t.ab.buttonNode.play("command_special_tap_end").processDeferred("action_stop").then(function() {
                    t.battleViewController.setCanStartPauseBySoulStrikeView(!0), t._executeTouchEndCallback()
                })
            }), this.ab.buttonTouchNode.addCallback("action_touch_began", function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (t._enabled === !1 || !t._touchEnabled) return;
                t.battleViewController.setCanStartPauseBySoulStrikeView(!1), t.ab.buttonNode.play("command_special_tap_start").process()
            }), this.ab.buttonTouchNode.addCallback("action_touch_enterd", function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (t._enabled === !1 || !t._touchEnabled) return;
                t.battleViewController.setCanStartPauseBySoulStrikeView(!1), t.ab.buttonNode.play("command_special_tap_start").process()
            }), this.ab.buttonTouchNode.addCallback("action_touch_exited", function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (t._enabled === !1 || !t._touchEnabled) return;
                t.ab.buttonNode.play("command_special_tap_cancel").processDeferred("action_stop").then(function() {
                    t.battleViewController.setCanStartPauseBySoulStrikeView(!0)
                })
            }), this.flush()
        },
        setSpecialPanelTouch: function(e) {
            this.touchEndedCallbackWithSlot = e
        },
        _executeTouchEndCallback: function(e) {
            e ? this.touchEndedCallbackWithSlot && this.touchEndedCallbackWithSlot(e.slot) : this.touchEndedCallback && this.touchEndedCallback()
        },
        setSoulStrikeGauge: function(e, t) {
            this.normalSoulStrikeGauge.setSoulStrikeGauge(e, t), this.selectorSoulStrikeGauge.setSoulStrikeGauge(e, t)
        },
        setGaugeCursor: function(e, t) {
            this.normalSoulStrikeGauge.setGaugeCursor(e, t), this.selectorSoulStrikeGauge.setGaugeCursor(e, t)
        },
        updateGaugeCursorVisible: function() {
            this.normalSoulStrikeGauge.setGaugeCursorVisible(!this._isSoulStrikeSelectorMode()), this.selectorSoulStrikeGauge.setGaugeCursorVisible(!this._isSoulStrikeSelectorMode())
        },
        setTouchVisible: function(e) {
            this.ab.buttonTouchNode.setVisible(e).process()
        },
        updateSoulStrikeGauge: function(e, t, n) {
            this.normalSoulStrikeGauge.updateSoulStrikeGauge(e, t, n), this.selectorSoulStrikeGauge.updateSoulStrikeGauge(e, t, n)
        },
        reset: function() {
            this._charaAssetId = void 0, this._enabled = void 0
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t), this.ssSelectorView && this.ssSelectorView.flush(), this.normalSoulStrikeGauge && this.normalSoulStrikeGauge.flush(), this.selectorSoulStrikeGauge && this.selectorSoulStrikeGauge.flush()
        },
        dispose: function() {
            this.ssSelectorView && this.ssSelectorView.dispose(), this.normalSoulStrikeGauge && this.normalSoulStrikeGauge.dispose(), this.selectorSoulStrikeGauge && this.selectorSoulStrikeGauge.dispose()
        }
    }), FF.ns.battle.view.SoulStrikeView.EVENTS = a, FF.ns.battle.view.SoulStrikeView
}), define("scenes/battle/view/SoulStrikeSelectorView", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/ab/ABNodeButton", "lib/EventBase"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle,
        a = "command_special_tap_start",
        f = "command_special_tap_end",
        l = "command_special_tap_cancel",
        c = "command_special_tap_end_2",
        h = "enabled_special",
        p = "disabled_special",
        d = "disabled",
        v = "enabled_special_select",
        m = "disabled_special_select",
        g = "enabled_special_select_eff",
        y = "btn_critical_name_txt",
        b = "btn_critical_img",
        w = "btn_critical_backlight_img",
        E = "btn_critical_enabled_particle",
        S = "btn_critical_tap_particle",
        x = "btn_critical_tap_particle",
        T = "SoulStrikeSelectors",
        N = o.extend({
            initialize: function(e, t, n, i) {
                this.btnReplaceNode = t, this.index = e, this.btnParentNode = n, this.mainNode = new r({
                    name: this.btnReplaceNode.name + "_inserted",
                    layer: this.btnReplaceNode.layer,
                    duplicateFrom: "btn_critical",
                    duplicateFromOptions: {
                        visualParentLayer: this.btnReplaceNode.layer,
                        visualParentNode: this.btnReplaceNode.name
                    }
                }), this.btn = (new s(this.btnParentNode, void 0, T)).setButtonStateTags(a, f, l).setCheckEnabledFunction(i), this.backLightNode = (new r({
                    name: w,
                    layer: this.btnReplaceNode.layer,
                    topNodeName: this.mainNode.name
                })).setVisible(!1).process(), this.imageNode = (new r({
                    name: b,
                    layer: this.btnReplaceNode.layer,
                    topNodeName: this.mainNode.name
                })).setVisible(!1).process(), this.effectParticleNode = (new r({
                    name: E,
                    layer: this.btnReplaceNode.layer,
                    topNodeName: this.mainNode.name
                })).setVisible(!0).process(), this.effectTapParticleNode = (new r({
                    name: S,
                    layer: this.btnReplaceNode.layer,
                    topNodeName: this.mainNode.name
                })).setVisible(!0).process(), this.tapParticleNode = (new r({
                    name: x,
                    layer: this.btnReplaceNode.layer,
                    topNodeName: this.mainNode.name
                })).setVisible(!0).process(), this._lastAssetPath = void 0, this._soulStrikeInfo = void 0, this._viewEnabled = void 0, this._buttonEnabled = void 0, this._hasView = void 0, this._particleVisible = void 0, this._updateButtonEnabled()
            },
            setBasicTouchHandlers: function(e, t, n, r) {
                return this.setTouchHandler(e), this.setTouchStartHandler(t), this.setTouchEnterHandler(n), this.setTouchCancelHandler(r), this
            },
            setTouchHandler: function(e) {
                var t = this;
                return this.btn.setTouchHandler(function() {
                    s.lockByGroupName(T), t.tapParticleNode.play(c).setVisible(!0).processDeferred("action_stop", {
                        tag: c
                    }).then(function() {
                        s.unlockByGroupName(T), e(t.index, t._soulStrikeInfo)
                    })
                }), this
            },
            setTouchEnterHandler: function(e) {
                var t = this;
                return this.btn.setTouchEnterHandler(function() {
                    e(t.index, t._soulStrikeInfo)
                }), this
            },
            setTouchStartHandler: function(e) {
                var t = this;
                return this.btn.setTouchStartHandler(function() {
                    e(t.index, t._soulStrikeInfo)
                }), this
            },
            setTouchCancelHandler: function(e) {
                var t = this;
                return this.btn.setTouchCancelHandler(function() {
                    e(t.index, t._soulStrikeInfo)
                }), this
            },
            setParticleVisible: function(e) {
                if (this._particleVisible === e) return;
                this._particleVisible = e, this.effectParticleNode.setVisible(this._particleVisible).process(), this.effectTapParticleNode.setVisible(this._particleVisible).process()
            },
            updateSlotView: function(e, t) {
                if (this._soulStrikeInfo === t) return;
                this._soulStrikeInfo = t;
                var n = this._soulStrikeInfo ? this._soulStrikeInfo.soulStrikeDispName : "";
                this.mainNode.setText(y, n, {
                    topNode: this.mainNode.name
                }).process();
                if (e === void 0) {
                    this._hasView = !1, this._lastAssetPath = void 0, this.backLightNode.setVisible(!1).process(), this.imageNode.setVisible(!1).process(), this._setViewEnabled(!1), this._updateButtonEnabled();
                    return
                }
                this._hasView = !0, this._setViewEnabled(this._soulStrikeInfo.enabled), this._updateButtonEnabled();
                if (this._lastAssetPath === e.assetPath) return;
                this.backLightNode.setVisible(!0).process(), this.imageNode.setVisible(!0).process(), this.mainNode.loadBundle(e.bundle).setImage(b, e.assetPath, {
                    topNode: this.mainNode.name
                }).setVisible(!0).process(), this._lastAssetPath = e.assetPath
            },
            _setViewEnabled: function(e) {
                if (e === this._viewEnabled) return;
                this._viewEnabled = e;
                var t = this._viewEnabled ? h : p;
                this.mainNode.play(t).process(), this._viewEnabled ? this.effectParticleNode.resumeParticle({
                    descendant: !0,
                    topNode: this.mainNode.name
                }).process() : this.effectParticleNode.suspendParticle({
                    effectParticleNode: !0,
                    topNode: this.mainNode.name
                }).process()
            },
            setButtonEnabled: function(e) {
                if (this._buttonEnabled === e) return;
                this._buttonEnabled = e, this._updateButtonEnabled()
            },
            _updateButtonEnabled: function() {
                var e = this._viewEnabled && this._hasView && this._buttonEnabled;
                this.btn.setEnabled(e)
            },
            resetTag: function() {
                var e = this._viewEnabled ? h : d;
                this.mainNode.play(e).process(), this._updateButtonEnabled()
            },
            dispose: function() {
                this.mainNode && this.mainNode.deleteNode(), this.mainNode = void 0, this.btn && this.btn.dispose(), this.btn = void 0
            }
        }),
        C = o.extend({
            _TAGS: {
                OUT: "command_change_out",
                IN: "command_change_in"
            },
            initialize: function(t, n) {
                var r = this,
                    i = C.EVENTS,
                    o = function(e) {
                        return u.DataConstructor.canOperateBattle()
                    },
                    c = function(e) {
                        return u.DataConstructor.canOperateBattle() && n.canStartPause()
                    };
                this.baseNode = t, this._isShown = void 0, this._isMenuShown = void 0, this._buttonEffectShown = void 0, this._soulStrikes = [], this._slots = [], this._currentTags = {}, this.ab = {}, this.ab.btnContainer = this.baseNode.createChildNode("critical_select").setVisible(!0), this.ab.open = this.baseNode.createChildNode("btn_critical_select_open").setVisible(!0), this.ab.close = this.baseNode.createChildNode("btn_critical_select_close").setVisible(!0), this.ab.openBtnEffects1 = this.baseNode.createChildNode("btn_critical_select_open_switch"), this.ab.openBtnEffects2 = this.baseNode.createChildNode("btn_critical_select_open_eff"), this.btnOpen = (new s(this.ab.open, this.baseNode.topNodeName, T)).setTouchHandler(e.bind(this._touchHandler, this)).setButtonStateTags(a, f, l).setCheckEnabledFunction(c), this.btnOpen.setLabelWithDetail(u.TextMaster.getInstance().get("B15250"), !0, "critical_name_txt_sample_01"), this.btnClose = (new s(this.ab.close, this.baseNode.topNodeName, T)).setTouchHandler(e.bind(this._touchHandler, this)).setButtonStateTags(a, f, l).setCheckEnabledFunction(o);
                var h = function(e, t) {
                        r.trigger(i.SLOT_SELECTED, e, t)
                    },
                    p = function(e, t) {
                        r.trigger(i.SLOT_TOUCH_START, e, t)
                    },
                    d = function(e, t) {
                        r.trigger(i.SLOT_TOUCH_START, e, t)
                    },
                    v = function(e, t) {
                        r.trigger(i.SLOT_TOUCH_CANCEL, e, t)
                    },
                    m = (new N(1, this.baseNode.createChildNode("btn_critical_pos_01"), this.baseNode.createChildNode("btn_critical_01"), o)).setBasicTouchHandlers(h, p, d, v),
                    g = (new N(2, this.baseNode.createChildNode("btn_critical_pos_02"), this.baseNode.createChildNode("btn_critical_02"), o)).setBasicTouchHandlers(h, p, d, v),
                    y = (new N(3, this.baseNode.createChildNode("btn_critical_pos_03"), this.baseNode.createChildNode("btn_critical_03"), o)).setBasicTouchHandlers(h, p, d, v),
                    b = (new N(4, this.baseNode.createChildNode("btn_critical_pos_04"), this.baseNode.createChildNode("btn_critical_04"), o)).setBasicTouchHandlers(h, p, d, v);
                this._slots[0] = m, this._slots[1] = g, this._slots[2] = y, this._slots[3] = b, this.hideAll()
            },
            _touchHandler: function(e) {
                var t = C.EVENTS;
                switch (e) {
                    case this.btnOpen:
                        FF.SoundMgr.playChooseEffect(), this.trigger(t.OPEN_TOUCHED);
                        break;
                    case this.btnClose:
                        FF.SoundMgr.playChooseEffect(), this.trigger(t.CLOSE_TOUCHED)
                }
            },
            setSoulStrikeInfo: function(e, t, n) {
                if (!e) return;
                this._soulStrikes[e - 1] = t, this._slots[e - 1].updateSlotView(n, t), this._updateAllParticleVisible(), this._updateButtonsEnabled()
            },
            resetSoulStrikeInfo: function(e) {
                if (!e) return;
                this._soulStrikes[e - 1] = void 0, this._slots[e - 1].updateSlotView(void 0, void 0), this._updateButtonsEnabled()
            },
            showOpenBtnEffect: function() {
                if (this._buttonEffectShown === !0) return;
                this._buttonEffectShown = !0, this.ab.openBtnEffects1.play(v).process(), this.ab.openBtnEffects2.play(g).process()
            },
            hideOpenBtnEffect: function() {
                if (this._buttonEffectShown === !1) return;
                this._buttonEffectShown = !1, this.ab.openBtnEffects1.play(m).process()
            },
            isShown: function() {
                return this._isShown === !0
            },
            isMenuShown: function() {
                return this._isMenuShown === !0
            },
            showAll: function() {
                if (this._isShown) return;
                return this._isShown = !0, this._updateAnimation(), this._updateAllParticleVisible(), this._updateButtonsEnabled(), this._resetButtons(), this
            },
            hideAll: function() {
                if (this._isShown === !1) return;
                return this._isShown = !1, this._updateAnimation(), this._updateAllParticleVisible(), this._updateButtonsEnabled(), this._resetButtons(), this
            },
            showMenu: function() {
                if (this._isMenuShown === !0) return;
                return this._isMenuShown = !0, this._updateAnimation(), this._updateAllParticleVisible(), this._updateButtonsEnabled(), this
            },
            hideMenu: function() {
                if (!this._isMenuShown) return;
                return this._isMenuShown = !1, this._updateAnimation(), this._updateAllParticleVisible(), this._updateButtonsEnabled(), this
            },
            _updateAllParticleVisible: function(t) {
                t = t === void 0 ? this._isShown === !0 && this._isMenuShown === !0 : t, e.each(this._slots, function(e) {
                    e.setParticleVisible(t)
                })
            },
            _resetButtons: function() {
                s.unlockByGroupName(T)
            },
            _updateButtonsEnabled: function() {
                var t = this;
                this.btnOpen.setEnabled(this._isShown && !this._isMenuShown), this.btnClose.setEnabled(this._isShown && this._isMenuShown), e.each(this._slots, function(e) {
                    e.setButtonEnabled(t._isShown && t._isMenuShown)
                })
            },
            _updateAnimation: function() {
                this._isShown ? this._isMenuShown ? (this._playTag(this.ab.open, this._TAGS.OUT), this._playTag(this.ab.close, this._TAGS.IN), this._playTag(this.ab.btnContainer, this._TAGS.IN)) : (this._playTag(this.ab.open, this._TAGS.IN), this._playTag(this.ab.close, this._TAGS.OUT), this._playTag(this.ab.btnContainer, this._TAGS.OUT)) : (this._playTag(this.ab.open, this._TAGS.OUT), this._playTag(this.ab.close, this._TAGS.OUT), this._playTag(this.ab.btnContainer, this._TAGS.OUT)), this.flush()
            },
            _playTag: function(e, t) {
                if (this._currentTags[e.name] === t) return;
                this._currentTags[e.name] = t, e.play(t)
            },
            setVisible: function(e, t) {
                return this.ab.open.setVisible(e), this.ab.close.setVisible(e), this.ab.btnContainer.setVisible(e), (t || t === void 0) && this.flush(), this
            },
            resetTag: function() {
                e.each(this._slots, function(e) {
                    e.resetTag()
                })
            },
            resetMenuButtons: function() {
                e.each(s.getButtonsByGroupName(T), function(e) {
                    e.reset()
                })
            },
            isUILocked: function() {
                return s.isGroupLocked(T)
            },
            flush: function() {
                var t = [];
                e.each(this.ab, function(e) {
                    t = t.concat(e.stream), e.stream = []
                }), t.length && kickmotor.animation.processAnimation(t)
            },
            dispose: function() {
                this.ab = void 0, this._soulStrikes = void 0, e.each(this._slots, function(e) {
                    e.dispose()
                }), this._slots = void 0
            }
        }, {
            EVENTS: {
                SLOT_SELECTED: "slotSelected",
                SLOT_TOUCH_START: "slotTouchStart",
                SLOT_TOUCH_CANCEL: "slotTouchCancel",
                OPEN_TOUCHED: "openTouched",
                CLOSE_TOUCHED: "closeTouched"
            }
        });
    return FF.ns.battle.view.SoulStrikeSelectorView = C, C
}), define("scenes/battle/view/SoulStrikeGauge", ["underscore", "jquery", "backbone", "sprintf", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/ab/ABNodeButton", "lib/EventBase", "lib/ClassBase"], function(e, t, n, r, i, s, o, u, a) {
    var f = a.extend({
            initialize: function(e, t, n) {
                this.gaugeNodePattern = e, this.gaugeCursorNodePattern = t, this.gaugeAddNodePattern = n
            },
            getGaugeNodeName: function(e) {
                return r(this.gaugeNodePattern, e)
            },
            getGaugeCursorNodeName: function(e) {
                return this.gaugeCursorNodePattern ? r(this.gaugeCursorNodePattern, e) : ""
            },
            getGaugeAddNodeName: function(e) {
                return r(this.gaugeAddNodePattern, e)
            },
            hasGaugeCursorNode: function() {
                return !!this.gaugeCursorNodePattern
            }
        }),
        l = new f("critical_gauge_nul_%02d", "image_gauge_cursor_%02d", "image_gauge_bar_add_%02d"),
        c = new f("critical_select_gauge_nul_%02d", "", "image_gauge_bar_add_%02d_01"),
        h = {
            normal: l,
            selector: c
        },
        p = {
            LOOP_ANIM: "bar_light_loop",
            BASE_ANIM: "bar"
        };
    return FF.ns.battle.view.SoulStrikeGauge = a.extend({
        initialize: function(e, t) {
            var n = h[t] || l;
            this._soulStrikePoint = void 0, this._consumePoint = void 0, this.gaugeCursorVisible = !1, this.ab = {}, this.ab.gaugeNode1 = e.createChildNode(n.getGaugeNodeName(1)), this.ab.gaugeNode2 = e.createChildNode(n.getGaugeNodeName(2)), this.ab.gaugeNode3 = e.createChildNode(n.getGaugeNodeName(3)), n.hasGaugeCursorNode && (this.ab.gaugeCursorNode1 = this.ab.gaugeNode1.createChildNode(n.getGaugeCursorNodeName(1)), this.ab.gaugeCursorNode2 = this.ab.gaugeNode2.createChildNode(n.getGaugeCursorNodeName(2)), this.ab.gaugeCursorNode3 = this.ab.gaugeNode3.createChildNode(n.getGaugeCursorNodeName(3)), this.ab.gaugeCursorNode1.play(p.LOOP_ANIM, {
                loop: !0
            }), this.ab.gaugeCursorNode2.play(p.LOOP_ANIM, {
                loop: !0
            }), this.ab.gaugeCursorNode3.play(p.LOOP_ANIM, {
                loop: !0
            })), this.ab.gaugeAddNode1 = this.ab.gaugeNode1.createChildNode(n.getGaugeAddNodeName(1)), this.ab.gaugeAddNode2 = this.ab.gaugeNode2.createChildNode(n.getGaugeAddNodeName(2)), this.ab.gaugeAddNode3 = this.ab.gaugeNode3.createChildNode(n.getGaugeAddNodeName(3)), this.ab.gaugeAddNode1.play(p.LOOP_ANIM, {
                loop: !0
            }).setVisible(!1), this.ab.gaugeAddNode2.play(p.LOOP_ANIM, {
                loop: !0
            }).setVisible(!1), this.ab.gaugeAddNode3.play(p.LOOP_ANIM, {
                loop: !0
            }).setVisible(!1), this.flush()
        },
        setGaugeCursorVisible: function(e) {
            if (this.gaugeCursorVisible === e) return;
            this.gaugeCursorVisible = e, this.setGaugeCursor(this._consumePoint, !0)
        },
        setSoulStrikeGauge: function(e, t) {
            if (e === this._soulStrikePoint) return;
            var n = void 0,
                r = void 0,
                i = p.BASE_ANIM;
            e < 500 ? (n = r = Math.round(e / 500 * 100), this.ab.gaugeNode1.playFrame(i, n, r), this.ab.gaugeNode2.playFrame(i, 0, 0), this.ab.gaugeNode3.playFrame(i, 0, 0), this.ab.gaugeAddNode1.setVisible(!1), this.ab.gaugeAddNode2.setVisible(!1), this.ab.gaugeAddNode3.setVisible(!1)) : e < 1e3 ? (n = r = Math.round((e - 500) / 500 * 100), this.ab.gaugeNode1.playFrame(i, 100, 100), this.ab.gaugeNode2.playFrame(i, n, r), this.ab.gaugeNode3.playFrame(i, 0, 0), e >= t && (this.ab.gaugeAddNode1.setVisible(!0), this.ab.gaugeAddNode2.setVisible(!1), this.ab.gaugeAddNode3.setVisible(!1))) : e < 1500 ? (n = r = Math.round((e - 1e3) / 500 * 100), this.ab.gaugeNode1.playFrame(i, 100, 100), this.ab.gaugeNode2.playFrame(i, 100, 100), this.ab.gaugeNode3.playFrame(i, n, r), e >= t && (this.ab.gaugeAddNode1.setVisible(!0), this.ab.gaugeAddNode2.setVisible(!0), this.ab.gaugeAddNode3.setVisible(!1))) : (this.ab.gaugeNode1.playFrame(i, 100, 100), this.ab.gaugeNode2.playFrame(i, 100, 100), this.ab.gaugeNode3.playFrame(i, 100, 100), this.ab.gaugeAddNode1.setVisible(!0), this.ab.gaugeAddNode2.setVisible(!0), this.ab.gaugeAddNode3.setVisible(!0)), this.setGaugeCursor(t), this.flush(), this._soulStrikePoint = e
        },
        setGaugeCursor: function(e, t) {
            if (!this.ab.gaugeCursorNode1) return;
            if (!t && e === this._consumePoint) return;
            switch (e) {
                case 500:
                    this.ab.gaugeCursorNode1.setVisible(this.gaugeCursorVisible), this.ab.gaugeCursorNode2.setVisible(!1), this.ab.gaugeCursorNode3.setVisible(!1);
                    break;
                case 1e3:
                    this.ab.gaugeCursorNode1.setVisible(!1), this.ab.gaugeCursorNode2.setVisible(this.gaugeCursorVisible), this.ab.gaugeCursorNode3.setVisible(!1);
                    break;
                case 1500:
                    this.ab.gaugeCursorNode1.setVisible(!1), this.ab.gaugeCursorNode2.setVisible(!1), this.ab.gaugeCursorNode3.setVisible(this.gaugeCursorVisible);
                    break;
                default:
                    this.ab.gaugeCursorNode1.setVisible(!1), this.ab.gaugeCursorNode2.setVisible(!1), this.ab.gaugeCursorNode3.setVisible(!1)
            }
            this._consumePoint = e
        },
        updateSoulStrikeGauge: function(e, t, n) {},
        reset: function() {
            this._soulStrikePoint = void 0, this._consumePoint = void 0
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {}
    }), FF.ns.battle.view.SoulStrikeGauge
}), define("scenes/battle/view/StatusAilmentsView", ["util", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n) {
    var r = FF.ns.battle,
        i = {
            INTERVAL: 1500,
            BALLOON_IDS: [r.Conf.STATUS_AILMENTS_TYPE.POISON, r.Conf.STATUS_AILMENTS_TYPE.SILENCE, r.Conf.STATUS_AILMENTS_TYPE.PARALYSIS, r.Conf.STATUS_AILMENTS_TYPE.CONFUSION, r.Conf.STATUS_AILMENTS_TYPE.STOP, r.Conf.STATUS_AILMENTS_TYPE.BLINDED, r.Conf.STATUS_AILMENTS_TYPE.SLEEP, r.Conf.STATUS_AILMENTS_TYPE.BERSERKER, r.Conf.STATUS_AILMENTS_TYPE.STAN],
            EXIST_BALLOON_ID: {}
        };
    _.each(i.BALLOON_IDS, function(e) {
        i.EXIST_BALLOON_ID[e] = !0
    }), i.AURA_TAG = {}, i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.HASTE] = "eff_light_haste", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SLOW] = "eff_light_slow", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.PROTECT] = "eff_light_protect", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SHELL] = "eff_light_shell", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.MAGIC_CHARM] = "eff_light_shell", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.REFLECTION] = "eff_light_reflect", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.REGEN] = "eff_light_regene", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.REGEN_MIDDLE] = "eff_light_regene_3", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.REGEN_STRONG] = "eff_light_regene_2", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RERAISE_40] = "eff_light_reraise", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RERAISE_60] = "eff_light_reraise", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RERAISE_80] = "eff_light_reraise", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RERAISE_100] = "eff_light_reraise", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RERAISE_DEATH] = "eff_light_reraise", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SAP] = "eff_light_slip", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.INDOMITABLENESS] = "eff_light_invincible", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.REFLECTION_FULL_TIME] = "eff_light_reflect", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RAGE] = "eff_violent", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.GRAND_CROSS] = "eff_light_grandcross", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME] = "eff_chant_short", i.OVERLAY_AURA_TAG = {}, i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.PYRAMID] = "eff_pyramid", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.PRISON_CAGE] = "eff_prison_cage", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.WATER_BALL] = "eff_water_ball", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.LOCK_ON] = "eff_lock_on", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.POSSESSION] = "eff_soulfire", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SWALLOWED] = "eff_swallow", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.MIGHTY_GUARD_1] = "eff_light_guard", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SUCTION] = "eff_vacuum", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ARM_CATCH] = "eff_restraint", i.ELEMENTAL_AURA_TAG = {}, i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_LIGHTNING_WEAK] = "eff_thunder_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_LIGHTNING_MIDDLE] = "eff_thunder_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_LIGHTNING_STRONG] = "eff_thunder_03", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_FIRE_WEAK] = "eff_fire_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_FIRE_MIDDLE] = "eff_fire_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_FIRE_STRONG] = "eff_fire_03", i.BACK_AURA_TAG = {}, i.BACK_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.MAGICAL_MINE] = "eff_light_guardian";
    var s = [r.Conf.STATUS_AILMENTS_TYPE.PROVOKE, r.Conf.STATUS_AILMENTS_TYPE.RUNIC, r.Conf.STATUS_AILMENTS_TYPE.RAID, r.Conf.STATUS_AILMENTS_TYPE.NON_DAMAGE, r.Conf.STATUS_AILMENTS_TYPE.CHARM];
    _.each(s, function(e) {
        i.AURA_TAG[e] = "eff_light_special"
    }), i.SPRITE_IDS = [r.Conf.STATUS_AILMENTS_TYPE.BLINDED, r.Conf.STATUS_AILMENTS_TYPE.SLEEP, r.Conf.STATUS_AILMENTS_TYPE.PETRIFACTION, r.Conf.STATUS_AILMENTS_TYPE.WEAKENED, r.Conf.STATUS_AILMENTS_TYPE.MINIMUM, r.Conf.STATUS_AILMENTS_TYPE.TOAD, r.Conf.STATUS_AILMENTS_TYPE.ZOMBIE], i.BALLOON_TAGS = {
        "00": ["01", void 0],
        "01": ["02", "status_01_02"],
        "02": ["01", "status_02_01"]
    }, i.MIRAGE_TAG = {}, i.MIRAGE_TAG[r.Conf.STATUS_AILMENTS_TYPE.MIRAGE_1] = "eff_cloning_01", i.MIRAGE_TAG[r.Conf.STATUS_AILMENTS_TYPE.MIRAGE_2] = "eff_cloning_02", i.MIRAGE_TAG[r.Conf.STATUS_AILMENTS_TYPE.MIRAGE_3] = "eff_cloning_03", i.TRANCE_TAG = {}, i.TRANCE_TAG[r.Conf.STATUS_AILMENTS_TYPE.TRANCE] = {
        show: "eff_burst_special",
        close: "eff_burst_special_close"
    }, FF.ns.battle.view.StatusAilmentsView = n.extend({
        initialize: function(e) {
            this._actorView = e, this._initializeParam()
        },
        _initializeParam: function() {
            this._balloon = {
                idx: 0,
                prevSa: void 0,
                elapsedTime: 0,
                no: "00"
            }, this._aura = {
                idx: 0,
                prevSa: void 0,
                elapsedTime: 0,
                tag: void 0,
                isAnimating: !1
            }, this._overlayAura = {
                idx: 0,
                prevSa: void 0,
                elapsedTime: 0,
                tag: void 0
            }, this._elementalAura = {
                idx: 0,
                prevSa: void 0,
                elapsedTime: 0,
                tag: void 0
            }, this._backAura = {
                idx: 0,
                prevSa: void 0,
                elapsedTime: 0,
                tag: void 0
            }, this._timer = {
                count: 0,
                isClosed: !0
            }, this._mirage = {
                tag: void 0
            }, this._trance = {
                prevSa: void 0,
                tag: void 0
            }, this._statusBonusPartsBuddy = {
                visibles: []
            }
        },
        update: function(e) {
            this._updateBalloon(e), this._updateTimer(e), this._updateAura(e), this._updateOverlayAura(e), this._updateElementalAura(e), this._updateBackAura(e), this._updateSprite(e), this._updateMirage(e), this._updateTrance(e), this._updateStatusBonusPartsBuddy(e)
        },
        _updateAura: function(e) {
            var t = e.statusAilments;
            this._aura.elapsedTime += FF.scene.elapsedTime;
            if (this._aura.isAnimating) return;
            var n = _.filter(t, function(e) {
                return i.AURA_TAG[e]
            });
            this._aura.elapsedTime >= i.INTERVAL && this._aura.idx++, this._aura.idx >= n.length && (this._aura.idx = 0);
            var r = n[this._aura.idx];
            if (r !== this._aura.prevSa) {
                var s = r ? i.AURA_TAG[r] : void 0;
                this.showStatusAilmentsAura(s), this._aura.elapsedTime = 0, this._aura.prevSa = r
            }
        },
        showStatusAilmentsAura: function(e) {
            var t = this,
                n = this._actorView;
            e || (e = "stop");
            if (this._aura.tag === e) return;
            this._aura.tag = e, this._aura.isAnimating = !0, n.ab.statusAilmentsAura.play("stop").processDeferred("action_stop").then(function() {
                e !== "stop" && n.ab.statusAilmentsAura.play(e), n.ab.colorChangeNode.play(e, {
                    isPlayChild: !1
                }), n.ab.colorChangeAddNode.play(e, {
                    isPlayChild: !1
                }), n.ab.leftArmColorChangeNode && (n.ab.leftArmColorChangeNode.play(e, {
                    isPlayChild: !1
                }), n.ab.leftArmColorChangeAddNode.play(e, {
                    isPlayChild: !1
                })), n.flush(), t._aura.isAnimating = !1
            })
        },
        _updateOverlayAura: function(e) {
            var t = e.statusAilments,
                n = _.filter(t, function(e) {
                    return i.OVERLAY_AURA_TAG[e]
                });
            this._overlayAura.elapsedTime += FF.scene.elapsedTime, this._overlayAura.elapsedTime >= i.INTERVAL && this._overlayAura.idx++, this._overlayAura.idx >= n.length && (this._overlayAura.idx = 0);
            var r = n[this._overlayAura.idx];
            if (r !== this._overlayAura.prevSa) {
                var s = r ? i.OVERLAY_AURA_TAG[r] : void 0;
                this.showStatusAilmentsOverlayAura(s), this._overlayAura.elapsedTime = 0, this._overlayAura.prevSa = r
            }
        },
        _updateBackAura: function(e) {
            var t = this._actorView;
            if (!t.ab.statusAilmentsBackAura) return;
            var n = e.statusAilments,
                r = this._backAura,
                s = _.filter(n, function(e) {
                    return i.BACK_AURA_TAG[e]
                });
            r.elapsedTime += FF.scene.elapsedTime, r.elapsedTime >= i.INTERVAL && r.idx++, r.idx >= s.length && (r.idx = 0);
            var o = s[r.idx];
            if (o !== r.prevSa) {
                var u = o ? i.BACK_AURA_TAG[o] : void 0;
                this.showStatusAilmentsBackAura(u), r.elapsedTime = 0, r.prevSa = o
            }
        },
        showStatusAilmentsOverlayAura: function(e) {
            var t = this,
                n = this._actorView;
            e || (e = "stop");
            if (this._overlayAura.tag === e) return;
            n.ab.statusAilmentsOverlayAura.play("stop").processDeferred("action_stop").then(function() {
                e !== "stop" && n.ab.statusAilmentsOverlayAura.play(e), n.flush(), t._overlayAura.tag = e
            })
        },
        _updateElementalAura: function(e) {
            var t = e.statusAilments,
                n = _.filter(t, function(e) {
                    return i.ELEMENTAL_AURA_TAG[e]
                });
            this._elementalAura.elapsedTime += FF.scene.elapsedTime, this._elementalAura.elapsedTime >= i.INTERVAL && this._elementalAura.idx++, this._elementalAura.idx >= n.length && (this._elementalAura.idx = 0);
            var r = n[this._elementalAura.idx];
            if (r !== this._elementalAura.prevSa) {
                var s = r ? i.ELEMENTAL_AURA_TAG[r] : void 0;
                this.showStatusAilmentsElementalAura(s), this._elementalAura.elapsedTime = 0, this._elementalAura.prevSa = r
            }
        },
        showStatusAilmentsElementalAura: function(e) {
            var t = this,
                n = this._actorView;
            e || (e = "stop");
            if (this._elementalAura.tag === e) return;
            n.ab.statusAilmentsElementalAura.play("stop").processDeferred("action_stop").then(function() {
                e !== "stop" && n.ab.statusAilmentsElementalAura.play(e), n.flush(), t._elementalAura.tag = e
            })
        },
        showStatusAilmentsBackAura: function(e) {
            var t = this._actorView,
                n = t.ab.statusAilmentsBackAura,
                r = this._backAura;
            e || (e = "stop");
            if (r.tag === e) return;
            n.play("stop").processDeferred("action_stop").then(function() {
                e !== "stop" && n.play(e), t.flush(), r.tag = e
            })
        },
        _updateBalloon: function(e) {
            var t = e.statusAilments;
            this._balloon.elapsedTime += FF.scene.elapsedTime;
            var n = _.filter(t, function(e) {
                return i.EXIST_BALLOON_ID[e]
            });
            this._balloon.elapsedTime >= i.INTERVAL && this._balloon.idx++, this._balloon.idx >= n.length && (this._balloon.idx = 0);
            var r = n[this._balloon.idx];
            if (r !== this._balloon.prevSa) {
                var s = r ? sprintf("status_icon_%s", r) : void 0;
                this.showStatusAilmentsBalloon(s), this._balloon.elapsedTime = 0, this._balloon.prevSa = r
            }
        },
        showStatusAilmentsBalloon: function(e) {
            var t = this._actorView,
                n = t.ab.statusAilmentsBalloon;
            if (!e) {
                if (this._balloon.no === "00") return;
                this._balloon.no = "00", n.play("status_close").process();
                return
            }
            var r = this._balloon.no,
                s = i.BALLOON_TAGS[r][0],
                o = i.BALLOON_TAGS[r][1],
                u = t.battleViewController.assetsManager.getAssetInfo(e);
            r === "00" ? n.loadBundle(u.bundle).setImage(sprintf("status_icon_img_%s", s), u.assetPath).play("status_open").process() : (n.loadBundle(u.bundle).setImage(sprintf("status_icon_img_%s", s), u.assetPath).process(), n.createVirtualNode("status_icon_anm_nul").play(o).process()), this._balloon.no = s
        },
        _updateTimer: function(e) {
            var t = e.statusAilments,
                n = -1;
            e.isCount && (n = _.max([e.count, 0]));
            if (this._timer.count !== n) {
                var r = n >= 0 ? sprintf("%02d", n) : void 0;
                this.showStatusAilmentsTimer(r), this._timer.count = n
            }
        },
        showStatusAilmentsTimer: function(e) {
            var t = this._actorView,
                n = t.ab.statusAilmentsDoom;
            e ? (n.setText("death_num_txt", e), this._timer.isClosed && (n.setVisible(!0).play("status_open"), this._timer.isClosed = !1)) : (n.play("status_close"), this._timer.isClosed = !0), n.process()
        },
        _updateSprite: function(e) {
            var t = e.statusAilments,
                n = _.filter(t, function(e) {
                    return _.contains(i.SPRITE_IDS, e)
                }),
                r = n[0];
            this.showStatusAilmentsSprite(r)
        },
        showStatusAilmentsSprite: function(e) {
            var t = this._actorView;
            if (!t.baseSpriteId) return;
            if (e) {
                var n = sprintf("%s_%d", t.baseSpriteId, e);
                t.setSprite(n)
            } else t.setSprite(t.baseSpriteId);
            t.flush()
        },
        _updateMirage: function(e) {
            var t = _.find(e.statusAilments, function(e) {
                    return !!i.MIRAGE_TAG[e]
                }),
                n = i.MIRAGE_TAG[t] || void 0;
            this._mirage.tag !== n && this.showStatusAilmentsMirage(n), this._mirage.tag = n
        },
        showStatusAilmentsMirage: function(e) {
            var t = this._actorView.ab.statusAilmentsMirage;
            e ? t.setVisible(!0).play(e) : t.setVisible(!1).play("stop"), t.process()
        },
        _updateTrance: function(e) {
            var t = e.statusAilments,
                n = _.find(e.statusAilments, function(e) {
                    return !!i.TRANCE_TAG[e]
                }),
                r = i.TRANCE_TAG[n] || void 0,
                s = i.TRANCE_TAG[this._trance.prevSa] || void 0;
            !r || !!s && s.show === this._trance.tag ? !r && !!s && s.show === this._trance.tag ? this.showStatusAilmentsTrance(s.close, {
                shouldCreateIfNotExists: !0
            }) : !r && !!s && s.close === this._trance.tag && (this._trance.prevSa = void 0, this._trance.tag = void 0) : (this.showStatusAilmentsTrance(r.show, {
                shouldCreateIfNotExists: !0
            }), this._trance.prevSa = n), !this._actorView.ab.statusAilmentsTranceAura || (r ? this._statusBonusPartsBuddy.visibles.push(!1) : this._statusBonusPartsBuddy.visibles.push(!0))
        },
        showStatusAilmentsTrance: function(e, t) {
            t = t || {};
            var n = this._actorView.getStatusAilmentsTranceAura(t);
            if (!n) return;
            e ? n.setVisible(!0).play(e) : n.setVisible(!1).play("stop"), n.process(), this._trance.tag = e
        },
        _updateStatusBonusPartsBuddy: function(e) {
            if (!!e.isDead) return;
            var t = this._statusBonusPartsBuddy.visibles.length;
            if (t === 0) return;
            var n = _.all(this._statusBonusPartsBuddy.visibles);
            n ? this._actorView.setStatusBonusBuddyVisible(!0) : this._actorView.setStatusBonusBuddyVisible(!1), this._statusBonusPartsBuddy.visibles.splice(0, t)
        },
        dispose: function() {
            this._actorView = void 0
        },
        reset: function() {
            this.showStatusAilmentsAura(), this.showStatusAilmentsBalloon(), this.showStatusAilmentsTimer(), this.showStatusAilmentsMirage(), this.showStatusAilmentsOverlayAura(), this.showStatusAilmentsElementalAura(), this.showStatusAilmentsBackAura(), this.showStatusAilmentsTrance(), this._initializeParam()
        },
        resetForDead: function() {
            this.reset()
        }
    })
}), define("scenes/battle/view/ContinueBonusView", ["underscore", "jquery", "util", "sprintf", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/EventBase"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle,
        a = ["01", "02", "03", "04"],
        f = ["01", "02", "03", "04", "05"],
        l = {
            CARD: "cardNode%s",
            CHARA: "charaNode%s",
            BASE_CHARA: "baseCharaNode%s"
        };
    return FF.ns.battle.view.ContinueBonusView = o.extend({
        initialize: function(t) {
            FF.logger.debug("ContinueBonusView: initialize"), this.battleViewController = t.battleViewController, this.windowNode = t.windowNode, this.menuLayerInfo = t.menuLayerInfo, this._isSelected = !1, this.ab = {};
            var n = this.windowNode.createChildNode("mogu_nul"),
                i = n.createChildNode("mogu_position_nul"),
                s = i.createChildNode("mogu_anm_nul");
            this.ab.moguPosNode = i, this.ab.moguAnmNode = s;
            var o = this.windowNode.createChildNode("chara_group_nul");
            e.each(f, function(e) {
                var t = r(l.BASE_CHARA, e),
                    n = r("chara_nul_%s", e);
                this.ab[t] = o.createChildNode(n)
            }, this), this.ab.charaGroupNode = o, this.flush()
        },
        setup: function() {
            this._setupBuddies(), this._setupCard()
        },
        showPreRaise: function() {
            this.setBaseCharaVisible(!1), this._showBuddiesDead(), this._showCardsInit(), this.ab.moguAnmNode.play("mogu_idle"), this.flush()
        },
        showPostRaise: function() {
            var e = u.DataConstructor.getBattleBgm();
            FF.SoundMgr.playMusic(e), this.showBuddiesHandsUp(), this._showPostAura()
        },
        _setupCard: function() {
            var t = this;
            e.each(a, function(e, n) {
                var s = r("cardNode%s", e);
                if (t.ab[s]) return;
                var o = (new i({
                    name: r("continue_bonus_card_%s", e),
                    layer: t.menuLayerInfo.layerName,
                    touchNodeName: "card_touch",
                    duplicateFrom: "card_nul",
                    duplicateFromOptions: {
                        visualParentLayer: t.menuLayerInfo.layerName,
                        visualParentNode: r("card_pos_nul_%s", e),
                        visualParentTopNode: t.windowNode.name
                    }
                })).setVisible(!0);
                t.ab[s] = o
            }), this.flush()
        },
        _showCardsInit: function() {
            var t = this;
            e.each(a, function(e, n) {
                var i = t.ab[r("cardNode%s", e)];
                i.play("reset"), t._isSelected = !1
            }), this.flush()
        },
        _setCardImage: function(t) {
            var n = this;
            e.each(a, function(e, i) {
                var s = n.ab[r("cardNode%s", e)],
                    o = u.Config.getInstance().get("ContinueBonus", t[i], "cardImageId"),
                    a = n.battleViewController.assetsManager.getAssetInfo(o);
                s.loadBundle(a.bundle).setImage("card_img", a.assetPath)
            }), this.flush()
        },
        registerCardTouch: function(i, s) {
            var o = this;
            e.each(a, function(f, c) {
                var h = o.ab[r(l.CARD, f)];
                h.addCallback("action_touch_ended", function() {
                    if (o._isSelected) return;
                    o._isSelected = !0;
                    var p = e.shuffle(n.cloneDeep(u.Config.getInstance().get("ContinueBonusIds"))),
                        d = p[c],
                        v = t.Deferred();
                    i(d, v), v.promise().then(function() {
                        o._setCardImage(p);
                        var e = r("mogu_pos_%d", c + 1);
                        return o.ab.moguPosNode.play(e, {
                            isPlayChild: !1
                        }).processDeferred("action_stop")
                    }).then(function() {
                        return o.ab.moguAnmNode.play("mogu_selected").processDeferred("action_stop"), h.play("card_open").processDeferred("action_stop")
                    }).then(function() {
                        var n = [];
                        return e.each(e.without(a, f), function(e) {
                            var t = o.ab[r(l.CARD, e)];
                            n.push(t.play("card_open").processDeferred("action_stop"))
                        }), t.when.apply(t, n)
                    }).then(function() {
                        e.each(a, function(e) {
                            o.ab[r(l.CARD, e)].removeAllCallback()
                        }), o.flush(), s(d)
                    })
                })
            }), this.flush()
        },
        _setupBuddies: function() {
            var t = this,
                n = this.battleViewController.assetsManager.getAssetInfo("player_common");
            e.each(u.DataConstructor.loadBuddyDrawInfo(), function(e) {
                var t = e.posId,
                    s = r(l.CHARA, t);
                if (this.ab[s]) return;
                var o = r("continue_bonus_chara_%s", t),
                    u = (new i({
                        name: o,
                        layer: n.layerName,
                        duplicateFrom: "character_nul",
                        duplicateFromOptions: {
                            visualParentLayer: this.menuLayerInfo.layerName,
                            visualParentNode: r("chara_pos_nul_%s", t),
                            visualParentTopNode: this.windowNode.name
                        }
                    })).setParam({
                        color_change_parent: o
                    }),
                    a = r("buddy-%s", e.buddyAnimationInfo.path),
                    f = this.battleViewController.assetsManager.getAssetInfo(a);
                u.loadBundle(f.bundle).setSpriteAnimeByNode("sprite_character_base", f.assetPath).setSpriteAnimeByNode("sprite_character_add", f.assetPath), this.ab[s] = u
            }, this), this.flush()
        },
        _showBuddiesDead: function() {
            this._showBuddies("dead")
        },
        showBuddiesHandsUp: function() {
            this._showBuddies("hands_up")
        },
        _showPostAura: function() {
            this.ab.charaGroupNode.play("continue_resume"), this.flush()
        },
        _showBuddies: function(t) {
            e.each(u.DataConstructor.loadBuddyDrawInfo(), function(e) {
                var n = e.posId,
                    i = r("charaNode%s", n),
                    s = r(l.BASE_CHARA, n);
                this.ab[i].play(t), this.ab[s].setVisible(!0)
            }, this), this.flush()
        },
        setBaseCharaVisible: function(t) {
            var n = this;
            e.each(f, function(e) {
                n.ab[r(l.BASE_CHARA, e)].setVisible(t)
            }), this.flush()
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        deleteNodes: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush(), this.ab = {}
        },
        dispose: function() {
            FF.logger.debug("ContinueBonusView: dispose")
        }
    }), FF.ns.battle.view.ContinueBonusView
}), define("scenes/battle/view/TargetArrowView", ["underscore", "jquery", "sprintf", "lib/ab/ABNode", "lib/EventBase"], function(e, t, n, r, i) {
    var s = FF.ns.battle;
    return FF.ns.battle.view.TargetArrowView = i.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.ab = {};
            var t = this.battleViewController.battleLayer;
            this.ab.scaleNode = t.createNode("target_arrow_scale_nul"), this.ab.arrowNode = this.ab.scaleNode.createChildNode("target_arrow_nul"), this._isOpening = !1, this._selectorUid = void 0, this._targetUid = void 0
        },
        open: function(e, n) {
            var r = this,
                i = e.getUid(),
                s = n.getUid();
            if (i === s) {
                this.close();
                return
            }
            if (i === this._targetUid) return;
            var o = !this.isOpening();
            t.when(e.getTargetPositionDeferred(), n.getTargetPositionDeferred()).done(function(e, t) {
                var n = [t[0], t[1] + 10];
                (!this._selectorUid || this._selectorUid !== s) && r.ab.scaleNode.setPosition(n).setVisible(!0);
                var i = r._calculateDegree(n, e);
                FF.logger.debug("targetArrow info: ", "correctSelectorPos", n, "targetPos", e, "degree", i), r.ab.arrowNode.setRot(i), o && r.ab.arrowNode.play("arrow_open"), r.flush()
            }).fail(function(e) {
                throw new Error("fail to open target arrow. " + JSON.stringify(e))
            }), this._isOpening = !0, this._targetUid = i, this._selectorUid = s
        },
        _calculateDegree: function(e, t) {
            var n = t[0] - e[0],
                r = t[1] - e[1],
                i = Math.round(Math.atan2(r, n) / (Math.PI / 180));
            return i -= 180, i
        },
        close: function() {
            if (!this.isOpening()) return;
            this._playCloseDeferred(), this._isOpening = !1, this._selectorUid = void 0, this._targetUid = void 0
        },
        closeDeferred: function() {
            var e = this;
            return this.isOpening() ? this._playCloseDeferred().then(function() {
                e._isOpening = !1, e._selectorUid = void 0, e._targetUid = void 0
            }) : t.Deferred().resolve().promise()
        },
        _playCloseDeferred: function() {
            var e = this;
            return this.ab.arrowNode.play("arrow_close").processDeferred("action_stop").then(function() {
                e.ab.scaleNode.setVisible(!1), e.flush()
            })
        },
        isOpening: function() {
            return this._isOpening
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {}
    }), FF.ns.battle.view.TargetArrowView
}), define("scenes/battle/view/TutorialBattleView", ["underscore", "jquery", "backbone", "sprintf", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i, s) {
    var o = FF.ns.battle;
    FF.ns.battle.view.TutorialBattleView = s.extend({
        initialize: function(e) {
            var t = this;
            this.battleViewController = e.battleViewController, this.ab = {}
        },
        setup: function(e) {
            var t = {
                    battle1: {
                        battleId: "tutorial_battle_1",
                        msgBattleId: "tutorial_msg_battle_1"
                    }
                },
                n = t[e],
                r = this.battleViewController.battleLayer,
                s = this.battleViewController.assetsManager.getAssetInfo(n.battleId);
            this.ab.indicatorNode = (new i({
                name: "tutorial_nul",
                layer: s.layerName,
                visualParentTo: "tutorial_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: r.layerName
                }
            })).play("reset"), s = this.battleViewController.assetsManager.getAssetInfo(n.msgBattleId), this.ab.tutorNode = (new i({
                name: "tutorial_msg_nul",
                layer: s.layerName,
                visualParentTo: "tutorial_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: r.layerName
                }
            })).play("reset"), this.flush()
        },
        playDeferred: function(e, n, r, i) {
            var s = void 0,
                o = void 0;
            return e && (s = {
                action: e,
                messageId: n
            }), r && (o = {
                action: r,
                frameNo: i
            }), t.when(this.playTutorDeferred(s), this.playIndicatorDeferred(o))
        },
        playTutorDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            if (!e) return r.resolve().promise();
            var i = void 0;
            e.messageId && (i = o.TextMaster.getInstance().get(e.messageId));
            switch (e.action) {
                case "IN":
                    i && this.ab.tutorNode.setText("main_txt", i), this.ab.tutorNode.play("in").processDeferred("action_stop").then(function() {
                        n.ab.tutorNode.play("loop"), n.flush(), r.resolve()
                    });
                    break;
                case "SAY":
                    i && this.ab.tutorNode.setText("main_txt", i), this.ab.tutorNode.play("tap").processDeferred("action_stop").then(function() {
                        n.ab.tutorNode.play("loop"), n.flush(), r.resolve()
                    }), this.flush();
                    break;
                case "OUT":
                    this.ab.tutorNode.play("out").processDeferred("action_stop").then(function() {
                        r.resolve()
                    });
                    break;
                case "RESET":
                    this.ab.tutorNode.play("reset").processDeferred("action_stop").then(function() {
                        r.resolve()
                    });
                    break;
                default:
                    throw new Error("invalid acion. " + e.action)
            }
            return r.promise()
        },
        playIndicatorDeferred: function(e) {
            var n = t.Deferred();
            if (!e) return n.resolve().promise();
            switch (e.action) {
                case "PLAY":
                    this._playByFrameNoDeferred(e.frameNo).then(function() {
                        n.resolve()
                    });
                    break;
                case "RESET":
                    this.ab.indicatorNode.play("reset").processDeferred("action_stop").then(function() {
                        n.resolve()
                    });
                    break;
                default:
                    throw new Error("invalid acion. " + e.action)
            }
            return n.promise()
        },
        _playByFrameNoDeferred: function(e) {
            var n = this,
                i = t.Deferred(),
                s = r("play_%s", e),
                o = r("loop_%s", e);
            return this.ab.indicatorNode.play(s).processDeferred("action_stop").then(function() {
                n.ab.indicatorNode.play(o), n.flush(), i.resolve()
            }), this.flush(), i.promise()
        },
        setVisible: function(e) {
            this.ab.tutorNode.setVisible(e), this.ab.indicatorNode.setVisible(e), this.flush()
        },
        showSupporterSoulStrikePanel: function() {
            var e = o.DataConstructor.getSupporterSoulStrikeInfo(),
                t = this.battleViewController.supporterViewController;
            t.supporterButtonInDeferred(e)
        },
        hideSupporterSoulStrikePanel: function() {
            var e = this.battleViewController.supporterViewController;
            e.supporterButtonOutDeferred()
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            FF.logger.debug("TutorialView: dispose"), e.each(this.ab, function(e) {
                e.deleteNode().process()
            })
        }
    })
}), define("scenes/battle/view/animation/AnimationBase", ["underscore", "lib/EventBase", "util"], function(e, t, n) {
    return FF.ns.battle.view.animation.AnimationBase = t.extend({
        initialize: function(e, n) {
            t.prototype.initialize.apply(this, arguments), this.viewController = n, this.data = e, this.animatingActorInfoArray = []
        },
        play: function() {
            this.viewController.isAnimating, this.viewController.isAnimating = !0;
            var t = this.data.executerInfo;
            t && this.animatingActorInfoArray.push(t);
            var n = this.data.receiverInfo;
            if (e.isArray(n)) {
                var r = e.flatten(n);
                this.animatingActorInfoArray = this.animatingActorInfoArray.concat(r)
            }
            return e.each(this.animatingActorInfoArray, function(e) {
                this.viewController.getActorViewByActorInfo(e).registerIsInAnimation()
            }, this), this
        },
        playEnd: function(t) {
            return this.trigger("end", t), this.viewController.isAnimating = !1, e.each(this.animatingActorInfoArray, function(e) {
                this.viewController.getActorViewByActorInfo(e).unregisterIsInAnimation()
            }, this), this
        },
        addCallbackOnce: function(e, t) {
            return this.once(e, t), this
        },
        generateNodeName: function() {
            var e = 1;
            return function(t) {
                return t + "_" + e++ +"_" + n.getTime()
            }
        }()
    }), FF.ns.battle.view.animation.AnimationBase
}), define("scenes/battle/view/animation/AbilityBarrageAnimation", ["underscore", "lib/ab/ABNode", "util", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle,
        s = 3e3,
        o = 2;
    FF.ns.battle.view.animation.AbilityBarrageAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.options = n.option({
                skipDamageMotion: !1,
                skipDamageMotionCountMap: {}
            }, this.data), this.barrageCount = 0, this.nodeStopDeferreds = [], this.launchNodes = [], this.shotNodes = [], this.hitNodes = [], this.hasCharaInOutTag = this.data.abilityInfo.charaOutTag ? !0 : !1
        },
        play: function() {
            r.prototype.play.call(this);
            var t = this,
                n = this.data,
                i = $.Deferred(),
                s = i.promise();
            return s = s.then(function() {
                return t.helper.showSupporterEffectDeferred(n.executerInfo)
            }).then(function() {
                return t.helper.playWalkDeferred(n.executerInfo)
            }), e.each(n.receiverInfo, function(e) {
                s = s.then(function() {
                    return t.playBarrageDeferred(n.executerInfo, e, n.abilityInfo)
                })
            }), s = s.then(function() {
                return t.helper.playCharaInDeferred(n.executerInfo, n.abilityInfo)
            }).then(function() {
                return t.trigger("postHit", n.executerInfo), t.helper.playWalkBackDeferred(n.executerInfo)
            }).then(function() {
                return $.when.apply(null, t.nodeStopDeferreds)
            }).then(function() {
                return t.helper.hideSupporterEffectDeferred(n.executerInfo)
            }).then(function() {
                t.cleanUp(), t.playEnd(n.executerInfo)
            }), i.resolve(), s
        },
        playLaunchNextDeferred: function(e, t, n) {
            var r = $.Deferred(),
                s = !1;
            switch (n.launchType) {
                case i.Conf.ABILITY_LAUNCH_TYPE.NORMAL:
                    break;
                case i.Conf.ABILITY_LAUNCH_TYPE.ONCE:
                    this.barrageCount > 1 && (s = !0);
                    break;
                case i.Conf.ABILITY_LAUNCH_TYPE.BUDDY_ONLY:
                    e.isEnemy && (s = !0);
                    break;
                case i.Conf.ABILITY_LAUNCH_TYPE.NONE:
                    s = !0;
                    break;
                default:
                    throw new Error("invalid launch type: " + n.launchType)
            }
            if (s) r.resolve();
            else {
                if (e.supporterInfo) {
                    var o = this.helper.createSocialLaunchNode(e);
                    this.launchNodes.push(o), o.play("play").process()
                }
                var u = this.helper.createLaunchNode(e, t, n);
                u.addCallbackOnce("action_next", function() {
                    r.resolve()
                }), this.launchNodes.push(u), this.nodeStopDeferreds.push(u.play("play").processDeferred("action_stop"));
                if (n.launchBack) {
                    var a = this.helper.createLaunchBackNode(e, t, n);
                    this.launchNodes.push(a), this.nodeStopDeferreds.push(a.play("play").processDeferred("action_stop"))
                }
            }
            return r.promise()
        },
        _playBarrageAttackMotionDeferred: function(e, t) {
            return this.hasCharaInOutTag && this.barrageCount > 1 ? $.Deferred().resolve().promise() : this.helper.playAttackMotionDeferred(e, t)
        },
        _playBarrageCharaOutDeferred: function(e, t) {
            return this.hasCharaInOutTag && this.barrageCount > 1 ? $.Deferred().resolve().promise() : this.helper.playCharaOutDeferred(e, t)
        },
        playBarrageDeferred: function(e, t, n) {
            var r = this,
                s = $.Deferred();
            return r.barrageCount++, $.when(this.playLaunchNextDeferred(e, t, n), this._playBarrageAttackMotionDeferred(e, n)).then(function() {
                return r.helper.playReflectHitDeferred(t)
            }).then(function() {
                return $.when(r._playBarrageShotNextDeferred(e, t, n), r._playBarrageCharaOutDeferred(e, n))
            }).then(function() {
                return r.helper.playHitNextDeferred(e, t, n, {
                    hitCount: r.barrageCount,
                    playDamageOptions: {
                        speed: o
                    },
                    skipDamageMotion: r._skipDamageMotion()
                })
            }).then(function(e, u, a) {
                r.hitNodes = r.hitNodes.concat(e), r.nodeStopDeferreds = r.nodeStopDeferreds.concat(u);
                if (a) return s.resolve();
                if (r._skipDamageMotion()) {
                    r.helper.playSkipDeferred(t).then(s.resolve);
                    return
                }
                var f = r.helper.playDamageDeferred(t, n, {
                    speed: o
                });
                n.hitType === i.Conf.ABILITY_HIT_TYPE.MULTI_HIT_FAST ? s.resolve() : f.then(s.resolve)
            }), s.promise()
        },
        _skipDamageMotion: function() {
            return !!this.options.skipDamageMotion || !!this.options.skipDamageMotionCountMap[this.barrageCount]
        },
        _playBarrageShotNextDeferred: function(e, t, n) {
            switch (n.shotType) {
                case i.Conf.ABILITY_SHOT_TYPE.NORMAL_ONCE:
                case i.Conf.ABILITY_SHOT_TYPE.ATTRACT_ONCE:
                case i.Conf.ABILITY_SHOT_TYPE.BACKWARD_ONCE:
                case i.Conf.ABILITY_SHOT_TYPE.FORWARD_ONCE:
                    if (this.barrageCount > 1) return $.Deferred().resolve().promise()
            }
            var r = this,
                s = r.helper.playShotNextDeferred(e, t, n);
            return s.then(function(e, t) {
                r.shotNodes = r.shotNodes.concat(e), r.nodeStopDeferreds = r.nodeStopDeferreds.concat(t)
            }), s
        },
        cleanUp: function() {
            var t = this;
            i.util.DelayCallback.register(s, function() {
                e.each(t.launchNodes, function(e) {
                    e.deleteNode().process()
                }), e.each(t.shotNodes, function(e) {
                    e.deleteNode().process()
                }), e.each(t.hitNodes, function(e) {
                    e.deleteNode().process()
                }), t.helper.destroyLayers(), t.helper.destroyHitNodes()
            })
        }
    })
}), define("scenes/battle/view/animation/AbilitySingleAnimation", ["underscore", "lib/ab/ABNode", "util", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle,
        s = 3e3;
    FF.ns.battle.view.animation.AbilitySingleAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.options = n.option({
                skipDamageMotion: !1
            }, this.data), this.nodeStopDeferreds = [], this.launchNodes = [], this.shotNodes = [], this.hitNodes = [], this.displayedDamage = !1
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data;
            return this.helper.showSupporterEffectDeferred(t.executerInfo).then(function() {
                return e.helper.playWalkDeferred(t.executerInfo)
            }).then(function() {
                return $.when(e.helper.playAttackMotionDeferred(t.executerInfo, t.abilityInfo), e.playLaunchNextDeferred(t.executerInfo, t.receiverInfo, t.abilityInfo))
            }).then(function() {
                return e.helper.playReflectHitDeferred(t.receiverInfo)
            }).then(function() {
                var n = e.helper.playShotNextDeferred(t.executerInfo, t.receiverInfo, t.abilityInfo);
                return n.then(function(t, n) {
                    e.shotNodes = e.shotNodes.concat(t), e.nodeStopDeferreds = e.nodeStopDeferreds.concat(n)
                }), $.when(e.helper.playCharaOutDeferred(t.executerInfo, t.abilityInfo), n)
            }).then(function() {
                return e.helper.playHitNextDeferred(t.executerInfo, t.receiverInfo, t.abilityInfo, {
                    skipDamageMotion: e.options.skipDamageMotion
                })
            }).then(function(n, r, i) {
                return e.hitNodes = e.hitNodes.concat(n), e.nodeStopDeferreds = e.nodeStopDeferreds.concat(r), e.displayedDamage = i, e.helper.playCharaInDeferred(t.executerInfo, t.abilityInfo)
            }).then(function() {
                return e.playReturnDeferred(t.receiverInfo, t.abilityInfo)
            }).then(function() {
                e.trigger("postHit", t.executerInfo), t.receiverInfo.length <= 0 && (i.Message.showTextMaster("B10060"), i.BattleViewController.getInstance().resetBgColor());
                var n = [];
                return e.displayedDamage || (e.options.skipDamageMotion ? n.push(e.helper.playSkipDeferred(t.receiverInfo)) : n.push(e.helper.playDamageDeferred(t.receiverInfo, t.abilityInfo))), n.push(e.helper.playWalkBackDeferred(t.executerInfo)), $.when.apply(null, n)
            }).then(function() {
                return $.when.apply(null, e.nodeStopDeferreds)
            }).then(function() {
                return e.helper.hideSupporterEffectDeferred(t.executerInfo)
            }).then(function() {
                e.cleanUp(), e.playEnd(t.executerInfo)
            })
        },
        playLaunchNextDeferred: function(e, t, n) {
            var r = $.Deferred(),
                s = !1;
            switch (n.launchType) {
                case i.Conf.ABILITY_LAUNCH_TYPE.NORMAL:
                case i.Conf.ABILITY_LAUNCH_TYPE.ONCE:
                    break;
                case i.Conf.ABILITY_LAUNCH_TYPE.BUDDY_ONLY:
                    e.isEnemy && (s = !0);
                    break;
                case i.Conf.ABILITY_LAUNCH_TYPE.NONE:
                    s = !0;
                    break;
                default:
                    throw new Error("invalid launch type: " + n.launchType)
            }
            if (s) r.resolve();
            else {
                if (e.supporterInfo) {
                    var o = this.helper.createSocialLaunchNode(e);
                    this.launchNodes.push(o), o.play("play").process()
                }
                var u = this.helper.createLaunchNode(e, t, n);
                u.addCallbackOnce("action_next", function() {
                    r.resolve()
                }), this.launchNodes.push(u), this.nodeStopDeferreds.push(u.play("play").processDeferred("action_stop"));
                if (n.launchBack) {
                    var a = this.helper.createLaunchBackNode(e, t, n);
                    this.launchNodes.push(a), this.nodeStopDeferreds.push(a.play("play").processDeferred("action_stop"))
                }
            }
            return r.promise()
        },
        playReturnDeferred: function(e, t) {
            var n = this,
                r = $.Deferred();
            return t.returnType === i.Conf.ABILITY_RETURN_TYPE.NONE ? r.resolve().promise() : this.playReturnShotNextDeferred(e, t).then(function() {
                return n.playReturnHitNextDeferred(e, t)
            })
        },
        playReturnShotNextDeferred: function(t, n) {
            var r = $.Deferred(),
                s = !1,
                o = !1,
                u = !1;
            switch (n.returnType) {
                case i.Conf.ABILITY_RETURN_TYPE.NORMAL:
                    o = !0;
                    break;
                case i.Conf.ABILITY_RETURN_TYPE.ATTRACT:
                    o = !0, u = !0;
                    break;
                case i.Conf.ABILITY_RETURN_TYPE.BACKWARD:
                case i.Conf.ABILITY_RETURN_TYPE.FORWARD:
                    break;
                case i.Conf.ABILITY_RETURN_TYPE.NONE:
                    s = !0;
                    break;
                default:
                    throw new Error("invalid return type: " + n.returnType)
            }
            if (s) return r.resolve().promise();
            if (o) {
                var a = [],
                    f = this._filterToReturnable(t);
                e.each(f, function(e) {
                    var t = $.Deferred(),
                        r = this.helper.createReturnShotNode(e, n);
                    a.push(t.promise()), r.addCallbackOnce("action_next", function() {
                        t.resolve()
                    });
                    if (u) {
                        var i = this.viewController.getActorViewByActorInfo(e.absorber);
                        i.setAbilityShotAttractor(r)
                    }
                    this.shotNodes.push(r), this.nodeStopDeferreds.push(r.play("play").processDeferred("action_stop"))
                }, this), $.when.apply(null, a).then(function() {
                    r.resolve()
                })
            } else {
                var l = this.helper.createReturnShotNode(t[0], n);
                l.addCallbackOnce("action_next", function() {
                    r.resolve()
                }), this.shotNodes.push(l), this.nodeStopDeferreds.push(l.play("play").processDeferred("action_stop"))
            }
            return r.promise()
        },
        playReturnHitNextDeferred: function(t, n) {
            var r = [],
                i = this._filterToReturnable(t);
            return e.each(i, function(e) {
                var t = $.Deferred(),
                    i = this.helper.createReturnHitNode(e.absorber, n);
                i.addCallbackOnce("action_next", function() {
                    t.resolve()
                }), r.push(t.promise()), this.hitNodes.push(i), this.nodeStopDeferreds.push(i.play("play").processDeferred("action_stop"))
            }, this), $.when.apply(null, r)
        },
        _filterToReturnable: function(t) {
            return e.filter(t, function(t) {
                return e.isUndefined(t.absorber) ? !1 : t.canHit ? !0 : !1
            })
        },
        cleanUp: function() {
            var t = this;
            i.util.DelayCallback.register(s, function() {
                e.each(t.launchNodes, function(e) {
                    e.deleteNode().process()
                }), e.each(t.shotNodes, function(e) {
                    e.deleteNode().process()
                }), e.each(t.hitNodes, function(e) {
                    e.deleteNode().process()
                }), t.helper.destroyLayers(), t.helper.destroyHitNodes()
            })
        }
    })
}), define("scenes/battle/view/animation/AbilitySingleAndDeformAnimation", ["./AnimationBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.view.animation.AbilitySingleAndDeformAnimation = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var n = this.data,
                r = void 0;
            n.options && (r = n.options.skipDamageMotion ? n.options.skipDamageMotion : void 0), this._attackAnimation = new t.view.animation.AbilitySingleAnimation({
                abilityInfo: n.abilityInfo,
                executerInfo: n.executerInfo,
                receiverInfo: n.receiverInfo,
                skipDamageMotion: r,
                skipAttackMotion: !0
            }, this.viewController), this._deformAnimation = new t.view.animation.DeformAnimation({
                deformInfo: n.deformInfo
            }, this.viewController)
        },
        play: function() {
            e.prototype.play.call(this);
            var t = this,
                n = this.data.options || {},
                r = $.Deferred();
            this._attackAnimation.addCallbackOnce("end", function() {
                r.resolve()
            });
            var i = $.Deferred(),
                s = n.usesMainNode ? void 0 : this.viewController.getActorViewByActorInfo(this.data.executerInfo);
            this._deformAnimation.addAttackCallbackOnce(function() {
                t._attackAnimation.play()
            }, s), this._deformAnimation.addCallbackOnce("end", function() {
                i.resolve()
            }), this._deformAnimation.play(), $.when(r.promise(), i.promise()).then(function() {
                t.playEnd()
            })
        }
    })
}), define("scenes/battle/view/animation/AbilityBarrageAndDeformAnimation", ["./AnimationBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.view.animation.AbilityBarrageAndDeformAnimation = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var n = this.data,
                r = void 0;
            n.options && (r = n.options.skipDamageMotion ? n.options.skipDamageMotion : void 0), this._attackAnimation = new t.view.animation.AbilityBarrageAnimation({
                abilityInfo: n.abilityInfo,
                executerInfo: n.executerInfo,
                receiverInfo: n.receiverInfo,
                skipDamageMotion: r,
                skipAttackMotion: !0
            }, this.viewController), this._deformAnimation = new t.view.animation.DeformAnimation({
                deformInfo: n.deformInfo
            }, this.viewController)
        },
        play: function() {
            e.prototype.play.call(this);
            var t = this,
                n = this.data.options || {},
                r = $.Deferred();
            this._attackAnimation.addCallbackOnce("end", function() {
                r.resolve()
            });
            var i = $.Deferred(),
                s = n.usesMainNode ? void 0 : this.viewController.getActorViewByActorInfo(this.data.executerInfo);
            this._deformAnimation.addAttackCallbackOnce(function() {
                t._attackAnimation.play()
            }, s), this._deformAnimation.addCallbackOnce("end", function() {
                i.resolve()
            }), this._deformAnimation.play(), $.when(r.promise(), i.promise()).then(function() {
                t.playEnd()
            })
        }
    })
}), define("scenes/battle/view/animation/AnimationFactory", ["underscore"], function(e) {
    var t = FF.ns.battle,
        n = {};
    return n[t.Conf.ANIMATION_TYPE.NORMAL] = function(n, r) {
        return new t.view.animation.AbilitySingleAnimation(e.extend(t.DataConstructor.getActionResultInfo(n.actionResult), n.options), r)
    }, n[t.Conf.ANIMATION_TYPE.BARRAGE] = function(n, r) {
        return new t.view.animation.AbilityBarrageAnimation(e.extend(t.DataConstructor.getActionResultInfo(n.actionResult), n.options), r)
    }, n[t.Conf.ANIMATION_TYPE.DROP_ITEM] = function(e, n) {
        return new t.view.animation.DropItemAnimation({
            dropItemInfo: t.DataConstructor.getDropItemInfo(e.dropItemInfo)
        }, n)
    }, n[t.Conf.ANIMATION_TYPE.DAMAGE] = function(e, n) {
        return new t.view.animation.DamageAnimation(t.DataConstructor.getActionResultInfo(e.actionResult), n)
    }, n[t.Conf.ANIMATION_TYPE.DEAD] = function(n, r) {
        return new t.view.animation.DeadAnimation({
            actorInfo: e.map(n.actorInfo, function(e) {
                return t.DataConstructor.getActorInfo(e)
            })
        }, r)
    }, n[t.Conf.ANIMATION_TYPE.DEFORM] = function(e, n) {
        return new t.view.animation.DeformAnimation({
            deformInfo: t.DataConstructor.getDeformInfoByAnimationInfo(e)
        }, n)
    }, n[t.Conf.ANIMATION_TYPE.APPEARANCE] = function(n, r) {
        return new t.view.animation.AppearanceAnimation({
            round: n.round,
            roundNum: n.roundNum,
            materiaExpBoostBuddies: n.materiaExpBoostBuddies,
            deformInfo: e.map(n.deformInfo, function(e) {
                return t.DataConstructor.getDeformInfo(e)
            })
        }, r)
    }, n[t.Conf.ANIMATION_TYPE.TRANSITION] = function(e, n) {
        return new t.view.animation.TransitionAnimation({
            buddies: t.DataConstructor.getActorInfo(e.buddies),
            buddyTransitType: e.buddyTransitType,
            backgroundChangeType: e.backgroundChangeType
        }, n)
    }, n[t.Conf.ANIMATION_TYPE.JUMP_IN] = function(e, n) {
        return new t.view.animation.JumpInAnimation(t.DataConstructor.getActionResultInfo(e.actionResult), n)
    }, n[t.Conf.ANIMATION_TYPE.JUMP_OUT] = function(e, n) {
        return new t.view.animation.JumpOutAnimation({
            executerInfo: t.DataConstructor.getActorInfo(e.action.executer),
            abilityInfo: t.DataConstructor.getAbilityInfo(e.action)
        }, n)
    }, n[t.Conf.ANIMATION_TYPE.ENEMY_JUMP] = function(n, r) {
        return new t.view.animation.EnemyJumpAnimation(e.extend(t.DataConstructor.getActionResultInfo(n.actionResult), n.options), r)
    }, n[t.Conf.ANIMATION_TYPE.DEFORM_ATTACK] = function(n, r) {
        return new t.view.animation.AbilitySingleAndDeformAnimation(e.extend({
            deformInfo: t.DataConstructor.getDeformInfoByAnimationInfo(n),
            options: n.options
        }, t.DataConstructor.getActionResultInfo(n.actionResult)), r)
    }, n[t.Conf.ANIMATION_TYPE.DEFORM_BARRAGE] = function(n, r) {
        return new t.view.animation.AbilityBarrageAndDeformAnimation(e.extend({
            deformInfo: t.DataConstructor.getDeformInfoByAnimationInfo(n),
            options: n.options
        }, t.DataConstructor.getActionResultInfo(n.actionResult)), r)
    }, n[t.Conf.ANIMATION_TYPE.INVALIDITY] = function(e, n) {
        return new t.view.animation.InvalidityAnimation(t.DataConstructor.getActionResultInfo(e.actionResult), n)
    }, n[t.Conf.ANIMATION_TYPE.RERAISE_RISE] = function(e, n) {
        return new t.view.animation.ReraiseRiseAnimation(t.DataConstructor.getActionResultInfo(e.actionResult), n)
    }, FF.ns.battle.view.animation.AnimationFactory = {
        create: function(e, t) {
            var r = n[e.animationType];
            if (!r) throw new Error("invalid animation type: " + e.animationType);
            return r(e, t)
        },
        createForDebug: function(e, n) {
            switch (e.animationType) {
                case t.Conf.ANIMATION_TYPE.NORMAL:
                    return new t.view.animation.AbilitySingleAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.BARRAGE:
                    return new t.view.animation.AbilityBarrageAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.DROP_ITEM:
                    return new t.view.animation.DropItemAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.ATTACK:
                    return new t.view.animation.AttackAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.DAMAGE:
                    return new t.view.animation.DamageAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.DEAD:
                    return new t.view.animation.DeadAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.DEFORM:
                    return new t.view.animation.DeformAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.JUMP_IN:
                    return new t.view.animation.JumpInAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.JUMP_OUT:
                    return new t.view.animation.JumpOutAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.TRANSITION:
                    return new t.view.animation.TransitionAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.RERAISE_RISE:
                    return new t.view.animation.ReraiseRiseAnimation(e, n);
                default:
                    throw new Error("invalid animation type: " + e.animationType)
            }
        }
    }, FF.ns.battle.view.animation.AnimationFactory
}), define("scenes/battle/view/animation/AnimationHelper", ["underscore", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/ClassBase", "util"], function(e, t, n, r, i) {
    var s = FF.ns.battle;
    FF.ns.battle.view.animation.AnimationHelper = r.extend({
        initialize: function(e) {
            this.viewController = e.viewController, this.layers = {}, this.hitNodes = [], this.animation = e
        },
        playWalkDeferred: function(e) {
            if (e.isEnemy) return $.Deferred().resolve().promise();
            var t = e.posId,
                n = this.viewController.buddyViews[t];
            return n.playWalkDeferred("front")
        },
        playWalkBackDeferred: function(e) {
            var t = this,
                n = $.Deferred();
            if (e.isEnemy) return n.resolve().promise();
            var r = e.posId,
                i = this.viewController.buddyViews[r];
            return i.playWalkDeferred().then(function() {
                i.hideSpecialReady(), t.viewController.resetSpecialMessage(), n.resolve()
            }), n.promise()
        },
        playBuddiesWalk: function(t) {
            var n = e.filter(t, function(e) {
                    return !e.isDead
                }),
                r = e.filter(t, function(e) {
                    return e.isDead
                });
            e.each(r, function(e) {
                this.viewController.getActorView(e.posInfo).setVisible(!1)
            }, this), e.each(n, function(e) {
                this.viewController.getActorView(e.posInfo).playWalk()
            }, this)
        },
        playBuddiesStopWalk: function(t) {
            var n = e.filter(t, function(e) {
                    return !e.isDead
                }),
                r = e.filter(t, function(e) {
                    return e.isDead
                });
            e.each(r, function(e) {
                this.viewController.getActorView(e.posInfo).setVisible(!0)
            }, this), e.each(n, function(e) {
                this.viewController.getActorView(e.posInfo).playIdle()
            }, this)
        },
        playCharaOutDeferred: function(t, n) {
            if (!n.charaOutTag) return $.Deferred().resolve().promise();
            var r = t.posId,
                i = [];
            return e.each(this.viewController.buddyViews, function(e, t) {
                t === r ? i.push(e.playOutDeferred(n.charaOutTag)) : n.otherOutTag && (e.registerIsInAnimation(), i.push(e.playOutDeferred(n.otherOutTag)))
            }), $.when.apply($, i)
        },
        playCharaInDeferred: function(t, n) {
            if (!n.charaInTag) return $.Deferred().resolve().promise();
            var r = t.posId,
                i = [];
            return e.each(this.viewController.buddyViews, function(e, t) {
                t === r ? i.push(e.playInDeferred(n.charaInTag)) : n.otherInTag && i.push(e.playInDeferred(n.otherInTag, function() {
                    e.unregisterIsInAnimation()
                }))
            }), $.when.apply($, i)
        },
        playStopDeferred: function(e) {
            if (e.isEnemy) return $.Deferred().resolve().promise();
            var t = e.posId,
                n = this.viewController.buddyViews[t];
            return n.playDeferred("stop")
        },
        playAttackMotionDeferred: function(e, t, n) {
            var r = this.viewController.getActorViewByActorInfo(e);
            if (e.isBuddy) return r.playAttackDeferred(t, n);
            var i = this.animation.data.skipAttackMotion;
            return i ? $.Deferred().resolve().promise() : r.playDeferred("attack", n)
        },
        playShotNextDeferred: function(t, n, r) {
            var i = $.Deferred(),
                o = !1,
                u = !1,
                a = !1,
                f = [],
                l = [],
                c = [];
            switch (r.shotType) {
                case s.Conf.ABILITY_SHOT_TYPE.NORMAL:
                case s.Conf.ABILITY_SHOT_TYPE.NORMAL_ONCE:
                    u = !0;
                    break;
                case s.Conf.ABILITY_SHOT_TYPE.ATTRACT:
                case s.Conf.ABILITY_SHOT_TYPE.ATTRACT_ONCE:
                    u = !0, a = !0;
                    break;
                case s.Conf.ABILITY_SHOT_TYPE.BACKWARD:
                case s.Conf.ABILITY_SHOT_TYPE.FORWARD:
                case s.Conf.ABILITY_SHOT_TYPE.BACKWARD_ONCE:
                case s.Conf.ABILITY_SHOT_TYPE.FORWARD_ONCE:
                    break;
                case s.Conf.ABILITY_SHOT_TYPE.NONE:
                    o = !0;
                    break;
                default:
                    throw new Error("invalid shot type: " + r.shotType)
            }
            if (o) return i.resolve(l, c).promise();
            if (u) e.each(n, function(e) {
                var n = $.Deferred(),
                    i;
                e.reflector ? i = this.createShotNode(t, e.reflector, r) : i = this.createShotNode(t, e, r), f.push(n.promise()), i.addCallbackOnce("action_next", function() {
                    n.resolve()
                });
                if (a) {
                    var s = this.viewController.getActorViewByActorInfo(e);
                    s.setAbilityShotAttractor(i)
                }
                l.push(i), c.push(i.play("play").processDeferred("action_stop"))
            }, this);
            else {
                var h = $.Deferred(),
                    p = this.createShotNode(t, n, r);
                f.push(h.promise()), p.addCallbackOnce("action_next", function() {
                    h.resolve()
                }), l.push(p), c.push(p.play("play").processDeferred("action_stop"))
            }
            return $.when.apply(null, f).then(function() {
                i.resolve(l, c)
            }), i.promise()
        },
        playHitNextDeferred: function(t, n, r, i) {
            var o = this;
            i = i || {};
            var u = {},
                a = $.Deferred(),
                f = !0;
            switch (r.hitType) {
                case s.Conf.ABILITY_HIT_TYPE.NORMAL:
                    break;
                case s.Conf.ABILITY_HIT_TYPE.MULTI_HIT:
                case s.Conf.ABILITY_HIT_TYPE.MULTI_HIT_FAST:
                    u = {
                        hitCount: i.hitCount
                    }, u.hitCount && u.hitCount < r.hitArg && (f = !1);
                    break;
                default:
                    throw new Error("invalid hit type: " + r.hitType)
            }
            var l = [],
                c = [],
                h = [],
                p = !1;
            return e.each(n, function(e) {
                if (e.isNotShownHitMotion) return;
                var s = $.Deferred(),
                    a = $.Deferred(),
                    d = this.createHitNode(t, e, r, u);
                l.push(s.promise()), l.push(a.promise());
                if (r.hasHitTiming && f) {
                    if (!!i.skipDamageMotion) throw new Error('Invalid Setting: Both "hasHitTiming" and "skipDamageMotion" are true. One of these must be chosen.');
                    d.addCallbackOnce("action_damage", function() {
                        o.playDamageDeferred(n, r, i.playDamageOptions).then(function() {
                            p = !0, a.resolve()
                        })
                    })
                } else a.resolve();
                d.addCallbackOnce("action_next", function() {
                    if (r.hitNextTag && e.isBuddy && e.canHit) {
                        var t = o.viewController.getActorViewByActorInfo(e);
                        t.playOutDeferred(r.hitNextTag).then(function() {
                            s.resolve()
                        })
                    } else s.resolve()
                }), c.push(d), h.push(d.play("play").processDeferred("action_stop"))
            }, this), $.when.apply(null, l).then(function() {
                a.resolve(c, h, p)
            }), a.promise()
        },
        playHitNextDeferredByHitNode: function(t) {
            var n = this,
                r = $.Deferred(),
                i = [],
                s = [];
            return e.each(t, function(e) {
                var t = $.Deferred();
                i.push(t.promise()), e.addCallbackOnce("action_damage", function() {
                    t.resolve()
                }), e.addCallbackOnce("action_next", function() {
                    t.resolve()
                }), s.push(e.play("play").processDeferred("action_stop"))
            }, this), $.when.apply(null, i).then(function() {
                r.resolve(t, s)
            }), r.promise()
        },
        playDamageDeferred: function(t, n, r) {
            var i = [];
            return e.each(t, function(e) {
                i.push(this._playDamageMotionDeferred(e, n, r))
            }, this), $.when.apply(null, i)
        },
        playSkipDeferred: function(t) {
            var n = [];
            return e.each(t, function(e) {
                var t = this.viewController.getActorViewByActorInfo(e);
                e.isNoeffect ? n.push(t.playNoeffectDeferred()) : e.advantage ? n.push(this._playAdvantageDeferred(e, e.advantage)) : e.canHit || n.push(t.playMissDeferred())
            }, this), $.when.apply(null, n)
        },
        playReflectHitDeferred: function(t) {
            var n = [],
                r = [];
            return e.each(t, function(e) {
                e.reflector && r.push(e.reflector)
            }), e.each(r, function(e) {
                var t = this.createReflectHitNode(e);
                e.isBuddy && t.setScale([-1, 1]), n.push(t.play("play").processDeferred("action_stop"))
            }, this), $.when.apply(null, n)
        },
        _playDamageMotionDeferred: function(e, t, n) {
            return e.canHit ? this._playDamageMotionHitDeferred(e, t, n) : this._playDamageMotionMissDeferred(e, t, n)
        },
        _playDamageMotionMissDeferred: function(e, t, n) {
            var r = this.viewController.getActorViewByActorInfo(e);
            return e.isNoeffect ? r.playNoeffectDeferred() : r.playMissDeferred()
        },
        _playDamageMotionHitDeferred: function(e, t, n) {
            return e.isAbilityPanel ? this._playMpDamageMotionHitDeferred(e, t, n) : this._playHpDamageMotionHitDeferred(e, t, n)
        },
        _playMpDamageMotionHitDeferred: function(e, t, n) {
            var r = this,
                i = this.viewController.getActorViewByActorInfo(e);
            return i.registerIsInAnimation(), $.Deferred().resolve().promise().then(function() {
                return i.playMpDamageMotionDeferred(e.canHit, e.damage)
            }).then(function() {
                i.unregisterIsInAnimation()
            })
        },
        _playHpDamageMotionHitDeferred: function(t, n, r) {
            var i = this,
                s = this.viewController.getActorViewByActorInfo(t);
            s.registerIsInAnimation();
            var o = void 0;
            t.isNotShownDamageMotion ? o = $.Deferred().resolve().promise() : e.isNumber(t.fakeDamage) ? o = this._playHpDamageDeferred(s, t.fakeDamage, r) : o = s.setDamageMotionDeferred(t.canHit, t.prevHp, t.currHp, t.maxHp, t.damage, n.damageTag, n.recoveryTag, r);
            var u = this._playAbsorbMotionDeferred(t);
            return $.Deferred().resolve().promise().then(function() {
                return t.isCritical ? s.playCriticalDeferred() : $.Deferred().resolve().promise()
            }).then(function() {
                return i._playAdvantageDeferred(t, t.advantage)
            }).then(function() {
                return $.when(o, u)
            }).then(function() {
                s.unregisterIsInAnimation()
            })
        },
        _playAdvantageDeferred: function(e, t) {
            var n = this.viewController.getActorViewByActorInfo(e),
                r = void 0;
            switch (e.advantage) {
                case s.Conf.ADVANTAGE.WEAK:
                    r = n.playWeaknessDeferred();
                    break;
                case s.Conf.ADVANTAGE.HALF:
                    r = n.playDefenseDeferred();
                    break;
                case s.Conf.ADVANTAGE.ABSORPTION:
                    r = n.playAbsorbDeferred();
                    break;
                case s.Conf.ADVANTAGE.VOID:
                    r = n.playResistDeferred();
                    break;
                default:
                    r = $.Deferred().resolve().promise()
            }
            return r
        },
        _playHpDamageDeferred: function(e, t, n) {
            return t >= 0 ? e.playHpDamageDeferred(t, n) : e.playHpRecoveryDeferred(-1 * t, n)
        },
        _playAbsorbMotionDeferred: function(e) {
            if (!e.absorber) return $.Deferred().resolve().promise();
            var t = this.viewController.getActorView(e.absorber.posInfo);
            return t.setDamageMotionDeferred(e.canHit, e.absorbHp.prevHp, e.absorbHp.currHp, e.absorbHp.maxHp, e.absorbHp.damage, e.damageTag, e.recoveryTag)
        },
        showEnemyName: function(t) {
            var n = this.viewController.enemyContainers;
            e.each(n, function(e) {
                e.showEnemyName(t)
            })
        },
        showEnemyNameDeferred: function(t) {
            var n = [],
                r = this.viewController.enemyContainers;
            return e.each(r, function(e) {
                n.push(e.showEnemyNameDeferred(t))
            }), $.when.apply($, n)
        },
        setEnemyHpGaugeEnabled: function(t) {
            var n = this.viewController.enemyContainers;
            e.each(n, function(e) {
                e.setHpGaugeEnabled(t)
            })
        },
        createLaunchNode: function(e, n, r) {
            var i = this.viewController.getActorViewByActorInfo(e),
                s = i.getAbilityNodeDuplicateOptions("launch"),
                o = sprintf("ability-%s_launch", r.abilityAnimationId);
            this.createLayerFromAssetId(o);
            var u = new t({
                    name: this.animation.generateNodeName("ability_launch_nul"),
                    layer: this.layers[o].layerName,
                    duplicateFrom: "ability_launch_nul",
                    duplicateFromOptions: s
                }),
                a = r.launchSpriteNum;
            a > 0 && (e.supporterInfo ? this._setSpriteToNodeForSupporter(u, e.supporterInfo, a) : this._setSpriteToNode(u, e, n, a));
            var f = r.launchParticleJson;
            return f && (e.supporterInfo ? this._setParticleTextureToNodeForSupporter(u, e.supporterInfo, n, f) : this._setParticleTextureToNode(u, e, n, f)), this._addCustomActionCallbacks(u), u
        },
        createLaunchBackNode: function(e, n, r) {
            var i = this.viewController.getActorViewByActorInfo(e),
                s = sprintf("ability-%s_launch_back", r.abilityAnimationId);
            this.createLayerFromAssetId(s);
            var o = {
                    visualParentLayer: this.viewController.battleLayer.layerName,
                    visualParentNode: sprintf("%s_all_shot_pos_nul_3", i.nodePrefix)
                },
                u = new t({
                    name: this.animation.generateNodeName("ability_back_nul"),
                    layer: this.layers[s].layerName,
                    duplicateFrom: "ability_back_nul",
                    duplicateFromOptions: o
                });
            return this._addCustomActionCallbacks(u), u
        },
        createSocialLaunchNode: function(e) {
            var n = this.viewController.getActorViewByActorInfo(e),
                r = n.getAbilityNodeDuplicateOptions("launch"),
                i = this.viewController.assetsManager.getAssetInfo("social_attack"),
                s = new t({
                    name: this.animation.generateNodeName("social_launch_nul"),
                    layer: i.layerName,
                    duplicateFrom: "ability_launch_nul",
                    duplicateFromOptions: r
                });
            return s
        },
        createHitNode: function(e, n, r, i) {
            i = i || {};
            var s = this.viewController.getActorViewByActorInfo(n),
                o = s.getAbilityNodeDuplicateOptions("hit"),
                u = void 0,
                a = void 0;
            n.canHit ? (u = i.hitCount ? sprintf("ability-%s_hit_%d", r.abilityAnimationId, i.hitCount) : sprintf("ability-%s_hit", r.abilityAnimationId), this.createLayerFromAssetId(u), a = this.layers[u].layerName) : (u = "miss_hit", a = this.viewController.assetsManager.getAssetInfo(u).layerName, r.missHit && (u = i.hitCount ? sprintf("ability-%s_miss_hit_%d", r.abilityAnimationId, i.hitCount) : sprintf("ability-%s_miss_hit", r.abilityAnimationId), this.createLayerFromAssetId(u), a = this.layers[u].layerName));
            var f = new t({
                    name: this.animation.generateNodeName("ability_hit_nul"),
                    layer: a,
                    duplicateFrom: "ability_hit_nul",
                    duplicateFromOptions: o
                }),
                l = r.hitSpriteNum;
            l > 0 && (e.supporterInfo ? this._setSpriteToNodeForSupporter(f, e.supporterInfo, l) : this._setSpriteToNode(f, e, n, l));
            var c = r.hitParticleJson;
            return c && (e.supporterInfo ? this._setParticleTextureToNodeForSupporter(f, e.supporterInfo, n, c) : this._setParticleTextureToNode(f, e, n, c)), this._addCustomActionCallbacks(f), r.reverseHit && n.isBuddy && f.setScale([-1, 1]), f
        },
        createShotNode: function(e, n, r) {
            var i = this.viewController.getActorViewByActorInfo(e),
                s = {};
            this._isShotTypeForBackward(r.shotType) || this._isShotTypeForForward(r.shotType) ? s = {
                visualParentLayer: this.viewController.battleLayer.layerName,
                visualParentNode: this._isShotTypeForBackward(r.shotType) ? sprintf("%s_all_shot_pos_nul", i.nodePrefix) : sprintf("%s_all_shot_pos_nul_2", i.nodePrefix)
            } : s = i.getAbilityNodeDuplicateOptions("shot");
            var o = sprintf("ability-%s_shot", r.abilityAnimationId);
            this.createLayerFromAssetId(o);
            var u = new t({
                    name: this.animation.generateNodeName("ability_shot_nul"),
                    layer: this.layers[o].layerName,
                    duplicateFrom: "ability_shot_nul",
                    duplicateFromOptions: s
                }),
                a = r.shotSpriteNum;
            a > 0 && (e.supporterInfo ? this._setSpriteToNodeForSupporter(u, e.supporterInfo, a) : this._setSpriteToNode(u, e, n, a));
            var f = r.shotParticleJson;
            return f && (e.supporterInfo ? this._setParticleTextureToNodeForSupporter(u, e.supporterInfo, n, f) : this._setParticleTextureToNode(u, e, n, f)), this._addCustomActionCallbacks(u), r.reverseShot && e.isEnemy && u.setScale([-1, 1]), u
        },
        createReturnShotNode: function(e, n) {
            var r = this.viewController.getActorViewByActorInfo(e),
                i = {};
            n.returnType === s.Conf.ABILITY_RETURN_TYPE.BACKWARD || n.returnType === s.Conf.ABILITY_RETURN_TYPE.FORWARD ? i = {
                visualParentLayer: this.viewController.battleLayer.layerName,
                visualParentNode: n.returnType === s.Conf.ABILITY_RETURN_TYPE.BACKWARD ? sprintf("%s_all_shot_pos_nul_2", r.nodePrefix) : sprintf("%s_all_shot_pos_nul", r.nodePrefix)
            } : i = r.getAbilityNodeDuplicateOptions("shot");
            var o = sprintf("ability-%s_return_shot", n.abilityAnimationId);
            this.createLayerFromAssetId(o);
            var u = new t({
                name: this.animation.generateNodeName("ability_return_shot_nul"),
                layer: this.layers[o].layerName,
                duplicateFrom: "ability_shot_nul",
                duplicateFromOptions: i
            });
            return this._addCustomActionCallbacks(u), u
        },
        createReturnHitNode: function(e, n) {
            var r = this.viewController.getActorViewByActorInfo(e),
                i = r.getAbilityNodeDuplicateOptions("hit"),
                s = sprintf("ability-%s_return_hit", n.abilityAnimationId);
            this.createLayerFromAssetId(s);
            var o = new t({
                name: this.animation.generateNodeName("ability_return_hit_nul"),
                layer: this.layers[s].layerName,
                duplicateFrom: "ability_hit_nul",
                duplicateFromOptions: i
            });
            return this._addCustomActionCallbacks(o), o
        },
        createReflectHitNode: function(e) {
            return this._createHitNode({
                actorInfo: e,
                assetId: "reflect_hit",
                nodeName: "reflect_hit_nul"
            })
        },
        createReraiseRiseHitNode: function(e) {
            return this._createHitNode({
                actorInfo: e,
                assetId: "reraise_rise_hit",
                nodeName: "reraise_rise_hit_nul"
            })
        },
        _createHitNode: function(e) {
            var n = this.viewController.assetsManager.getAssetInfo(e.assetId),
                r = this.viewController.getActorViewByActorInfo(e.actorInfo),
                i = r.getAbilityNodeDuplicateOptions("hit"),
                s = new t({
                    name: this.animation.generateNodeName(e.nodeName),
                    layer: n.layerName,
                    duplicateFrom: "ability_hit_nul",
                    duplicateFromOptions: i
                });
            return this.hitNodes.push(s), s
        },
        _addCustomActionCallbacks: function(e) {
            var t = this,
                n = this.animation.data.abilityInfo.aliasName;
            e.setParam({
                layer_battle_field: this.viewController.battleLayer.layerName
            }), e.addCallback("action_shake_part", function() {
                t.viewController.startShakeBackground()
            }), e.addCallback("action_shake_part_stop", function() {
                t.viewController.stopShakeBackground()
            }), e.addCallback("action_flash", function() {
                t.viewController.playFlash()
            }), e.addCallback("action_shake_all", function() {
                t.viewController.startShakeField()
            }), e.addCallback("action_shake_all_stop", function() {
                t.viewController.stopShakeField()
            }), e.addCallbackOnce("action_special_name_in", function() {
                t.viewController.showSpecialMessage(n)
            }), e.addCallbackOnce("action_special_name_out", function() {
                t.viewController.hideSpecialMessage()
            })
        },
        showSupporterEffectDeferred: function(e) {
            return e.supporterInfo ? this.viewController.supporterViewController.showSupporterEffectDeferred(e) : $.Deferred().resolve().promise()
        },
        hideSupporterEffectDeferred: function(e) {
            return e.supporterInfo ? this.viewController.supporterViewController.hideSupporterEffectDeferred(e) : $.Deferred().resolve().promise()
        },
        createLayerFromAssetId: function(e) {
            if (!this.layers[e]) {
                var t = this.viewController.assetsManager.getAssetInfo(e);
                this.layers[e] = (new n({
                    layerName: t.layerName + "_" + i.getTime()
                })).loadBundle(t.bundle).createLayer(t.assetPath, {
                    useParsedJsonCache: !0
                }).process()
            }
        },
        _isShotTypeForBackward: function(t) {
            return e.contains([s.Conf.ABILITY_SHOT_TYPE.BACKWARD, s.Conf.ABILITY_SHOT_TYPE.BACKWARD_ONCE], t)
        },
        _isShotTypeForForward: function(t) {
            return e.contains([s.Conf.ABILITY_SHOT_TYPE.FORWARD, s.Conf.ABILITY_SHOT_TYPE.FORWARD_ONCE], t)
        },
        _setSpriteToNode: function(e, t, n, r) {
            var i = this._decideActorInfoToSetSprite(t, n);
            if (i) {
                var s = this.viewController.assetsManager.getAssetInfo("buddy-" + i.buddyAnimationInfo.path);
                e = e.loadBundle(s.bundle);
                for (var o = 1; o <= r; o++) e.setSpriteAnimeByNode(sprintf("chara_sprite_%02d", o), s.assetPath)
            }
        },
        _setParticleTextureToNode: function(t, n, r, i) {
            var s = this._decideActorInfoToSetSprite(n, r);
            if (s) {
                var o = this.viewController.assetsManager.getAssetInfo("buddy-" + s.buddyAnimationInfo.path);
                t = t.loadBundle(o.bundle), e.each(i, function(n, r) {
                    e.each(n, function(e) {
                        t.setSpriteAnimeByNode(r, o.assetPath, {
                            emitterName: e
                        })
                    })
                })
            }
        },
        _decideActorInfoToSetSprite: function(e, t) {
            var n = e.isBuddy ? e : t.isBuddy ? t : void 0;
            return n
        },
        _setSpriteToNodeForSupporter: function(e, t, n) {
            var r = t && t.buddyAnimationInfo && t.buddyAnimationInfo.path;
            if (r) {
                var i = this.viewController.assetsManager.getAssetInfo("buddy-" + r);
                e = e.loadBundle(i.bundle);
                for (var s = 1; s <= n; s++) e.setSpriteAnimeByNode(sprintf("chara_sprite_%02d", s), i.assetPath)
            }
        },
        _setParticleTextureToNodeForSupporter: function(t, n, r) {
            var i = n && n.buddyAnimationInfo && n.buddyAnimationInfo.path;
            if (i) {
                var s = this.viewController.assetsManager.getAssetInfo("buddy-" + i);
                t = t.loadBundle(s.bundle), e.each(r, function(n, r) {
                    e.each(n, function(e) {
                        t.setSpriteAnimeByNode(r, s.assetPath, {
                            emitterName: e
                        })
                    })
                })
            }
        },
        destroyLayers: function() {
            e.each(this.layers, function(e) {
                e.destroyLayer({
                    clearParsedJsonCache: !1,
                    forced: !0
                }).process()
            })
        },
        destroyHitNodes: function() {
            e.each(this.hitNodes, function(e) {
                e.deleteNode().process()
            })
        }
    })
}), define("scenes/battle/view/animation/AppearanceAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.AppearanceAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this)
        },
        play: function() {
            n.prototype.play.call(this);
            var r = this,
                i = this.data.round,
                s = this.data.roundNum,
                o = this.data.materiaExpBoostBuddies,
                u = this.data.deformInfo,
                a = new t({
                    name: "battle_start_nul",
                    layer: this.viewController.battleLayer.layerName
                }),
                f = a.setText("battle_start_num_txt_1", i).setText("battle_start_num_txt_2", "/ " + s).setVisible(!0).play("battle_start").processDeferred("action_stop");
            return f.then(function() {
                var t = [];
                return u.length === 0 ? r.helper.setEnemyHpGaugeEnabled(!0) : e.each(u, function(e) {
                    t.push(r._playDeformDeferred(e))
                }), e.each(o, function(e) {
                    t.push(r._playExpBonusDeferred(e))
                }), $.when.apply($, t).then(function() {
                    r.helper.showEnemyName(2e3), r.playEndHook(), r.playEnd()
                })
            })
        },
        _playDeformDeferred: function(e) {
            var t = this.viewController.enemyContainers[e.posId],
                n = {
                    isRandom: e.isRandom,
                    invisibleHpGaugePosArray: e.invisibleHpGaugePosArray
                };
            return t.playDeformDeferred(e.deformTag, e.posArray, e.shouldDeformAllNodes, n)
        },
        _playExpBonusDeferred: function(e) {
            return this.viewController.buddyViews[e.posId].ab.txtEffNode.play("exp_up").processDeferred("action_stop")
        },
        playEndHook: function() {}
    })
}), define("scenes/battle/view/animation/AttackAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.AttckAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this)
        },
        play: function() {
            n.prototype.play.call(this);
            var e = this,
                t = this.data;
            this.helper.playAttackMotionDeferred(t.executerInfo, t.atkMotion).then(function() {
                e.playEnd(t.executerInfo)
            })
        }
    })
}), define("scenes/battle/view/animation/InvalidityAnimation", ["underscore", "lib/ab/ABNode", "util", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle;
    FF.ns.battle.view.animation.InvalidityAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this)
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data,
                n = this.viewController.getActorViewByActorInfo(t.executerInfo);
            return this.helper.playWalkDeferred(t.executerInfo).then(function() {
                if (t.executerInfo.isEnemy) return n.playDeferred("attack")
            }).then(function() {
                return i.Message.showTextMaster("B10060"), i.util.DelayCallback.registerDeferred(1500)
            }).then(function() {
                return e.helper.playWalkBackDeferred(t.executerInfo)
            }).then(function() {
                e.helper.destroyLayers(), e.helper.destroyHitNodes(), e.playEnd(t.executerInfo)
            })
        }
    })
}), define("scenes/battle/view/animation/DamageAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.DamageAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments)
        },
        play: function() {
            n.prototype.play.call(this);
            var t = this,
                r = this.data,
                i = [];
            e.each(r.receiverInfo, function(e) {
                var n = t.viewController.getActorView(e.posInfo);
                e.damage >= 0 ? i.push($.when(n.playHpDamageDeferred(e.damage), n.setLifeGaugeMotionDeferred(e.prevHp, e.currHp, e.maxHp))) : i.push($.when(n.playHpRecoveryDeferred(-1 * e.damage), n.setLifeGaugeMotionDeferred(e.prevHp, e.currHp, e.maxHp)))
            }), $.when.apply($, i).then(function() {
                t.playEnd()
            })
        }
    })
}), define("scenes/battle/view/animation/DeadAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.DeadAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments)
        },
        play: function() {
            var t = this;
            n.prototype.play.call(this);
            var r = this.data.actorInfo,
                i = [];
            e.each(r, function(e) {
                e.nodeNamePrefix === "enemy" && i.push(t._playDeadDeferred(e))
            }), $.when.apply($, i).then(function() {
                t.playEnd()
            })
        },
        _playDeadDeferred: function(e) {
            var t = this.viewController.getActorView(e.posInfo),
                n = this._getDeadTag(e),
                i = e.deadAnimateType === r.Conf.DEAD_ANIMATE_TYPE.APPARENT_DEAD,
                s = t.ab.characterNode.play(n).processDeferred("action_stop").then(function() {
                    t.setDeadInfo({
                        isApparentDead: i
                    })
                });
            return t.setHpGaugeEnabled(!1), $.when(s, t.playDeferred(n))
        },
        _getDeadTag: function(e) {
            return e.deadAnimateType ? r.Config.getInstance().get("DeadTag", e.deadAnimateType) : e.isSpEnemy && e.isFinalEnemy ? r.Config.getInstance().get("DeadTag", r.Conf.DEAD_ANIMATE_TYPE.BOSS) : r.Config.getInstance().get("DeadTag", r.Conf.DEAD_ANIMATE_TYPE.DEAD)
        }
    })
}), define("scenes/battle/view/animation/DeformAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.DeformAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this)
        },
        play: function() {
            n.prototype.play.call(this);
            var e = this,
                t = this.data.deformInfo,
                r = this._detectEnemyContainer(),
                i = t.skipEnemyName,
                s = {
                    isRandom: t.isRandom,
                    invisibleHpGaugePosArray: t.invisibleHpGaugePosArray
                };
            r.playDeformDeferred(t.deformTag, t.posArray, t.shouldDeformAllNodes, s).then(function() {
                i || e.helper.showEnemyName(2e3), e.playEnd()
            })
        },
        addAttackCallbackOnce: function(e, t) {
            var n = this,
                r = "attack";
            this.addCallbackOnce(r, e);
            var i;
            if (t) i = t.ab.characterNode;
            else {
                var s = this._detectEnemyContainer();
                i = s.mainNode
            }
            i.addCallbackOnce("action_ability", function() {
                n.trigger(r)
            })
        },
        _detectEnemyContainer: function() {
            var e = this.data.deformInfo.posId;
            return this.viewController.enemyContainers[e]
        }
    })
}), define("scenes/battle/view/animation/DropItemAnimation", ["underscore", "lib/ab/ABNode", "lib/ab/ABLayer", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle,
        s = i.Conf,
        o = {};
    o[s.DROP_ITEM_TYPE.POTION] = "playPotionItemDeferred", o[s.DROP_ITEM_TYPE.HI_POTION] = "playHiPotionItemDeferred", o[s.DROP_ITEM_TYPE.X_POTION] = "playPotionItemDeferred", o[s.DROP_ITEM_TYPE.ETHER] = "playEtherItemDeferred", o[s.DROP_ITEM_TYPE.TURBO_ETHER] = "playEtherItemDeferred", o[s.DROP_ITEM_TYPE.GIL] = "_setGilNum", o[s.DROP_ITEM_TYPE.TREASURE] = "_setTreasureNum", o[s.DROP_ITEM_TYPE.ORB] = "_setOrbNum";
    var u = {
        POTION: 1,
        ETHER: 2,
        HI_POTION: 3
    };
    FF.ns.battle.view.animation.DropItemAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.layers = {}, this.dropItemViews = {}, this._gil = 0, this._treasure = 0, this._orb = 0
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data.dropItemInfo;
            return $.Deferred().resolve().promise().then(function() {
                return e.playDropItemInDeferred()
            }).then(function() {
                return e.playDropItemOutDeferred()
            })
        },
        playDropItemInDeferred: function() {
            var t = this.data.dropItemInfo,
                n = this,
                r = [],
                s = {};
            return e.each(t, function(e) {
                var t = e.executerInfo.posId;
                s[t] = s[t] || [], s[t].push(e.item)
            }), e.each(s, function(e, t) {
                n.dropItemViews[t] = new i.view.DropItemView({
                    posId: t,
                    battleViewController: n.viewController
                });
                var s = n.dropItemViews[t].dropItemDeferred(e);
                r.push(s)
            }), $.when.apply(null, r)
        },
        playDropItemOutDeferred: function() {
            var t = this.data.dropItemInfo,
                n = this,
                r = this.playGetItemDeferred(t),
                i = this.playEraseItemDeferred().then(function() {
                    n.playNum()
                });
            return this.playGilNum(), $.when(r, i).then(function() {
                n.playEnd(t), e.each(n.dropItemViews, function(e) {
                    e.dispose()
                }), n.dropItemViews = null
            })
        },
        playNum: function() {
            this.playOrbNum(), this.playTreasureNum()
        },
        playEraseItemDeferred: function() {
            var t = [];
            return e.each(this.dropItemViews, function(e) {
                t.push(e.workDeferred())
            }), $.when.apply(null, t)
        },
        playGetItemDeferred: function(t) {
            var n = [];
            return e.each(t, function(e) {
                var t = this._getFuncName(e.item.type),
                    r = this[t](e);
                r && n.push(r)
            }, this), $.when.apply($, n)
        },
        _setGilNum: function(e) {
            var t = e.receiverInfo[0].currNum;
            t > this._gil && (this._gil = t)
        },
        _setTreasureNum: function(e) {
            var t = e.receiverInfo[0].currNum;
            t > this._treasure && (this._treasure = t)
        },
        _setOrbNum: function(e) {
            var t = e.receiverInfo[0].currNum;
            t > this._orb && (this._orb = t)
        },
        playGilNum: function() {
            this._gil > 0 && this.viewController.setGilNum(this._gil)
        },
        playTreasureNum: function() {
            this._treasure > 0 && this.viewController.setTreasureNum(this._treasure)
        },
        playOrbNum: function() {
            this._orb > 0 && this.viewController.setOrbNum(this._orb)
        },
        playPotionItemDeferred: function(e) {
            return this._playCureItemDeferred(e, u.POTION)
        },
        playHiPotionItemDeferred: function(e) {
            return this._playCureItemDeferred(e, u.HI_POTION)
        },
        playEtherItemDeferred: function(e) {
            return this._playCureItemDeferred(e, u.ETHER)
        },
        _playCureItemDeferred: function(r, i) {
            var s = this,
                o = this.viewController.battleLayer,
                a = o.layerName,
                f = r.executerInfo.posId,
                l = this.dropItemViews[f],
                c = void 0;
            switch (i) {
                case u.POTION:
                    c = "20000";
                    break;
                case u.HI_POTION:
                    c = "20001";
                    break;
                case u.ETHER:
                    c = "20010";
                    break;
                default:
                    c = "20000"
            }
            var h = [],
                p = [],
                d = [],
                v = sprintf("ability-%s_shot", c),
                m = sprintf("ability-%s_hit", c),
                g = this.viewController.assetsManager.getAssetInfo(v),
                y = this.viewController.assetsManager.getAssetInfo(m);
            return this.layers[v] = (new n({
                layerName: g.layerName
            })).loadBundle(g.bundle).createLayer(g.assetPath, {
                useParsedJsonCache: !0
            }).process(), this.layers[m] = (new n({
                layerName: y.layerName
            })).loadBundle(y.bundle).createLayer(y.assetPath, {
                useParsedJsonCache: !0
            }).process(), e.each(r.receiverInfo, function(e) {
                var n = $.Deferred(),
                    r = e.posId,
                    o = "player",
                    u = s.viewController.getActorView(e.posInfo);
                u.registerIsInAnimation(), s.animatingActorInfoArray.push(e);
                var f = new t({
                    name: sprintf("%s_ability_shot_nul_%s", o, r),
                    layer: sprintf("layer_ability-%s_shot", c),
                    duplicateFrom: "ability_shot_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a,
                        visualParentNode: "drop_item_eff_pos_nul_02",
                        visualParentTopNode: l.dropItemNode.name
                    }
                });
                f.setAttractor("shot_particle", sprintf("%s_attractor_%s", o, r), {
                    attractorLayer: a
                });
                var v = new t({
                    name: sprintf("%s_ability_hit_nul_%s", o, r),
                    layer: sprintf("layer_ability-%s_hit", c),
                    duplicateFrom: "ability_hit_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a,
                        visualParentNode: sprintf("%s_hit_pos_nul_%s", o, r)
                    }
                });
                v.addCallbackOnce("action_stop", function() {
                    v.deleteNode().process(), f.deleteNode().process(), n.resolve()
                }), f.addCallbackOnce("action_next", function() {
                    v.play("play").process(), s._playActorEffectDeferred(e, i)
                }), v.process(), f.process(), h.push(v), p.push(f), d.push(n.promise())
            }), e.each(p, function(e) {
                e.play("play").process()
            }), $.when.apply(null, d)
        },
        _playActorEffectDeferred: function(e, t) {
            var n, r = this.viewController.getActorView(e.posInfo);
            switch (t) {
                case u.POTION:
                case u.HI_POTION:
                    n = r.setDamageMotionDeferred(!0, e.prevHp, e.currHp, e.maxHp, e.damage);
                    break;
                case u.ETHER:
                    n = r.playMpRecoveryDeferred(-1 * e.damageNum);
                    break;
                default:
                    n = $.Deferred().resolve().promise()
            }
            return n
        },
        _getFuncName: function(e) {
            var t = o[e];
            if (!this[t]) throw new Error("invalid drop item type.t=" + e);
            return t
        },
        destroyLayers: function() {
            e.each(this.layers, function(e) {
                e.destroyLayer({
                    clearParsedJsonCache: !1,
                    forced: !0
                }).process()
            })
        }
    })
}), define("scenes/battle/view/animation/JumpInAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.JumpInAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this)
        },
        play: function() {
            n.prototype.play.call(this);
            var e = this;
            this.playJumpInDeferred().then(function() {
                e.playEnd()
            })
        },
        playJumpInDeferred: function() {
            var n = this,
                r = this.data,
                i = this.data.executerInfo,
                s = this.data.receiverInfo,
                o = this.data.abilityInfo,
                u = [],
                a = [],
                f = this.viewController.getActorViewByActorInfo(i);
            return e.each(s, function(e) {
                var r = this.helper.createHitNode(i, e, o),
                    s = new t({
                        name: sprintf("hit_character_%s", e.posId),
                        layer: f.ab.characterNode.layer,
                        duplicateFrom: "character_nul",
                        duplicateFromOptions: {
                            visualParentLayer: r.layer,
                            visualParentNode: "chara_pos_nul",
                            visualParentTopNode: r.name
                        }
                    });
                r.setParam({
                    abilityEffTargetLayer: s.layer,
                    abilityEffNode: "sprite_character_base",
                    abilityEffNodeAdd: "sprite_character_add",
                    abilityEffParentNode: s.name
                }), r.addCallbackOnce("action_next", function() {
                    n.helper.playDamageDeferred([e], o)
                }), r.process();
                var l = this.viewController.assetsManager.getAssetInfo(f.baseSpriteId);
                s.loadBundle(l.bundle).setSpriteAnimeByNode("sprite_character_base", l.assetPath).setSpriteAnimeByNode("sprite_character_add", l.assetPath).setVisible(!1, {
                    topNode: s.name,
                    node: "shadow_nul"
                }).process(), u.push(r.play("play").processDeferred("action_stop")), a.push(r), a.push(s)
            }, this), $.when.apply($, u).then(function() {
                return e.each(a, function(e) {
                    e.deleteNode().process()
                }), n.helper.playCharaInDeferred(i, o), f.setVisible(!0), n.helper.playWalkBackDeferred(i)
            })
        }
    })
}), define("scenes/battle/view/animation/JumpOutAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.JumpOutAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this)
        },
        play: function() {
            n.prototype.play.call(this);
            var e = this,
                t = this.data;
            this.helper.playWalkDeferred(t.executerInfo).then(function() {
                return e.playJumpDeferred()
            }).then(function() {
                e.playEnd()
            })
        },
        playJumpDeferred: function() {
            var e = this,
                t = this.data.abilityInfo,
                n = this.data.executerInfo,
                r = this.data.receiverInfo,
                i = [],
                s = this.helper.createLaunchNode(n, r, t);
            i.push(s.play("play").processDeferred("action_stop").then(function() {
                return e.helper.playCharaOutDeferred(n, t)
            }));
            var o = this.helper.createShotNode(n, r, t);
            return i.push(o.play("play").processDeferred("action_stop")), $.when.apply($, i).then(function() {
                var t = e.viewController.getActorViewByActorInfo(n);
                t.setVisible(!1)
            }).then(function() {
                s.deleteNode().process(), o.deleteNode().process()
            })
        }
    })
}), define("scenes/battle/view/animation/TransitionAnimation", ["underscore", "util", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle;
    FF.ns.battle.view.animation.TransitionAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.data = t.option({
                buddies: void 0,
                backgroundChangeType: !1,
                buddyTransitType: void 0
            }, this.data)
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data.backgroundChangeType,
                n = t === i.Conf.BACKGROUND_CHANGE_TYPE.NONE ? this._playTransitionDeferred() : this._playBgChangeDeferred(t);
            n.then(function() {
                e.playEnd()
            })
        },
        _playBgChangeDeferred: function(e) {
            var t = this,
                n = e === i.Conf.BACKGROUND_CHANGE_TYPE.WALK,
                r = this.data.buddies;
            n && this.helper.playBuddiesWalk(r);
            var s = $.Deferred();
            return this.viewController.backgroundView.playChangeTransitionDeferred().then(function() {
                n && t.helper.playBuddiesStopWalk(r), s.resolve()
            }), s.promise()
        },
        _playTransitionDeferred: function() {
            var e = this.data.buddyTransitType;
            switch (e) {
                case i.Conf.TRANSITION_TYPE.NONE:
                    return $.Deferred().resolve().promise();
                case i.Conf.TRANSITION_TYPE.SCROLL:
                    return this._playTransitionWalkDeferred();
                default:
                    throw new Error("invalid transit type.t=" + e)
            }
        },
        _playTransitionWalkDeferred: function() {
            var e = this,
                t = this.data.buddies;
            this.helper.playBuddiesWalk(t);
            var n = $.Deferred();
            return this.viewController.backgroundView.playScrollTransitionDeferred().then(function() {
                e.helper.playBuddiesStopWalk(t), e.viewController.backgroundView.suspendTransition(), n.resolve()
            }), n.promise()
        }
    })
}), define("scenes/battle/view/animation/EnemyJumpAnimation", ["underscore", "lib/ab/ABNode", "util", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle,
        s = 3e3;
    FF.ns.battle.view.animation.EnemyJumpAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.options = n.option({
                skipDamageMotion: !1
            }, this.data), this.nodeStopDeferreds = [], this.launchNode = void 0, this.shotNodes = [], this.hitNodes = []
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data;
            return this.helper.playAttackMotionDeferred(t.executerInfo, t.abilityInfo).then(function() {
                return e.playJumpOutDeferred()
            }).then(function() {
                return e.helper.playHitNextDeferred(t.executerInfo, t.receiverInfo, t.abilityInfo)
            }).then(function(t, n) {
                return e.hitNodes = e.hitNodes.concat(t), e.nodeStopDeferreds = e.nodeStopDeferreds.concat(n), e.playJumpInDeferred()
            }).then(function() {
                return e.trigger("postHit", t.executerInfo), e.options.skipDamageMotion ? $.Deferred().resolve().promise() : e.helper.playDamageDeferred(t.receiverInfo, t.abilityInfo)
            }).then(function() {
                return $.when.apply(null, e.nodeStopDeferreds)
            }).then(function() {
                e.cleanUp(), e.playEnd(t.executerInfo)
            })
        },
        playJumpOutDeferred: function() {
            var e = this.data.abilityInfo,
                t = this.data.executerInfo,
                n = this.data.receiverInfo,
                r = [],
                i = this.viewController.getActorViewByActorInfo(t),
                s = this.helper.createLaunchNode(t, n, e);
            r.push(s.play("play").processDeferred("action_stop").then(function() {
                return i.playOutDeferred(e.charaOutTag)
            }));
            var o = this.helper.createShotNode(t, n, e);
            return r.push(o.play("play").processDeferred("action_stop")), $.when.apply($, r).then(function() {
                s.deleteNode().process(), o.deleteNode().process()
            })
        },
        playJumpInDeferred: function() {
            var e = this.data.abilityInfo,
                t = this.data.executerInfo,
                n = this.viewController.getActorViewByActorInfo(t);
            return n.playInDeferred(e.charaInTag)
        },
        cleanUp: function() {
            var t = this;
            i.util.DelayCallback.register(s, function() {
                t.launchNode && t.launchNode.deleteNode().process(), e.each(t.shotNodes, function(e) {
                    e.deleteNode().process()
                }), e.each(t.hitNodes, function(e) {
                    e.deleteNode().process()
                }), t.helper.destroyLayers(), t.helper.destroyHitNodes()
            })
        }
    })
}), define("ww/scenes/common/util/VCApi", ["jquery", "underscore", "lib/api"], function(e, t, n) {
    return t.extend({}, {
        getVCBundlesDeferred: function(e) {
            return e && e.handleRetry ? (e.callingFunction = "getVCBundlesDeferred", n.callDeferredWithRetry(this._getVCBundlesDeferred.bind(this), e)) : this._getVCBundlesDeferred()
        },
        _getVCBundlesDeferred: function(n) {
            var r = this,
                i = e.Deferred();
            return kickmotor.platform.getVCBundles(function(e) {
                if (i) {
                    if (e.success) {
                        if (FF.env.isAndroid()) {
                            var n = [];
                            t.each(e.vcBundles, function(e) {
                                e.title = e.detail, n.push(e)
                            }), e.vcBundles = n
                        }
                        i.resolve(e.vcBundles)
                    } else FF.logger.debug("Failed to get VC due to : " + e.reason), i.reject();
                    i = null
                }
            }), i.promise()
        },
        buyVCBundleDeferred: function(t) {
            var n = this,
                r = e.Deferred();
            return kickmotor.platform.buyVCBundle(t, function(e) {
                e.success ? r.resolve(e.wallet) : (FF.logger.debug("Failed to buy VC due to : " + e.reason), r.reject(e.reason))
            }), r.promise()
        }
    })
}), define("ww/scenes/battle/view/VCListView", ["underscore", "util", "sprintf", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/EventBase", "ww/scenes/common/util/VCApi", "jquery"], function(e, t, n, r, i, s, o, u) {
    var a = FF.ns.battle,
        f = ["1", "2", "3", "4", "5"],
        l = {
            BUNDLE: "bundleNode%s"
        };
    return FF.ns.battle.view.VCListView = s.extend({
        initialize: function(e) {
            FF.logger.debug("VCListView: initialize"), this.windowMainNode = e.windowMainNode, this.menuLayerInfo = e.menuLayerInfo, this.battleLayerName = e.battleLayerName, this._isSelected = !1, this.ab = {}, this.btnEnableInfo = {}, this._tappingBtnName = void 0, this._initBaseNode(), this._initThanksAnim(), this._initBundleNodes(), this.flush()
        },
        _initBaseNode: function() {
            this.ab.bundleGroupNode = this.windowMainNode.createChildNode("buy_select_nul")
        },
        _initThanksAnim: function() {
            var e = this.windowMainNode,
                t = this.menuLayerInfo,
                n = this.battleLayerName;
            this.ab.thankNode = new r({
                name: "buy_thank_nul",
                layer: t.layerName,
                visualParentTo: "zero_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: n
                }
            }), this.ab.thankNode.setVisible(!0)
        },
        _initBundleNodes: function() {
            var t = this;
            e.each(f, function(e, r) {
                var i = n("bundleNode%s", e);
                if (t.ab[i]) return;
                t.ab[i] = t._createBtnNode(n("buy_select_bt_%s_nul", e), function(e) {
                    if (!t.ab || !t.ab[i] || !t._isBtnEnable(t.ab[i]) || t.isSelected) return;
                    t.isSelected = !0, t._onClickBundleNodeDeferred(r).done(function() {
                        return t.ab.thankNode.play("buy_thank").processDeferred("action_stop")
                    }).always(function() {
                        t.isSelected = !1, e()
                    })
                })
            }), this.flush()
        },
        _onClickBundleNodeDeferred: function(e) {
            return o.buyVCBundleDeferred(this.vcBundles[e].sku)
        },
        setupDeferred: function() {
            var e = this,
                t = u.Deferred();
            return o.getVCBundlesDeferred().done(function(n) {
                e.vcBundles = n, e._setupBundles(), t.resolve()
            }).fail(function() {
                t.reject()
            }), t.promise()
        },
        _setupBundles: function() {
            var t = this;
            if (!this.vcBundles) return;
            e.each(f, function(e, r) {
                var i = n("bundleNode%s", e),
                    s = t.ab[i];
                if (r < t.vcBundles.length) {
                    var o = t.vcBundles[r],
                        u = o.title || o.sku;
                    u = u.replace("Gem ", "");
                    var a = o.value + " Gems";
                    s.setText(n("buy_select_menu_word_%s", e), u).process(), s.setText(n("buy_select_gem_num_%s", e), a).process(), s.setText(n("text_buy_select_bt_%s", e), o.displayPrice).process(), s.setVisible(!0)
                }
            }), this.flush()
        },
        setButtonVisibility: function(t) {
            var r = this;
            e.each(f, function(e) {
                r.ab[n("bundleNode%s", e)].setVisible(t)
            }), this.flush()
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        deleteNodes: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush(), this.ab = {}
        },
        dispose: function() {
            FF.logger.debug("VCListView: dispose")
        },
        _createNode: function(e) {
            var t = this.ab.bundleGroupNode.createChildNode(e);
            return t
        },
        _createBtnNode: function(e, t) {
            var n = this._createNode(e);
            return this._createBtnNodeFromNode(n, t)
        },
        _createBtnNodeFromNode: function(e, t) {
            var n = this;
            return this._setBtnEnable(e, !0), e.addCallback("action_touch_began", function() {
                if (!n._isBtnEnable(e)) return;
                if (!n._lockBtnTap(e)) return;
                n.touchBeganDeferred = e.play("tap").processDeferred("action_stop")
            }), e.addCallback("action_touch_ended", function() {
                if (!n._isLockedBtnTap(e) || !n.touchBeganDeferred) return;
                n.touchBeganDeferred.then(function() {
                    FF.SoundMgr.playChooseEffect(), n.touchBeganDeferred = void 0, t(function() {
                        e.play("reset").process(), n._unlockBtnTap()
                    })
                })
            }), e.addCallback("action_touch_exited", function() {
                if (!n._isLockedBtnTap(e) || !n.touchBeganDeferred) return;
                n.touchBeganDeferred.then(function() {
                    e.play("reset").process(), n.touchBeganDeferred = void 0, n._unlockBtnTap()
                })
            }), e
        },
        _setBtnEnable: function(e, t) {
            this.btnEnableInfo[e.name] = t
        },
        _isBtnEnable: function(e) {
            return this.btnEnableInfo[e.name] ? !0 : !1
        },
        _playBtnEnable: function(e) {
            this._isBtnEnable(e) ? e.play("reset", {
                autoRemove: !1
            }) : e.play("bt_disable", {
                autoRemove: !1
            }), this.flush()
        },
        _lockBtnTap: function(e) {
            return this._tappingBtnName ? !1 : (this._tappingBtnName = e.name, !0)
        },
        _isLockedBtnTap: function(e) {
            return !!this._tappingBtnName && this._tappingBtnName === e.name
        },
        _unlockBtnTap: function() {
            this._tappingBtnName = void 0
        }
    }), FF.ns.battle.view.VCListView
}), define("scenes/battle/view/animation/ReraiseRiseAnimation", ["underscore", "./AnimationBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.view.animation.ReraiseRiseAnimation = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.helper = new n.view.animation.AnimationHelper(this)
        },
        play: function() {
            t.prototype.play.call(this);
            var n = this,
                r = this.data,
                i = e.map(r.receiverInfo, function(e) {
                    return n.helper.createReraiseRiseHitNode(e)
                });
            return n.helper.playHitNextDeferredByHitNode(i).then(function() {
                var t = [];
                return e.each(r.receiverInfo, function(e) {
                    var r = n.viewController.getActorView(e.posInfo);
                    t.push($.when(r.playHpRecoveryDeferred(-1 * e.damage), r.setLifeGaugeMotionDeferred(e.prevHp, e.currHp, e.maxHp)))
                }), $.when.apply(null, t)
            }).then(function() {
                n.playEnd()
            })
        }
    })
}), define("scenes/battle/BattleScene", ["util", "lib/Ticker", "lib/Scene", "lib/Battle", "lib/BattleConfig", "lib/BattleStorage", "lib/JsLoader", "lib/Watchdog", "backbone", "jquery", "lib/Chara", "./AbilityFactory", "./AbilityInfoMgr", "./AbilityMgr", "./ActiveTarget", "./ActorBase", "./ActorBuddy", "./ActorSupporter", "./ActorEnemy", "./ActorMgr", "./ActorParamHolder", "./ActorTimeMgr", "./Api", "./BattleEventMgr", "./BattleEventMgr", "./BattleFsm", "./BattleInfo", "./BattleInitData", "./BattleLog", "./BattleProcessMgr", "./BattleResultFsm", "./BattleScene", "./BattleViewController", "./SupporterViewController", "./BuddyPartyMgr", "./Commander", "./Conf", "./Config", "./ContinueBonus", "./ContinueFsm", "./ContinueTxn", "./Counters", "./DataConstructor", "./DeathFsm", "./Debug", "./EnemyContainer", "./EnemyParty", "./EnemyPartyMgr", "./EventFsm", "./ExpireFsm", "./ExternalFunc", "./ExternalUserAuth", "./LotteryBox", "./MateriaFactory", "./MateriaHolder", "./Message", "./PreBattleFsm", "./RemoteLogger", "./Score", "./StatusAilments", "./StatusAilmentsConfig", "./TextMaster", "./ParameterEncoder", "./action/ActionBase", "./action/ActionHelper", "./action/BuiltinHealDeathAction", "./action/BuiltinIncreaseMpAction", "./action/BuiltinInflictSaAction", "./action/CustomParamAction", "./action/CustomParamAndSelfDestructAction", "./action/DoNothingAction", "./action/DamagedHpAttackAction", "./action/DefenseAction", "./action/DeformAction", "./action/DeformMultiAction", "./action/DoNothingAction", "./action/EnemyJumpAction", "./action/EntrustSsPointAction", "./action/FractionalAttackByHpAction", "./action/FractionalAttackByMaxHpAction", "./action/FractionalAttackByHpWithoutSaAction", "./action/FractionalAttackByHpWithoutSaAndInflictSaAction", "./action/FractionalHealByHpAction", "./action/PhysicalAttackElementAndCustomParamAction", "./action/HealDeathAction", "./action/ReraiseRiseAction", "./action/HealHpAction", "./action/HealHpAndCustomParamAction", "./action/HealHpAndInflictSaAction", "./action/HealHpAndHealSaMultiAction", "./action/HealHpAndHealSaAction", "./action/HealSaAction", "./action/HealSaLotAction", "./action/HealSaMultiAction", "./action/HealAndInflictSaAction", "./action/InflictSaAction", "./action/InflictSaAndFallbackMagicAttackAction", "./action/InflictSaAndIncreaseMpAction", "./action/InflictSaHitAction", "./action/InflictSaHitAndDeformAction", "./action/JumpAction", "./action/PhysicalAttackMultiAndSelfSaMultiAction", "./action/LotAction", "./action/MagicAttackAction", "./action/MagicAttackAndAbsorbHpAction", "./action/MagicAttackAndDefIgnoredAction", "./action/MagicAttackAndDefIgnoredAndDeformAction", "./action/MagicAttackAndDeformAction", "./action/MagicAttackAndDefBoostIgnoredAction", "./action/MagicAttackMultiAction", "./action/MagicAttackMultiWithMultiSaAction", "./action/MagicAttackAndHealHpAction", "./action/MagicAttackAndPhysicalAttackElementAction", "./action/MagicAttackMultiAndPartyCustomParamAction", "./action/MagicAttackMultiAndInflictSaMultiAction", "./action/PhysicalAttackWithMultiSaAction", "./action/ParamBoosterAction", "./action/PhysicalAttackAction", "./action/PhysicalAttackAndAbsorbHpAction", "./action/PhysicalAttackAndCustomParamAction", "./action/PhysicalAttackAndDefIgnoredAction", "./action/PhysicalAttackAndHpBarterAction", "./action/PhysicalAttackCriticalOrMissAction", "./action/PhysicalAttackElementAction", "./action/PhysicalAttackHitAction", "./action/PhysicalAttackMultiAction", "./action/PhysicalAttackMultiWithMultiParamsAction", "./action/PhysicalAttackMultiWithMultiSaAction", "./action/PhysicalAttackWithoutAimingBySaAction", "./action/PhysicalAttackAndSelfCustomParamAction", "./action/PhysicalAttackAndPartyCustomParamAction", "./action/MagicAttackAndSelfCustomParamAction", "./action/PhysicalCustomParamBidirectionallyAction", "./action/PhysicalInflictSaBidirectionallyAction", "./action/PhysicalAttackMultiAndInflictSaAndCustomParamAction", "./action/PhysicalAttackMultiAndHealSaMultiAction", "./action/PhysicalAttackElementMultiAndSelfSaAndSelfCustomParamAction", "./action/ReduceMpAction", "./action/IncreaseMpAction", "./action/SaPoisonAction", "./action/SaRegenAction", "./action/SelfDestructAction", "./action/SelfDestructAndDeformAction", "./action/FixedDamageAction", "./action/FixedDamageMultiAction", "./action/FixedDamageAndDeformAction", "./action/LvInflictSaAction", "./action/MagicAttackAndCustomParamAction", "./action/FixedHpAction", "./action/FixedHpAndDeformAction", "./action/MagicAttackAndHealDeathAction", "./action/PhysicalAttackWithHealSaAction", "./action/PhysicalAttackMultiAndDeformAction", "./action/PhysicalAttackAndDeformAction", "./action/ShowAbilityEffectAction", "./action/PhysicalDamagedHpAttackAction", "./action/PhysicalAttackAndSelfSaAction", "./action/PhysicalAttackMultiAndColleagueSaAction", "./action/PhysicalAttackMultiAndSelfSaAction", "./action/PhysicalAttackMultiAndCustomParamAction", "./action/PhysicalAttackMultiAndCustomParamAndSelfCustomParamAction", "./action/PhysicalAttackMultiAndSelfAttachElementAction", "./action/InflictSaAndCustomProbabilityDeformAction", "./action/ShowAbilityEffectDeformAction", "./action/PhysicalAttackAndHealHpAction", "./action/CustomParamMultiAndInflictSaMultiAction", "./action/WrappedAbilityActionBase", "./action/RageAction", "./action/TranceAction", "./action/PhysicalAttackElementAndInflictSaAndSelfSaAction", "./action/AttachElementAction", "./action/CustomParamMultiAction", "./action/PhysicalAttackElementMultiAndSelfCustomParamAction", "./action/PhysicalAttackElementMultiAndPartyCustomParamAction", "./action/PhysicalAttackWithMultiHealSaAction", "./action/ChangeCastTimeAction", "./action/HealHpAndHealDeathAction", "./action/MagicAttackMultiAndSelfSaAction", "./action/MagicAttackAndInflictSaMultiAction", "./action/MagicAttackAndAbsorbHpAndDeformAction", "./action/HealSaMultiAndDeformAction", "./action/HealHpAndIncreaseMpAction", "./action/PhysicalAttackDependedOnSaAction", "./ai/AiUtil", "./action/PhysicalAttackElementMultiAndSelfCustomParamWithEffectAction", "./ai/State", "./ai/StateMap", "./ai/StateMapBuilder", "./ai/TransitCondition", "./ai/Transition", "./ai/ConditionFlag", "./ai/ResultObjectTmp", "./ai/resultObjectTmp/DamageResultObjectTmp", "./ai/state/DoNothingState", "./ai/state/InitState", "./ai/state/InterruptAbility", "./ai/state/InterruptMultipleAbility", "./ai/state/SimpleState", "./ai/state/SimpleWithoutState", "./ai/transition/NextStateIdTransition", "./ai/transitCondition/AbilityCountTransitCondition", "./ai/transitCondition/EachDamageTransitCondition", "./ai/transitCondition/DamageTransitCondition", "./ai/transitCondition/TimeTransitCondition", "./ai/transitCondition/TurnTransitCondition", "./fsm/State", "./fsm/StateMap", "./fsm/TransitCondition", "./fsm/Transition", "./materia/MateriaHelper", "./materia/FirstAttackMateria", "./materia/PanelNumMateria", "./materia/PanelNumMateriaByCategory", "./materia/PanelNumMateriaByMultiCategory", "./materia/PanelSwapMateria", "./materia/PanelRandomSwapMateria", "./materia/ParamMateria", "./materia/ParamAndInflictSaMateria", "./materia/InflictSaMateria", "./materia/InflictSaWhenHpFallsMateria", "./materia/DamageBoostWhenWeaknessMateria", "./materia/DamageBoostElementMateria", "./materia/DamageBoostByWeaponMateria", "./materia/BlackMagicDamageBoostByWeaponMateria", "./materia/DamageBoostAbilityMateria", "./materia/DamageBoostByWeaponWithAllowableTypesMateria", "./materia/HealBoostMateria", "./materia/CounterMateria", "./materia/ParamBoostInBuddyDeadMateria", "./materia/ParamBoostInHpDecreaseMateria", "./materia/ParamBoostByArmorMateria", "./materia/ParamBoostByWeaponMateria", "./materia/SoulStrikePointFactorBoostMateria", "./materia/SeqActionByCategoryMateria", "./materia/MateriaBase", "./recept/AbilityPanel", "./recept/ReceptBase", "./recept/Skip", "./recept/SoulStrike", "./recept/SoulStrikePanel", "./recept/SupporterSoulStrike", "./recept/PositiveIncontrollable", "./util/DamageCalculator", "./util/DamageCalculateHook", "./util/DelayCallback", "./util/DropItem", "./util/Targeting", "./util/EnemyTargeting", "./util/PanelTargeting", "./view/AbilityPanelView", "./view/BackgroundView", "./view/BuddyView", "./view/CommandView", "./view/MateriaDropView", "./view/DropItemView", "./view/EnemyContainer", "./view/EnemyView", "./view/MenuWindowView", "./view/LoadingView", "./view/MessageView", "./view/SoulStrikeView", "./view/SoulStrikeSelectorView", "./view/SoulStrikeGauge", "./view/StatusAilmentsView", "./view/ContinueBonusView", "./view/TargetArrowView", "./view/TutorialBattleView", "./view/animation/AbilityBarrageAnimation", "./view/animation/AbilitySingleAnimation", "./view/animation/AbilitySingleAndDeformAnimation", "./view/animation/AbilityBarrageAndDeformAnimation", "./view/animation/AnimationBase", "./view/animation/AnimationFactory", "./view/animation/AnimationHelper", "./view/animation/AppearanceAnimation", "./view/animation/AttackAnimation", "./view/animation/InvalidityAnimation", "./view/animation/DamageAnimation", "./view/animation/DeadAnimation", "./view/animation/DeformAnimation", "./view/animation/DropItemAnimation", "./view/animation/JumpInAnimation", "./view/animation/JumpOutAnimation", "./view/animation/TransitionAnimation", "./view/animation/EnemyJumpAnimation", "ww/scenes/battle/view/VCListView", "./view/animation/ReraiseRiseAnimation"], function(e, t, n, r, i, s, o, u, a, f) {
    var l = "battle/ai/conf/%d",
        c = 2,
        h = FF.ns.battle;
    return n.extend({
        initialize: function(e) {
            e = e || {}, FF.logger.debug("call BattleScene initialize!"), this.isFinished = !1, this._fpsCount = 0, this._fpsBaseTime = 0
        },
        setupDeferred: function() {
            var e = this,
                t = this.getErrorHandler(),
                n = void 0;
            return f.Deferred().resolve().promise().then(t.bindTryCatchDeferred(function() {
                return n = "4017", FF.logger.debug("checkSession"), e._checkSessionDeferred()
            })).then(t.bindTryCatchDeferred(function() {
                return n = "4020", FF.logger.debug("loadStorage"), s.loadDeferred()
            })).then(t.bindTryCatchDeferred(function() {
                return n = "4033", FF.logger.debug("requestBattleData"), e._requestBattleDataDeferred()
            })).then(t.bindTryCatchDeferred(function(e) {
                n = "4046", FF.logger.debug("validate data");
                var t = new h.BattleInitData(e);
                h.BattleInfo.getInstance().load(t.validate())
            })).then(t.bindTryCatchDeferred(function() {
                return n = "4059", i.loadBattleConfigDeferred().then(function(e) {
                    h.BattleInfo.getInstance().setBattleConfig(e)
                })
            })).then(t.bindTryCatchDeferred(function() {
                n = "4062", FF.logger.debug("loadAbility");
                var e = h.BattleInfo.getInstance().getBattleInitData(),
                    t = e.battle,
                    r = [];
                r = r.concat(t.enemyAbilities), _.each(t.buddy, function(e) {
                    r = r.concat(_.values(e.abilities)), _.each(e.soulStrikes, function(e) {
                        r.push(e)
                    })
                }, this), _.each(t.supporter, function(e) {
                    r = r.concat(_.values(e.abilities)), r.push(e.soulStrikes[0])
                }, this), h.AbilityInfoMgr.getInstance().load(r)
            })).then(t.bindTryCatchDeferred(function() {
                return n = "4075", FF.logger.debug("requestDynamicJs"), e._requestDynamicJsDeferred()
            })).then(t.bindTryCatchDeferred(function() {
                n = "4088";
                var e = h.BattleInfo.getInstance().getBattleInitData();
                return h.Message.load(e.battle.messages), h.BattleViewController.getInstance().loadDeferred(e)
            })).fail(function(e) {
                if (!FF.env.isNative()) throw e;
                window.onErrorFunc(e, n)
            })
        },
        _checkSessionDeferred: function() {
            var e = f.Deferred();
            if (!FF.env.isNative()) return e.resolve().promise();
            if (FF.env.isTutorial()) return e.resolve().promise();
            var t = h.BattleInfo.getInstance().getAppInitDataSessionKey();
            return r.checkSessionAndUpdateDeferred(t)
        },
        navigate: function(e, t) {
            h.BattleViewController.getInstance().deactivateABScreen(), a.history.navigate(e, t)
        },
        redirect: function(t, n) {
            n = e.option({
                noFadeOut: !1
            }, n);
            var r = h.BattleViewController.getInstance(),
                i = function() {
                    r.deactivateABScreen(), FF.redirect(t)
                };
            if (n.noFadeOut) {
                i();
                return
            }
            r.playFadeOutDeferred().then(i)
        },
        redirectTop: function() {
            FF.scene.redirect("/dff/", {
                noFadeOut: !0
            })
        },
        start: function() {
            var e = this;
            h.BattleInfo.getInstance().set("isPlaying", !0), this.defineOnAppForeground();
            var n = this.getErrorHandler();
            n.onError = function(e) {
                FF.env.isNative() && h.BattleViewController.getInstance().showSystemWindow(h.Conf.SYSTEM_WINDOW.ERROR), FF.scene.suspend(), FF.logger.debug(e.message, e.stack)
            }, h.ExternalUserAuth.checkExternalUserAuthCallDeferred().always(function() {
                e.battleEventMgr = new h.BattleEventMgr, e.listenTo(t, "tick", n.bindTryCatch(e._update, e)), e.ticker = t
            })
        },
        defineOnAppForeground: function() {
            if (!FF.env.isNative()) return;
            kickmotor.nativefn.onApplicationForeground = function() {
                h.BattleViewController.getInstance().startPause(), FF.env.checkMobageLoginDeferred().then(function(e) {
                    e ? h.ExternalUserAuth.checkExternalUserAuthCallDeferred() : h.BattleViewController.getInstance().showSystemWindow(h.Conf.SYSTEM_WINDOW.LOGIN)
                }), kickmotor.nativefn.getRemoteNotificationLog(function(e) {
                    if (!e) return;
                    h.RemoteLogger.pushRemoteNotificationInfomation(e)
                })
            }
        },
        clearOnAppForeground: function() {
            kickmotor.nativefn.onApplicationForeground = function() {}
        },
        suspend: function() {
            if (!h.BattleInfo.getInstance().get("isPlaying")) return;
            h.BattleInfo.getInstance().set("isPlaying", !1), h.BattleViewController.getInstance().suspendAnime(), FF.SoundMgr.pause()
        },
        resume: function() {
            if (h.BattleInfo.getInstance().get("isPlaying")) return;
            h.BattleInfo.getInstance().set("isPlaying", !0);
            var e = h.BattleViewController.getInstance();
            e.resumeAnime(), FF.env.isTutorial() && e.tutorialBattleView.setVisible(!0), FF.SoundMgr.resume()
        },
        escape: function() {
            var e = this;
            h.BattleViewController.getInstance().resumeAnime(), h.BattleResultFsm.sendEscapeResultDeferred().done(function(t) {
                e.saveBattleConfigDeferred().then(function() {
                    s.removeDataDeferred().then(function() {
                        var n = h.BattleInfo.getInstance();
                        n.set("resultInfo", {
                            data: t
                        }), e._transferEscapePage()
                    })
                })
            })
        },
        toggleDoubleSpeed: function() {
            this.isDoubleSpeed ? (h.BattleViewController.getInstance().setUpdateTimeSpeed(1), this.isDoubleSpeed = !1) : (h.BattleViewController.getInstance().setUpdateTimeSpeed(c), this.isDoubleSpeed = !0)
        },
        saveBattleConfigDeferred: function() {
            return i.saveBattleConfigDeferred(h.BattleInfo.getInstance().getBattleConfig())
        },
        _requestBattleDataDeferred: function() {
            var e = this,
                t = f.Deferred();
            if (!FF.env.isNative()) return t.resolve(this._battleInitData).promise();
            var n = this.getErrorHandler();
            return h.Api.getBattleInitDeferred().then(n.bindTryCatchDeferred(function(n, r, i) {
                n.initChkResult = e._validateInitChk(i.responseText, i.getResponseHeader("Ff-chk")), n.resClientSnapshot = h.ParameterEncoder.snapshotResponse(n), t.resolve(n)
            })).fail(function() {
                t.reject()
            }), t.promise()
        },
        _requestDynamicJsDeferred: function() {
            var e = f.Deferred(),
                t = [],
                n = h.BattleInfo.getInstance().getEnemyContainerParams();
            _.each(n, function(e) {
                if (!e.aiId) return;
                t.push(e.aiId)
            });
            var r = h.BattleInfo.getInstance().getEnemyParams();
            _.each(r, function(e) {
                if (!e.aiId) return;
                t.push(e.aiId)
            }), t = _.uniq(t);
            var i = _.map(t, function(e) {
                return sprintf(l, e)
            });
            return o.load(i, function() {
                e.resolve()
            }), e.promise()
        },
        _validateInitChk: function(e, t) {
            var n = this.b(),
                r = this.c(),
                i = Chara.ZEROMUS(e + n, r).toString();
            return i === t
        },
        _transferNextScene: function() {
            var e = h.BattleInfo.getInstance();
            if (e.get("isExpired")) {
                this._exit(), this.redirectTop();
                return
            }
            if (e.get("isAllEnded")) {
                this._exit();
                var t = h.BattleViewController.getInstance();
                e.isVictory() ? this._transferWinPage() : e.isLose() ? this._transferLosePage() : e.isForceEscape() && this._transferEscapePage()
            }
        },
        _transferWinPage: function() {
            var e = h.BattleViewController.getInstance(),
                t = h.BattleInfo.getInstance();
            t.isResultAlreadyEnded() ? e.showSystemWindow(h.Conf.SYSTEM_WINDOW.BATTLE_RESULT, function() {
                FF.scene.redirect(t.detectUrlFromResultInfo())
            }) : t.isResultExpired() ? e.showSystemWindow(h.Conf.SYSTEM_WINDOW.EXPIRE, function() {
                FF.scene.redirect(t.detectUrlFromResultInfo())
            }) : t.isResultError() ? e.showSystemWindow(h.Conf.SYSTEM_WINDOW.ERROR, function() {
                FF.scene.redirect(t.detectUrlFromResultInfo())
            }) : (this.clearOnAppForeground(), FF.battleResult = t.get("resultInfo").data, FF.battleResult.battleLayers = e.assetsManager.layerNames, this.navigate("battle_result", !0))
        },
        _transferLosePage: function() {
            var e = h.BattleInfo.getInstance();
            FF.scene.redirect(e.detectUrlFromResultInfo())
        },
        _transferEscapePage: function() {
            var e = h.BattleInfo.getInstance();
            FF.SoundMgr.stopMusic(), FF.SoundMgr.resume(), FF.scene.redirect(e.detectUrlFromResultInfo())
        },
        _exit: function() {
            this.isFinished = !0, t.reset(), this.stopListening()
        },
        _update: function(e) {
            this.elapsedTime = e;
            if (h.BattleInfo.getInstance().get("isPlaying")) {
                this.timeCompression > 0 && (this.elapsedTime *= this.timeCompression);
                var t = h.BattleInfo.getInstance().getBattleConfig().speed || 100;
                this.elapsedBattleTime = Math.floor(e * +t / 100), this.battleEventMgr.update(), h.Message.update(), h.BattleViewController.getInstance().update(), h.util.DelayCallback.update(this.elapsedTime, this.elapsedBattleTime), u.update(this.elapsedTime), h.BattleLog.update()
            }
            this._transferNextScene(), this._updateFps()
        },
        _updateFps: function() {
            if (!FF.env.isDevelop()) return;
            this._fpsCount++;
            var t = e.getTime(),
                n = t - this._fpsBaseTime;
            n > 1e3 && (this.fps = Math.floor(this._fpsCount / n * 1e3), this._fpsCount = 0, this._fpsBaseTime = t)
        },
        b: function() {
            return FF.env.b
        },
        c: function() {
            return FF.env.c
        },
        d: function() {
            return FF.env.f
        },
        dispose: function() {
            n.prototype.dispose.apply(this)
        }
    })
}), define("scenes/common/config/FriendInvite", ["lib/TextMaster"], function(e) {
    return {
        postingTextOf: {
            copy: "ã€FINAL FANTASY Record Keeperã€‘",
            facebook: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            fb_messenger: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            twitter: function() {
                return e.getInstance().get("friend_invite_text_short")
            },
            mail: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            line: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            googleplus: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            whatsapp: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            other: function() {
                return e.getInstance().get("friend_invite_text_short")
            }
        }
    }
}), define("scenes/common/config/GoogleAnalytics", [], function() {
    var e = {
        BattleAnimationStart: "BattleAnimationStart",
        BattleAnimationResult: "BattleAnimationResult",
        EquipEnhancementAnimation: "EquipEnhancementAnimation",
        EquipEvolutionAnimation: "EquipEvolutionAnimation",
        AbilityGenerateAnimation: "AbilityGenerateAnimation",
        AbilityUpgradeAnimation: "AbilityUpgradeAnimation"
    };
    return {
        DIRECT_CALL_SCREEN_NAME_OF: e,
        screenNameToUrlRegex: {
            WorldTop: /^#?world$/,
            GameTop: /^#?title$/,
            DungeonsSelect: /^#?world\/dungeons\/[^\/]+$/,
            BattlesSelect: /^#?world\/battles\/[^\/]+$/,
            EventsTop: /^#?events$/,
            EventsDungeonsSelect: /^#?event\/[^\/]+\/[^\/]+\/dungeons$/,
            EventsBattleSelect: /^#?event\/[^\/]+\/[^\/]+\/battles\/[^\/]+$/,
            EventsPrizes: /^#?event\/[^\/]+\/[^\/]+\/prizes$/,
            PartyTop: /^#?party$/,
            EquipChangeEdit: /^#?party\/equipment_change\/[^\/]+$/,
            GachaLineUp: /^#?gacha$/,
            GachaTop: /^#?gacha\/top\/[^\/]+$/,
            GachaAnimation: /^#?gacha\/anim\/(free|item|coin)\/$/,
            GachaResult: /^#?gacha\/result\/$/,
            BattleLose: /^#?battle\/fail\/[^\/]+\/lose\/$/,
            DungeonsClear: /^#?world\/battles\/[^\/]+\/clear$/,
            EquipTop: /^#?party\/equipment_top$/,
            EquipLimitExpand: /^#?party\/possession_limit_expand\/equipment$/,
            EquipChangeTop: /^#?party\/equipment$/,
            GiftBox: /^#?gift_box$/,
            EquipEnhancement: /^#?party\/enhancement$/,
            EquipEnhancementSelect: /^#?party\/enhancement_selected\/[^\/]+$/,
            AbilityChangeEdit: /^#?party\/ability_change\/[^\/]+$/,
            AbilityTop: /^#?party\/ability_top$/,
            AbilityLimitExpand: /^#?party\/possession_limit_expand\/ability$/,
            EquipChangeEditWeapon: /^#?party\/equipment_change_detail\/[^\/]+\/weapon$/,
            EquipChangeEditArmor: /^#?party\/equipment_change_detail\/[^\/]+\/armor$/,
            AbilityChange: /^#?party\/ability$/,
            AbilityGenerate: /^#?party\/ability_generate$/,
            PartyEditTop: /^#?party\/party_edit$/,
            BattleOpeTop: /^#?battle\/operations$/,
            AbilityChangeEditSlot1: /^#?party\/ability_change_detail\/[^\/]+\/1$/,
            EquipChangeEditAccessory: /^#?party\/equipment_change_detail\/[^\/]+\/accessory$/,
            AbilityChangeEditSlot2: /^#?party\/ability_change_detail\/[^\/]+\/2$/,
            EquipEvolution: /^#?party\/evolution$/,
            AbilityUpgrade: /^#?party\/ability_upgrade$/,
            BattleLeave: /^#?battle\/fail\/[^\/]+\/leave\/$/,
            EquipEvolutionSelect: /^#?party\/evolution_selected\/[^\/]+$/,
            EventsIntro: /^#?event\/[^\/]+\/intro$/,
            Quest: /^#?quest$/
        }
    }
}), define("scenes/common/config/PartialTemplate", [], function() {
    return {
        paths: ["templates/achievement_room/views/AchivementInfoCondition", "templates/party/views/AbilityGenerationList", "templates/party/views/AbilityUpgradeList"]
    }
}), define("scenes/common/Config", ["./config/FriendInvite", "./config/GoogleAnalytics", "./config/PartialTemplate"], function(e, t, n) {
    return {
        friendInvite: e,
        googleAnalytics: t,
        partialTemplate: n
    }
}), define("scenes/common/helper/FirstDungeonClearFlag", ["jquery", "lib/Storage"], function(e, t) {
    var n = "first_dungeon_clear_flag";
    return {
        saveDeferred: function(e) {
            var r = {
                isFirstClear: e
            };
            return t.setItemDeferred(n, JSON.stringify(r))
        },
        loadDeferred: function() {
            var r = e.Deferred();
            return t.getItemDeferred(n).then(function(e) {
                var t = e.value ? JSON.parse(e.value) : {};
                r.resolve(t)
            }), r.promise()
        },
        resetDeferred: function() {
            return t.removeItemDeferred(n)
        }
    }
}), define("scenes/progress_map/LatestProgressData", ["lib/Storage"], function(e) {
    var t = {
        DUNGEON: "latest_dungeon_data",
        CAN_RETURN: "can_return_progress_map"
    };
    return {
        saveCanReturnDeferred: function(n) {
            var r = this,
                i = $.Deferred(),
                s = {
                    canReturn: n
                };
            return e.setItemDeferred(t.CAN_RETURN, JSON.stringify(s)).then(function(e) {
                i.resolve()
            }), i.promise()
        },
        saveDungeonDataByModelsDeferred: function(e, t) {
            if (e.isNormalWorld()) {
                var n = t.get("id"),
                    r = t.isForce(),
                    i = t.get("progress_map_level");
                return r ? this.saveDungeonDataDeferred(void 0, n, i, !0) : this.saveDungeonDataDeferred(n, void 0, i, !1)
            }
            return $.Deferred().resolve().promise()
        },
        saveDungeonDataDeferred: function(n, r, i, s) {
            var o = $.Deferred(),
                u = {
                    level: i,
                    dungeonId: void 0,
                    normalDungeonId: n,
                    forceDungeonId: r,
                    isForce: s
                };
            return e.setItemDeferred(t.DUNGEON, JSON.stringify(u)).then(function(e) {
                o.resolve()
            }), o.promise()
        },
        getCanReturnDeferred: function() {
            var n = this,
                r = $.Deferred();
            return e.getItemDeferred(t.CAN_RETURN).then(function(e) {
                var t = e.value ? JSON.parse(e.value) : {};
                r.resolve(t)
            }), r.promise()
        },
        getDungeonDataDeferred: function() {
            var n = this,
                r = $.Deferred();
            return e.getItemDeferred(t.DUNGEON).then(function(e) {
                var t = e.value ? JSON.parse(e.value) : {};
                r.resolve(t)
            }), r.promise()
        }
    }
}), define("scenes/battle_result/models/Score", ["backbone"], function(e) {
    var t = e.Model.extend({
        initialize: function(e) {
            this.medalStatuses = [], _.each(e, _.bind(function(e) {
                var t = +e.medalNum,
                    n = [];
                for (var r = 0; r < t; r++) n.push(!1);
                this.medalStatuses.push(n)
            }, this)), this.maxMedalNum = this.medalStatuses.length * 3, this.medalSum = _.reduce(this.medalStatuses, function(e, t) {
                return e + t.length
            }, 0), this.currentIntervalRank = 0, this.thresGood = this.maxMedalNum / 2, this.thresExcellent = this.maxMedalNum * 5 / 6, this.startRatio = this.currentIntervalRatio = 0, this.currentIntervalMedalNum = 0, this.endRatio = this.medalSum / this.maxMedalNum
        },
        progress: function(e) {
            this.currentIntervalRatio += e, this.currentIntervalRatio >= this.endRatio && (this.currentIntervalRatio = this.endRatio);
            var t = this._calcMedalNum();
            this.trigger("update:gauge", this._getFrameByRatio(this.currentIntervalRatio)), t > this.currentIntervalMedalNum && this._showMedal(t - this.currentIntervalMedalNum), this.currentIntervalMedalNum = t, this._updateCurrentIntervalRank(), this.currentIntervalRatio >= this.endRatio && this.trigger("finish:animation")
        },
        _getFrameByRatio: function(e) {
            return e * 100 || 0
        },
        _calcMedalNum: function() {
            return Math.floor(this.maxMedalNum * this.currentIntervalRatio)
        },
        _showMedal: function(e) {
            _.each(this.medalStatuses, _.bind(function(t, n) {
                if (e === 0) return;
                var r = 0,
                    i = 0;
                _.each(t, function(e) {
                    e ? i++ : r++
                });
                if (!r) return;
                for (var s = i; s < t.length; s++) e > 0 && (this.medalStatuses[n][s] = !0, this.trigger("show:medal", n, s), e--)
            }, this))
        },
        _getRankByMedalNum: function(e) {
            return e >= this.thresExcellent ? 2 : e >= this.thresGood ? 1 : 0
        },
        _updateCurrentIntervalRank: function() {
            var e = this._getRankByMedalNum(this.currentIntervalMedalNum);
            if (e > this.currentIntervalRank) {
                for (var t = this.currentIntervalRank + 1; t <= e; t++) this.trigger("update:rank", t);
                this.currentIntervalRank = e
            }
        },
        _calcRankCoords: function(e) {
            var t = -250,
                n = 250,
                r, i = -10,
                s = (n - t) / this.maxMedalNum;
            if (e === 0) r = t;
            else if (e === 1) r = t + s * this.thresGood - 3;
            else {
                if (e !== 2) throw new Error("invalid rank " + e);
                r = t + s * this.thresExcellent - 7
            }
            return [r, i]
        },
        getRankNodeName: function() {
            var e = this._getRankByMedalNum(this.medalSum);
            return "rank_" + (e + 1) + "_nul"
        }
    });
    return t
}), define("scenes/battle_result/views/AnimationPool", ["underscore", "jquery", "backbone", "sprintf", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i, s) {
    return s.extend({
        initialize: function(e) {
            e = e ? e : {}, this.interval = e.interval || 16, this.nodes = e.nodes || []
        },
        flush: function() {
            var t = [];
            e.each(this.nodes, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        start: function() {
            var e = this;
            this.timer = setInterval(function() {
                e.flush()
            }, this.interval)
        },
        stop: function() {
            clearInterval(this.timer)
        },
        dispose: function() {
            this.nodes = null, this.stop()
        }
    })
}), define("scenes/battle_result/views/ResultScore", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/EventBase", "util", "../models/Score", "./AnimationPool"], function(e, t, n, r, i, s, o, u) {
    var a = {
        SCORE_SOUND_MAP: {
            1: "SE_RESULT_NORMAL",
            2: "SE_RESULT_GOOD",
            3: "SE_RESULT_EXCELLENT"
        },
        SE: {
            SE_RESULT_EXCELLENT: "se_battle_common_101053",
            SE_RESULT_GOOD: "se_battle_common_101052",
            SE_RESULT_NORMAL: "se_battle_common_101051"
        },
        INTERVAL_UPDATING_GAUGE: 30,
        INCREMENTAL_RATIO_PER_LOOP: .03,
        INCREMENTAL_RATIO_ON_COMPLETE_AT_ONCE: 1,
        WAIT_MS_BEFORE_RANK_EFFECT: 300
    };
    return i.extend({
        initialize: function(e) {
            FF.logger.debug("ResultScore: initialize", e), this.tutorialView = e.tutorialView, this.score = e.result.score, this.scoreBaseExp = Number(e.result.scoreBaseExp), this.scoreExpWithBonus = Number(e.result.scoreExpWithBonus), this.gil = Number(e.result.gil), this.layer = e.layer, this.fps = 16, this.msecPerFrame = 1e3 / this.fps, this.bonusExpAnimTimeInterval = 800, this.intervalToStartBonusCountUp = 1200, this.animationPool = new u, this.animationPool.start(), this.stageNode = new r({
                name: "stage_nul",
                layer: this.layer.layerName
            }), this.totalScoreNode = new r({
                name: "total_score_nul",
                layer: this.layer.layerName
            }), this.animationPool.nodes.push(this.totalScoreNode), this.expNumNode = new r({
                name: "exp_num_nul",
                layer: this.layer.layerName
            }), this.animationPool.nodes.push(this.expNumNode), this.gilNode = new r({
                name: "gil_nul",
                layer: this.layer.layerName
            }), this.animationPool.nodes.push(this.gilNode), this.duplicatedNodes = [];
            var t = this.makeSpecificScores(),
                n = this.makeGeneralScores();
            this.scoreInfo = n.concat(t), this.scoreModel = new o(this.scoreInfo), this.rankNode = new r({
                name: this.scoreModel.getRankNodeName(),
                layer: this.layer.layerName,
                parentNodeName: "bonus_rank_" + this.score.rank + "_nul"
            }), this.rankNode.setVisible(!1), this.animationPool.nodes.push(this.rankNode)
        },
        makeSpecificScores: function() {
            var t = 3,
                n = [];
            for (var i = 0, s = this.score.specific.length; i < s; i++) {
                if (!this.score.specific[i]) return n;
                if (i >= t) return FF.logger.error("specific score num is over maxLength:" + t), n;
                var o = (new r({
                        name: "dup_txt_special_score_pos_nul_" + (i + 1),
                        layer: this.layer.layerName,
                        duplicateFrom: "txt_score_base_nul",
                        duplicateFromOptions: {
                            parentNode: "txt_special_score_pos_nul_" + (i + 1)
                        }
                    })).process(),
                    u = [];
                for (var a = 1; a <= 3; a++) {
                    var f = (new r({
                        name: "dup_s_medal_" + (i + 1) + "_" + a,
                        layer: this.layer.layerName,
                        duplicateFrom: "medal_nul",
                        duplicateFromOptions: {
                            parentNode: "medal_pos_nul_" + a,
                            parentTopNode: o.name
                        }
                    })).process();
                    this.duplicatedNodes.push(f), u.push(f)
                }
                n.push(e.extend({
                    textPosNode: o,
                    medalNodes: u
                }, this.score.specific[i])), this.duplicatedNodes.push(o), this.animationPool.nodes.push(o)
            }
            return n
        },
        makeGeneralScores: function() {
            var t = 3,
                n = [];
            for (var i = 0, s = this.score.general.length; i < s; i++) {
                if (!this.score.general[i]) return n;
                if (i >= t) return FF.logger.error("general score num is over maxLength:" + t), n;
                var o = (new r({
                        name: "dup_txt_score_pos_nul_" + (i + 1),
                        layer: this.layer.layerName,
                        parentNodeName: "txt_score_pos_nul_" + (i + 1),
                        duplicateFrom: "txt_score_base_nul",
                        duplicateFromOptions: {
                            parentNode: "txt_score_pos_nul_" + (i + 1)
                        }
                    })).process(),
                    u = [];
                for (var a = 1; a <= 3; a++) {
                    var f = (new r({
                        name: "dup_g_medal_" + (i + 1) + "_" + a,
                        layer: this.layer.layerName,
                        duplicateFrom: "medal_nul",
                        duplicateFromOptions: {
                            parentNode: "medal_pos_nul_" + a,
                            parentTopNode: o.name
                        }
                    })).process();
                    this.duplicatedNodes.push(f), u.push(f)
                }
                n.push(e.extend({
                    textPosNode: o,
                    medalNodes: u
                }, this.score.general[i])), this.duplicatedNodes.push(o), this.animationPool.nodes.push(o)
            }
            return n
        },
        start: function() {
            var t = this;
            this.expNumNode.setText("exp_num_value_txt", this.scoreBaseExp).play("score_total_start"), this.gilNode.setText("gil_value_txt", this.gil).play("score_total_start"), this.prepareScoreItems(), this.animateGaugeDeferred().then(this.tutorialView.getTutorialFunc("firstMog")).then(e.bind(this.waitBeforeRankEffectDeferred, this)).then(e.bind(this.showRankDeferred, this)).then(e.bind(this.animateBonusDeferred, this)).then(this.tutorialView.getTutorialFunc("battleScoreMog")).then(e.bind(this.showNextDeferred, this))
        },
        prepareScoreItems: function() {
            e.each(this.scoreInfo, function(t) {
                FF.logger.debug("scoreinfo", t), t.textPosNode.play("score_txt_start").setText("score_key_txt", t.title).process(), e.each(t.medalNodes, function(e) {
                    e.play("medal_empty").process()
                })
            }), this.rankPointNodes = [];
            for (var t = 0; t < 3; t++) this.rankPointNodes.push(new r({
                name: "rank_point_nul_" + (t + 1),
                layer: this.layer.layerName
            })), this.rankPointNodes[t].setPosition(this.scoreModel._calcRankCoords(t)).process();
            this.rankPointNodes[0].setVisible(!1).process()
        },
        animateGaugeDeferred: function() {
            return this.gaugeDeferred = t.Deferred(), this.scoreGauge = new r({
                name: "mask_image_total_guage",
                layer: this.layer.layerName
            }), this.listenToOnce(this.scoreModel, "finish:animation", e.bind(function() {
                this.stopListening(this.scoreModel), this.gaugeDeferred.resolve()
            }, this)), this.listenTo(this.scoreModel, "update:gauge", e.bind(function(e) {
                this.scoreGauge.playFrame("score_guage", e, e).process()
            }, this)), this.listenTo(this.scoreModel, "show:medal", e.bind(function(t, n) {
                FF.logger.debug("show:medal received", [t, n]), this.scoreInfo[t].medalNodes[n].setVisible(!0).play("medal_in").processDeferred("action_stop").then(e.bind(function() {
                    this.scoreInfo[t].medalNodes[n].play("medal_loop").process()
                }, this))
            }, this)), this.listenTo(this.scoreModel, "update:rank", e.bind(function(e) {
                FF.logger.debug("update:rank received", e), this.rankPointNodes[e].play("score_guage_clear").process()
            }, this)), this.gaugeDeferred.progress(e.bind(function(t) {
                this.scoreModel.progress(t);
                var n = setInterval(e.bind(function() {
                    clearInterval(n), this.shouldCompleteAtOnce ? this.gaugeDeferred.notify(a.INCREMENTAL_RATIO_ON_COMPLETE_AT_ONCE) : this.gaugeDeferred.notify(a.INCREMENTAL_RATIO_PER_LOOP)
                }, this), a.INTERVAL_UPDATING_GAUGE)
            }, this)), this.gaugeDeferred.notify(a.INCREMENTAL_RATIO_PER_LOOP), this.gaugeDeferred.promise()
        },
        waitBeforeRankEffectDeferred: function() {
            var e = t.Deferred();
            if (this.shouldCompleteAtOnce) e.resolve();
            else var n = setInterval(function() {
                clearInterval(n), e.resolve()
            }, a.WAIT_MS_BEFORE_RANK_EFFECT);
            return e.promise()
        },
        showRankDeferred: function() {
            var e = t.Deferred(),
                n = a.SE[a.SCORE_SOUND_MAP[this.score.rank]];
            return FF.SoundMgr.playEffect(n), this.rankNode.setVisible(!0).play("rank").processDeferred("action_stop").then(function() {
                e.resolve()
            }), e.promise()
        },
        animateBonusDeferred: function() {
            var n = t.Deferred();
            return this.waitForPlayBonusExpDeferred().then(e.bind(function() {
                return this.playBonusExpDeferred()
            }, this)).then(e.bind(function() {
                n.resolve()
            }, this)), n.promise()
        },
        showNextDeferred: function() {
            return this.isDone = !0, this.trigger("show:nextBtn"), t.Deferred().resolve().promise()
        },
        waitForPlayBonusExpDeferred: function() {
            var e = this,
                n = t.Deferred();
            if (!this.hasBonusExp()) return n.resolve().promise();
            this.rankNode.play("rank_bonus");
            var r = s.getTime(),
                i = setInterval(function() {
                    var t = s.getTime() - r;
                    t > e.intervalToStartBonusCountUp && (clearInterval(i), n.resolve())
                }, this.msecPerFrame);
            return n.promise()
        },
        playBonusExpDeferred: function() {
            var e = this,
                n = t.Deferred(),
                r = s.getTime(),
                i = setInterval(function() {
                    var t = s.getTime() - r,
                        o = t / e.bonusExpAnimTimeInterval;
                    o < 1 ? e.updateTotalExp(o) : (e.updateTotalExp(1), clearInterval(i), n.resolve())
                }, e.msecPerFrame);
            return n.promise()
        },
        updateTotalExp: function(e) {
            var t = this.scoreExpWithBonus - this.scoreBaseExp,
                n = Math.round(this.scoreBaseExp + t * e);
            this.expNumNode.setText("exp_num_value_txt", n)
        },
        hasBonusExp: function() {
            return this.score.rank > 1
        },
        completeAtOnce: function() {
            !this.isDone && !this.shouldCompleteAtOnce && (FF.SoundMgr.playChooseEffect(), this.bonusExpAnimTimeInterval = 10, this.intervalToStartBonusCountUp = 10, this.shouldCompleteAtOnce = !0)
        },
        dispose: function() {
            this.animationPool.dispose(), this.animationPool = null, this.totalScoreNode.setVisible(!1).process(), e.each(this.scoreInfo, function(t) {
                e.each(t.medalNodes, function(e) {
                    e.suspendParticle().process()
                })
            });
            var t = function(t) {
                e.each(t, function(e) {
                    e && (e.removeAllCallback(), e.deleteNode().process())
                })
            };
            t(this.duplicatedNodes), this.tutorialView = void 0
        }
    })
}), define("scenes/battle_result/views/ExpCell", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/EventBase", "util", "lib/TextMaster"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle,
        a = {
            1: "_150",
            2: "_200"
        };
    return i.extend({
        initialize: function(t) {
            this.idx = t.idx, this.layer = t.layer, this.assetsManager = t.assetsManager, this.model = t.model, this.animationPool = t.animationPool;
            var n = this.assetsManager.getAssetInfo("player_common");
            this._setStatusAilmentsFlg();
            var i;
            if (this.isPetrified) {
                var s = FF.ns.battle.Conf.STATUS_AILMENTS_TYPE.PETRIFACTION + "";
                i = "buddy-" + this.model.get("path") + "_" + s
            } else i = "buddy-" + this.model.get("path");
            var u = this.assetsManager.getAssetInfo(i);
            this.expNode = (new r({
                name: "dup_exp_" + this.idx,
                layer: this.layer.layerName,
                parentNodeName: "exp_chara_pos_nul_" + this.idx,
                duplicateFrom: "exp_chara_nul",
                duplicateFromOptions: {
                    parentNode: "exp_chara_pos_nul_" + this.idx
                }
            })).process();
            var a = "soulstrike_exp";
            this.canShowSeriesEffect() && (a = "soulstrike_exp_series"), this.soulStrikeExpNode = (new r({
                name: "dup_soulstrike_exp_" + this.idx,
                layer: this.layer.layerName,
                parentNodeName: "soulstrike_exp_pos_" + this.idx,
                duplicateFrom: a,
                duplicateFromOptions: {
                    parentNode: "soulstrike_exp_pos_" + this.idx
                }
            })).setVisible(!1).process();
            var f = "dup_exp_chara_" + this.idx;
            this.charaNode = (new r({
                name: f,
                layer: n.layerName,
                duplicateFrom: "character_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.layer.layerName,
                    visualParentNode: "chara_pos_nul",
                    visualParentTopNode: "exp_chara_pos_nul_" + this.idx
                }
            })).setParam({
                color_change_parent: f
            }).loadBundle(u.bundle).setSpriteAnimeByNode("sprite_character_base", u.assetPath).setSpriteAnimeByNode("sprite_character_add", u.assetPath).play("idle").process();
            if (this.canShowSeriesEffect()) {
                var l = this._getStatusBonusAssetName(),
                    c = this.assetsManager.getAssetInfo(l);
                this.seriesNode = (new r({
                    name: sprintf("status_bonus_eff_chara_%s", this.idx),
                    layer: c.layerName,
                    duplicateFrom: "status_bonus_eff_chara_nul",
                    duplicateFromOptions: {
                        visualParentLayer: n.layerName,
                        visualParentNode: "status_bonus_eff_back_pos_nul",
                        visualParentTopNode: f
                    }
                })).setVisible(!0).play("play").process()
            }
            this.isDead && this.charaNode.play("dead").process(), this.setExpNode(), this.CurrentLevelNode = this.expNode.createVirtualNode("exp_lv_txt"), this.CurrentLevelNode.setText("exp_lv_txt", "Lv" + this.model.get("startLevel"), {
                topNode: this.expNode.name
            }).process(), this.HPNode = this.expNode.createVirtualNode("exp_hp_txt_nul"), this.HPNode.setText("exp_hp_txt", sprintf("%s / %s", this.model.get("hp"), this.model.get("maxHp"))).process(), this.charaNameNode = this.expNode.createVirtualNode("chara_name_nul"), this.charaNameNode.setText("chara_name_txt", this.model.get("name"), {
                topNode: this.expNode.name
            }).process(), this.CurrentLevelUpTextNode = this.expNode.createVirtualNode("exp_lv_up_txt"), this.expLvNextTextNode = this.expNode.createVirtualNode("exp_lv_next_txt"), this.animationPool.nodes.push(this.expLvNextTextNode), this.soulStrikeExpNode.play("init", {
                autoRemove: !1
            }).process(), this.expCoverNode = new r({
                name: "exp_cover_win",
                layer: this.layer.layerName
            }), this.expCoverNode.setVisible(!1).play("init", {
                autoRemove: !1
            }).process(), this.preLoadSoulStrikeExpImages(this.canShowSeriesEffect()), this._isMasterAnimCalled = [], this.setExpToNextLevelText(), this.listenTo(this.model, "levelUp", e.bind(this.levelUp, this)), this.listenTo(this.model, "change:progressRatio", e.bind(this.progress, this)), this.listenTo(this.model, "change:progressSSRatio", e.bind(this.progressSS, this));
            var h = o.getInstance().get("BWW15171");
            this.CurrentLevelNode.setText("exp_lv_txt", h + " " + this.model.get("startLevel"), {
                topNode: this.expNode.name
            }).process()
        },
        _setStatusAilmentsFlg: function() {
            var t = this.model.get("statusAilments");
            e.contains(t, FF.ns.battle.Conf.STATUS_AILMENTS_TYPE.PETRIFACTION + "") && (this.isPetrified = !0), e.contains(t, FF.ns.battle.Conf.STATUS_AILMENTS_TYPE.DEATH + "") && (this.isDead = !0)
        },
        setupDeferred: function() {
            var e = t.Deferred();
            return this.expGaugeNode.addCallbackOnce("action_stop", function() {
                e.resolve()
            }, {
                topNode: this.expNode.name
            }), this.expGaugeNode.playFrame("exp_guage", 0, this.model.getInitialFrame(), {
                speed: 100 * this.model.getInitialFrame()
            }).process(), this.previousFrame = 0, this.model.get("isLevelMax") && this.model.get("currentLevel") === this.model.get("endLevel") && this.suspendParticle(), this.model.get("incrementalExp") || this.suspendParticle(), e.promise()
        },
        setSoulStrikeExpGaugeDeferred: function() {
            var n = this,
                r = t.Deferred(),
                i = this.model.get("soulStrikeExps"),
                s = 0;
            return e.each(i, function(e) {
                var t = "_0" + (s + 1),
                    i = n.soulStrikeExpNodes[s];
                i.addCallbackOnce("action_stop", function() {
                    r.resolve()
                }, {
                    topNode: n.soulStrikeExpNode.name
                }), e.isAlreadyMastered || i.playFrame("exp_guage", 0, e.frameSets[0][0], {
                    speed: 100 * e.frameSets[0][0]
                }).process(), e.isAlreadyMastered && i.suspendParticle({
                    topNode: n.soulStrikeExpNode.name
                }).process(), s++
            }), this.previousSSFrame = 0, r.promise()
        },
        setSoulStrikeExpDeferredList: function() {
            var e = this.model.get("soulStrikeExps"),
                t = [];
            if (e.length === 0) return t;
            var n = this.canShowSeriesEffect();
            return t = t.concat(this.expCoverNode.setVisible(!0).play("soulstrike_exp_start").processDeferred("action_stop")), n ? (t = t.concat(this.soulStrikeExpNode.setVisible(!0).play("soulstrike_exp_start").processDeferred("action_stop")), t = t.concat(this._setSoulStrikeExpNodeByIsSeriesMatchedDeferredList(n))) : (t = t.concat(this.soulStrikeExpNode.setVisible(!0).play("soulstrike_exp_start").processDeferred("action_stop")), t = t.concat(this._setSoulStrikeExpNodeByIsSeriesMatchedDeferredList(n))), t
        },
        _setSoulStrikeExpNodeByIsSeriesMatchedDeferredList: function(t) {
            var n = this,
                r = this.model.get("soulStrikeExps"),
                i = this._getSoulStrikeExpNodeInfix(t),
                s = [];
            this.soulStrikeExpNodeOne = this.soulStrikeExpNode.createVirtualNode(sprintf("soulstrike_exp%s_01", i)), this.soulStrikeExpNodeOne.setVisible(!1).process(), this.soulStrikeExpNodeTwo = this.soulStrikeExpNode.createVirtualNode(sprintf("soulstrike_exp%s_02", i)), this.soulStrikeExpNodeTwo.setVisible(!1).process(), this.soulStrikeExpNodes = [this.soulStrikeExpNodeOne, this.soulStrikeExpNodeTwo];
            var o = 0;
            return e.each(r, function(e) {
                n.soulStrikeExpNodes[o].setVisible(!0).process();
                var t = "_0" + (o + 1);
                if (e.isAlreadyMastered) {
                    var r = n.soulStrikeExpNodes[o].createChildNode(sprintf("soulstrike_exp%s_gauge%s", i, t));
                    s.push(r.play("soulstrike_master_comp", {
                        autoRemove: !1
                    }).processDeferred("action_stop"))
                }
                o++
            }), s
        },
        preLoadSoulStrikeExpImages: function(t) {
            var n = this,
                r = this._getSoulStrikeExpNodeInfix(t),
                i = this.model.get("soulStrikeExps");
            if (i.length === 0) return;
            var s = 0;
            e.each(i, function(e) {
                var t = "_0" + (s + 1);
                n.soulStrikeExpNode.setText(sprintf("soulstrike_exp%s_txt%s", r, t), e.dispExp).process();
                if (+e.evolutionNum > 0) {
                    var i = a[+e.evolutionNum];
                    n.soulStrikeExpNode.createVirtualNode(sprintf("soulstrike_exp%s_bonus%s_img%s", r, i, t)).setVisible(!0).process()
                }
                n.soulStrikeExpNode.setText(sprintf("soulstrike_exp%s_name_txt%s", r, t), e.soulStrikeDispName).setVisible(!0).process(), n.soulStrikeExpNode.setText(sprintf("soulstrike_exp%s_num_txt%s", r, t), e.currentExp).setVisible(!0).process();
                var o = "equipment_" + e.soulStrikeId,
                    u = n.assetsManager.getAssetInfo(o);
                n.soulStrikeExpNode.loadBundle(u.bundle).setImage(sprintf("soulstrike_exp%s_equipment_img%s", r, t), u.assetPath).process();
                var f = "soul_strike_" + e.soulStrikeId,
                    l = n.assetsManager.getAssetInfo(f);
                n.soulStrikeExpNode.loadBundle(l.bundle).setImage(sprintf("soulstrike%s_img%s", r, t), l.assetPath).process(), e.previousExp === e.newExp && !e.isAlreadyMastered && n.suspendSoulStrikeExpParticle(), s++
            })
        },
        _getSoulStrikeExpNodeInfix: function(e) {
            return e ? "_series" : ""
        },
        progress: function() {
            var e = this.model.get("currentFrame");
            this.expGaugeNode.playFrame("exp_guage", e, e), this.setExpToNextLevelText(), this.previousFrame = e
        },
        progressSS: function() {
            var t = this,
                n = this.model.get("soulStrikeExps"),
                r = 0,
                i = this._getSoulStrikeExpNodeInfix(this.canShowSeriesEffect());
            e.each(n, function(e) {
                if (e.isAlreadyMastered) {
                    r++;
                    return
                }
                var n = "_0" + (r + 1),
                    s = t.soulStrikeExpNodes[r],
                    o = e.currentFrame;
                t.soulStrikeExpNode.setText(sprintf("soulstrike_exp%s_num_txt%s", i, n), e.currentExp).setVisible(!0).process();
                if (e.currentExp === 0) {
                    if (!t._isMasterAnimCalled[r]) {
                        var u = t.soulStrikeExpNode.createChildNode(sprintf("soulstrike_exp%s_gauge%s", i, n));
                        u.play("soulstrike_master").process()
                    }
                    t._isMasterAnimCalled[r] = !0
                } else s.playFrame("exp_guage", o, o).process();
                r++
            })
        },
        setExpNode: function() {
            this.expGaugeNode = this._setExpNode(), this.animationPool.nodes.push(this.expGaugeNode)
        },
        _setExpNode: function() {
            var e;
            return this.canShowMateriaExpBonusEffect() ? (this.expNode.createChildNode("guage_exp_lv_nul").setVisible(!1).process(), e = this._createMateriaBonusEffect()) : this.canShowSeriesEffect() ? (this.expNode.createChildNode("guage_exp_lv_nul").setVisible(!1).process(), e = this.expNode.createChildNode("series_exp_lv_nul").setVisible(!0).process()) : e = this.expNode.createChildNode("guage_exp_lv_nul").process(), e
        },
        canShowSeriesEffect: function() {
            return this._canShowEffect() ? this.isSeriesMatched() ? !0 : !1 : !1
        },
        canShowMateriaExpBonusEffect: function() {
            if (!this._canShowEffect()) return !1;
            var e = this.model.get("exp").expBonusInfo;
            return e.typeName !== "RECORD_MATERIA" ? !1 : !0
        },
        _canShowEffect: function() {
            return this.isDead ? !1 : this.isPetrified ? !1 : !0
        },
        _createMateriaBonusEffect: function() {
            var t = this.model.get("exp").expBonusInfo,
                n = t.boostRate,
                r = sprintf("%03d", +n),
                i = r.split("").reverse(),
                s = this.expNode.createChildNode("rmbonus_txt");
            return e.each(i, function(e, t) {
                var n = sprintf("rmbonus_num_%d_sprite", t);
                s.setSpriteActionByNode(n, sprintf("txt_%s", e))
            }), s.process(), this.expNode.createChildNode("rmbonus_exp_lv_nul").setVisible(!0).process()
        },
        isSeriesMatched: function() {
            return this.model.get("statusBonusFlgOf").buddy
        },
        _getStatusBonusAssetName: function() {
            var e = FF.ns.battle.Conf,
                t = {};
            return t[e.STATUS_BONUS_TYPE.SERIES] = "series_eff_chara", t[e.STATUS_BONUS_TYPE.ROLE] = "role_eff_chara", t[this.model.get("statusBonusTypeOf")]
        },
        levelUp: function(e) {
            this.expNode.play("exp_lv_up").process(), this.expNode.createChildNode("exp_hp_txt").setVisible(!1).process();
            var t = this.model.get("levelToHpMax")[e - 1],
                n = this.model.get("levelToHpMax")[e];
            this.expNode.createChildNode("exp_hp_lvup_txt").setText("exp_hp_lvup_txt", sprintf("%s / %sâ†’%s", n, t, n)).setVisible(!0).process(), this.setCurrentLevelUpText(e), this.charaNode.play("hands_up").process()
        },
        setExpToNextLevelText: function() {
            var e = this.model.get("expToNextLevel");
            this.expLvNextTextNode.setText("exp_lv_next_txt", e, {
                topNode: this.expNode.name
            })
        },
        setCurrentLevelUpText: function(e) {
            this.CurrentLevelUpTextNode.setText("exp_lv_up_txt", e, {
                topNode: this.expNode.name
            }).process()
        },
        suspendParticle: function() {
            this.expNode.suspendParticle().process()
        },
        suspendSoulStrikeExpParticle: function() {
            this.soulStrikeExpNode.suspendParticle().process()
        },
        isSoulStrikeCountUp: function() {
            var t = this.model.get("soulStrikeExps");
            return e.some(t, function(e) {
                return e.isAlreadyMastered ? !1 : e.previousExp === e.newExp ? !1 : !0
            })
        },
        dispose: function() {
            n.Events.stopListening(this.model, "change:progressRatio"), this.canShowSeriesEffect() && (this.seriesNode.suspendParticle().setVisible(!1).process(), this.seriesNode.deleteNode().process()), this.expNode.suspendParticle().process(), this.expNode.deleteNode().process(), this.charaNode.deleteNode().process(), this.expGaugeNode.deleteNode().process(), this.CurrentLevelNode.deleteNode().process(), this.charaNameNode.deleteNode().process(), this.CurrentLevelUpTextNode.deleteNode().process(), this.expLvNextTextNode.deleteNode().process(), this.soulStrikeExpNode.deleteNode().process(), this.layer = null, this.assetsManager = null, this.model = null, this.animationPool = null
        }
    })
}), define("scenes/battle_result/models/BuddyExp", ["backbone"], function(e) {
    var t = e.Model.extend({
        initialize: function(t) {
            e.Model.prototype.initialize.apply(t);
            var n = t.exp.levelToHpMax,
                r = t.exp.levelToExp,
                i = _.sortBy(_.keys(r), function(e) {
                    return +e
                });
            this.set("levels", i), this.set("levelToHpMax", n), this.set("levelToExp", r);
            var s, o = _.map(i, function(e, t) {
                return i[t + 1] && (s = r[i[t + 1]]), {
                    level: +e,
                    threshold: +r[e],
                    thresForNextLevel: +s
                }
            });
            this.levelMap = o, this.set("isLevelMax", t.exp.isLevelMax);
            var u = +t.exp.previousLevel,
                a = +t.exp.previousExp,
                f = +t.exp.currentLevel,
                l = +t.exp.currentExp,
                c = o[0].thresForNextLevel - a;
            _.isNaN(c) && (c = 0), this.set("expToNextLevel", c), this.set("startLevel", u), this.set("startExp", a), this.set("endLevel", f), this.set("endExp", l), this.set("incrementalExp", l - a);
            var h = this._buildFrameSets();
            FF.logger.debug("frameSets:", h), this.set("frameSets", h), this.set("currentFrameSet", 0), this.set("totalFrameCount", this.getTotalFrameCount()), this.set("currentExp", +this.get("startExp")), this.set("currentLevel", +this.get("startLevel")), this.set("progressRatio", 0), this.set("progressSSRatio", 0), this._setSoulStrikeExp()
        },
        _setSoulStrikeExp: function() {
            var e = this,
                t = this.get("soulStrikeExps");
            t = _.sortBy(t, function(e) {
                return +e.equipmentId
            }), _.each(t, function(t) {
                t.previousExp = +t.previousExp, t.newExp = +t.newExp, t.requiredExp = +t.requiredExp, t.frameSets = e._buildSSFrameSets(t.previousExp, t.newExp, t.requiredExp), t.totalFrame = e._getTotalSSFrameCount(t.frameSets), t.currentExp = +t.requiredExp - t.previousExp
            }), this.set("soulStrikeExps", t)
        },
        _buildFrameSets: function() {
            var e = [],
                t = this.get("levels"),
                n = this.get("levelToExp"),
                r = this.get("startExp"),
                i = this.get("endExp"),
                s = this.get("isLevelMax"),
                o, u, a, f;
            if (s && this.levelMap.length === 1) return e = [
                [100, 100]
            ], e;
            for (var l = 0, c = t.length - 1; l < c; l++) {
                a = n[t[l]], f = n[t[l + 1]];
                var h = f - a;
                r > a ? o = Math.round((r - a) / h * 100) : o = 0, i < f ? u = Math.round((i - a) / h * 100) : u = 100, e.push([o, u])
            }
            return e
        },
        _buildSSFrameSets: function(e, t, n) {
            var r = [],
                i = this.get("isLevelMax"),
                s = Math.round(e / n * 100),
                o = Math.round(t / n * 100);
            return r.push([s, o]), r
        },
        getTotalFrameCount: function() {
            var e = this.get("frameSets"),
                t = _.reduce(_.map(e, function(e) {
                    return e[1] - e[0]
                }), function(e, t) {
                    return e + t
                });
            return t
        },
        _getTotalSSFrameCount: function(e) {
            var t = _.reduce(_.map(e, function(e) {
                return e[1] - e[0]
            }), function(e, t) {
                return e + t
            });
            return t
        },
        getInitialFrame: function() {
            return this.get("frameSets")[0][0]
        },
        updateByProgressRatio: function(e) {
            var t = this.get("endExp") - this.get("startExp");
            this.set("prevExp", this.get("currentExp")), this.set("currentExp", this.get("startExp") + Math.round(t * e));
            var n = this.get("currentLevel"),
                r = this._calcCurrentLevel();
            n !== r && (this.set("currentLevel", r), this.trigger("levelUp", r)), this._calcExpToNextLevel(), this.set("currentFrame", this._calcCurrentFrame(e)), this.set("progressRatio", e)
        },
        updateByProgressSSRatio: function(e) {
            var t = this,
                n = this.get("soulStrikeExps");
            _.each(n, function(n) {
                n.currentFrame = t._calcSSCurrentFrame(e, n.frameSets, n.totalFrame);
                var r = +n.newExp - +n.previousExp;
                n.currentExp = +n.requiredExp - (+n.previousExp + Math.round(r * e))
            }), this.set("progressSSRatio", e)
        },
        _calcCurrentLevel: function() {
            var e = this.get("currentExp");
            for (var t = 0, n = this.levelMap.length; t < n; t++)
                if (e >= this.levelMap[t].threshold && e < this.levelMap[t].thresForNextLevel) return this.levelMap[t].level;
            if (e === _.last(this.levelMap).threshold) return _.last(this.levelMap).level;
            throw FF.logger.debug("level for exp doesnt exist. levelMap:", this.levelMap), new Error(sprintf("cant calc level."))
        },
        _calcExpToNextLevel: function() {
            var e = 0,
                t = this.get("levelToExp"),
                n = this.get("currentLevel") + 1;
            if (this.get("isLevelMax") && this.get("currentLevel") === this.get("endLevel")) {
                FF.logger.debug("max dayo"), this.set("expToNextLevel", 0);
                return
            }
            e = t[n] - this.get("currentExp"), this.set("expToNextLevel", e)
        },
        _calcCurrentFrame: function(e) {
            var t = this.get("frameSets"),
                n = this.get("totalFrameCount"),
                r = Math.round(n * e),
                i, s, o, u;
            for (var a = 0, f = t.length; a < f; a++) {
                s = t[a][0], o = t[a][1], u = o - s;
                if (!(r > u)) {
                    i = t[a][0] + r;
                    break
                }
                r -= u
            }
            return i
        },
        _calcSSCurrentFrame: function(e, t, n) {
            var r = Math.round(n * e),
                i, s, o, u;
            for (var a = 0, f = t.length; a < f; a++) {
                s = t[a][0], o = t[a][1], u = o - s;
                if (!(r > u)) {
                    i = t[a][0] + r;
                    break
                }
                r -= u
            }
            return i
        }
    });
    return t
}), define("scenes/battle_result/collections/BuddyExp", ["backbone", "../models/BuddyExp"], function(e, t) {
    var n = e.Collection.extend({
        model: t,
        updateByProgressRatio: function(e) {
            _.each(this.models, function(t) {
                t.updateByProgressRatio(e)
            }), this.trigger("update:progressRatio", e)
        },
        updateByProgressSSRatio: function(e) {
            _.each(this.models, function(t) {
                t.updateByProgressSSRatio(e)
            }), this.trigger("update:progressSSRatio", e)
        }
    });
    return n
}), define("scenes/battle_result/views/SoulStrikeLevelupModal", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ab/ABNodeButton", "lib/EventBase", "lib/TextMaster"], function(e, t, n, r, i, s, o) {
    var u = {
        TAG_OPEN: "play",
        TAG_OPEN_SPECIAL: "play_special",
        TAG_CLOSE: "close",
        LABEL_MESSAGE: "message_txt",
        LABEL_PARAM_BOOST_MESSAGE: "message_special_txt",
        LABEL_BUTTON_OK: "btn_txt",
        IMAGE_NODE: "ability_img",
        SPRITE_NODE: "chara_sprite"
    };
    return s.extend({
        initialize: function(e) {
            FF.logger.debug("SoulStrikeLevelupView: initialize");
            var t = this;
            this._lastTg = void 0, this.ab = {}, this.ab.topNode = e, this.ab.bgImgNode = new r({
                name: "bg_black_img",
                layer: this.ab.topNode.layer
            }), this.ab.centerNode = new r({
                name: "pos_center_nul",
                layer: this.ab.topNode.layer
            }), this.ab.posCenterAnmNode = e.createChildNode("pos_center_anm"), this.ab.messageSpecialNode = e.createChildNode("message_special"), this.ab.buttonNode = e.createChildNode("btn"), this.ab.buttonPosNode = e.createChildNode("btn_pos"), this.ab.bgAllWinNode = new r({
                name: "bg_all_win",
                layer: this.ab.topNode.layer
            }), this.ab.bgAllWinNode.play("init", {
                autoRemove: !1
            }).process(), this.ab.bgAllFrameWinNode = new r({
                name: "bg_all_frame_win",
                layer: this.ab.topNode.layer
            }), this.ab.bgAllFrameWinNode.play("init", {
                autoRemove: !1
            }).process(), this.button = (new i(e.createChildNode("btn"), e.name, "btnGroupName")).setButtonStateTags("btn_touch", void 0, void 0).setTouchHandler(function(e) {
                t.button.setEnabled(!1), t._closeDeferred().then(function() {
                    t._handleNextModal()
                })
            }).setEnabled(!0), this.button.setLabelWithDetail(o.getInstance().get("ok"), !0, u.LABEL_BUTTON_OK)
        },
        addModalData: function(e, t, n, r) {
            this._modalDataQueue === void 0 && (this._modalDataQueue = []), this._modalDataQueue.push({
                message: e,
                paramBoostMessage: t,
                spriteAssetInfo: n,
                abilityInfo: r
            })
        },
        showModalsDeferred: function() {
            return this._deferred = t.Deferred(), this._handleNextModal(), this._deferred.promise()
        },
        _handleNextModal: function() {
            if (!this._modalDataQueue || this._modalDataQueue.length === 0) this._deferred && (this._deferred.resolve(), this._deferred = void 0);
            else {
                var e = this._modalDataQueue.shift();
                this._showModal(e.message, e.paramBoostMessage, e.spriteAssetInfo, e.abilityInfo)
            }
        },
        _showModal: function(e, t, n, r) {
            var i = this;
            this.ab.topNode.setText(u.LABEL_MESSAGE, e);
            var s;
            t ? (s = u.TAG_OPEN_SPECIAL, this._initNodes("special_pos_01"), this.ab.messageSpecialNode.setVisible(!0), this.ab.topNode.setText(u.LABEL_PARAM_BOOST_MESSAGE, t)) : (s = u.TAG_OPEN, this._initNodes("init"), this.ab.messageSpecialNode.setVisible(!1)), this.ab.topNode.loadBundle(n.bundle).setSpriteAnimeByNode(u.SPRITE_NODE, n.assetPath), this.ab.topNode.loadBundle(r.bundle).setImage(u.IMAGE_NODE, r.assetPath), this._playTag(s, !0, function() {
                i.button.setEnabled(!0)
            }), this.button.setEnabled(!1)
        },
        _initNodes: function(e) {
            this.ab.centerNode.play(e, {
                autoRemove: !1
            }), this.ab.bgAllWinNode.play(e, {
                autoRemove: !1
            }), this.ab.bgAllFrameWinNode.play(e, {
                autoRemove: !1
            }), this.ab.buttonPosNode.play(e, {
                autoRemove: !1
            })
        },
        _closeDeferred: function() {
            var e = t.Deferred();
            return this._playTag(u.TAG_CLOSE, !0, function() {
                e.resolve()
            }), e.promise()
        },
        _playTag: function(e, t, n) {
            var r = this;
            if (this._lastTg === e) return;
            this._lastTg = e, this.ab.posCenterAnmNode.play(e).processDeferred("action_stop").then(function() {
                (e === u.TAG_OPEN || e === u.TAG_OPEN_SPECIAL) && r.ab.buttonNode.setVisible(!0).play("btn_open").process()
            }), this.ab.bgImgNode.play(e).processDeferred("action_stop").then(function() {
                FF.logger.debug("action stopped"), n && n()
            }), t && this._flush()
        },
        _flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            this.button && (this.button.dispose(), this.button = void 0)
        }
    })
}), define("scenes/battle_result/views/ResultExp", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/EventBase", "./ExpCell", "../collections/BuddyExp", "./AnimationPool", "./SoulStrikeLevelupModal", "lib/TextMaster"], function(e, t, n, r, i, s, o, u, a, f) {
    var l = {
        ANIMATION_POOL_FLUSH_INTERVAL: 30,
        MILLISECONDS_PER_TICK: 30,
        PROGRESS_PER_TICK: .03,
        SE: {
            COUNTUP: "se_battle_common_101054"
        }
    };
    return i.extend({
        initialize: function(t) {
            this.tutorialView = t.tutorialView, this.exp = t.exp, this.totalExp = t.totalExp, this.layer = t.layer, this.assetsManager = t.assetsManager, this.stageNode = new r({
                name: "stage_nul",
                layer: this.layer.layerName
            }), this.expTextNode = new r({
                name: "exp_get_txt_nul",
                layer: this.layer.layerName
            }), this.animationPool = new u({
                interval: l.ANIMATION_POOL_FLUSH_INTERVAL
            }), this.animationPool.nodes.push(this.expTextNode), this.animationPool.start(), this.buddyExpCollection = new o(this.exp), this.progressPerTicks = l.PROGRESS_PER_TICK, this.progressSSPerTicks = l.PROGRESS_PER_TICK, this.expCells = [];
            for (var i = 0, a = this.exp.length; i < a; i++) this.expCells[i] = new s({
                idx: i + 1,
                layer: this.layer,
                assetsManager: this.assetsManager,
                model: this.buddyExpCollection.findWhere({
                    buddyId: this.exp[i].buddyId
                }),
                animationPool: this.animationPool
            });
            this.expTextNode.setText("exp_get_txt", this.totalExp), n.Events.listenTo(this.buddyExpCollection, "update:progressRatio", e.bind(this.updateExpGetText, this)), this.soulStrikeLevelUpLayer = t.soulStrikeLevelUpLayer, this.soulStrikeLevelUpInfos = t.soulStrikeLevelUpInfos || []
        },
        start: function() {
            var n = this,
                r = [];
            e.each(this.expCells, function(e) {
                r.push(e.setupDeferred())
            }), t.when.apply(null, r).done(function() {
                setTimeout(function() {
                    n.startUpdatingGauges()
                }, 100)
            })
        },
        startUpdatingGauges: function() {
            var t = this,
                n = 0,
                r = 0,
                i = l.MILLISECONDS_PER_TICK;
            FF.SoundMgr.playEffect(l.SE.COUNTUP, {
                loop: !0
            }), this.progressTimer = setInterval(function() {
                t.buddyExpCollection.updateByProgressRatio(n), n += t.progressPerTicks, n >= 1 && (FF.SoundMgr.stopEffect(), t.buddyExpCollection.updateByProgressRatio(1), clearInterval(t.progressTimer), t.tutorialView.getTutorialFunc("battleExpMog")().then(function() {
                    e.each(t.expCells, function(e) {
                        e.suspendParticle()
                    }), t.isDone = !0, t.trigger("show:nextBtn")
                }))
            }, i)
        },
        drawSoulStrikeExp: function() {
            var n = this,
                r = 0,
                i = l.MILLISECONDS_PER_TICK,
                s = [];
            e.each(n.expCells, function(e) {
                s = s.concat(e.setSoulStrikeExpDeferredList())
            }), t.when.apply(t, s).then(function() {
                var r = [];
                return e.each(n.expCells, function(e) {
                    r.push(e.setSoulStrikeExpGaugeDeferred())
                }), t.when(r)
            }).then(function() {
                var t = e.some(n.expCells, function(e) {
                    return e.isSoulStrikeCountUp()
                });
                t ? FF.SoundMgr.playEffect(l.SE.COUNTUP, {
                    loop: !0
                }) : r = 1, n.isSSPhase = !0, n.progressSSTimer = setInterval(function() {
                    n.buddyExpCollection.updateByProgressSSRatio(r), r += n.progressSSPerTicks, r >= 1 && (FF.SoundMgr.stopEffect(), e.each(n.expCells, function(e) {
                        e.suspendSoulStrikeExpParticle()
                    }), n.buddyExpCollection.updateByProgressSSRatio(1), clearInterval(n.progressSSTimer), n.isSSDone = !0, n._showSoulStrikeLevelUpDeferred().then(function() {
                        n.trigger("show:nextBtn")
                    }))
                }, i)
            })
        },
        updateExpGetText: function(e) {
            var t = Math.round(this.totalExp * (1 - e));
            this.expTextNode.setText("exp_get_txt", t)
        },
        completeAtOnce: function() {
            FF.SoundMgr.stopEffect(), !this.isDone && !this.shouldCompleteAtOnce && (FF.SoundMgr.playChooseEffect(), this.progressPerTicks = 1, this.shouldCompleteAtOnce = !0), this.isSSPhase && !this.isSSDone && !this.shouldCompleteSSAtOnce && (this.progressSSPerTicks = 1, this.shouldCompleteSSAtOnce = !0)
        },
        _showSoulStrikeLevelUpDeferred: function() {
            function s(e) {
                var t = "buddy-" + e.path;
                return n.assetsManager.getAssetInfo(t)
            }

            function o(e) {
                var t = "soul_strike_" + e.soulStrikeId;
                return n.assetsManager.getAssetInfo(t)
            }

            function u(t) {
                if (e.keys(t.paramBooster).length === 0) return "";
                var n = f.getInstance().get("R10230") + "\n",
                    r = ["hp", "spd", "atk", "def", "matk", "mdef", "mnd", "acc", "eva"],
                    i = r.length;
                for (var s = 0; s <= i; s++) {
                    var o = r[s] + "Boost";
                    t.paramBooster[o] > 0 && (n += sprintf(f.getInstance().get("R10240"), f.getInstance().get("param_category_name_" + r[s]), t.paramBooster[o]))
                }
                return n
            }
            FF.logger.debug("ResultView: showSoulStrikeLvupDeferred");
            var n = this;
            if (this.soulStrikeLevelUpInfos.length === 0) return t.Deferred().resolve().promise();
            var r = this.soulStrikeLevelUpLayer.createNode("stage_nul"),
                i = new a(r);
            return e.each(this.soulStrikeLevelUpInfos, function(e) {
                var t = e.buddy.name,
                    n = e.soulStrike.soulStrikeName,
                    r = s(e.buddy),
                    a = o(e.soulStrike),
                    l = u(e.soulStrike),
                    c = f.getInstance().get("R10200");
                i.addModalData(sprintf(c, t, n), l, r, a)
            }), i.showModalsDeferred().then(function() {
                i.dispose()
            })
        },
        dispose: function() {
            n.Events.stopListening(this.buddyExpCollection, "update:progressRatio"), this.expTextNode.deleteNode().process(), e.each(this.expCells, function(e) {
                e.dispose()
            }), this.animationPool.dispose(), clearInterval(this.progressTimer), clearInterval(this.progressSSTimer), this.tutorialView = void 0, FF.SoundMgr.stopEffect()
        }
    })
}), define("scenes/battle_result/views/ResultItem", ["underscore", "jquery", "lib/ab/ABLayer", "backbone", "lib/ab/ABNode", "lib/EventBase", "lib/TextMaster"], function(e, t, n, r, i, s, o) {
    var u = {
        MAX_ROW: 9,
        RECORD_MATERIA_COND_TYPE: {
            SCORE: 4
        },
        RECORD_MATERIA_MODAL_ASSET_SIZE: 128
    };
    return s.extend({
        initialize: function(t) {
            this.tutorialView = t.tutorialView, this.layer = t.layer, this.assetsManager = t.assetsManager, this.buddy = t.buddy, this.dropItemIdToNum = t.dropItemIdToNum, this.dropRecordMateriaItemIdToNum = t.dropRecordMateriaItemIdToNum, this.scoreRecordMateriaItemIdToNum = t.scoreRecordMateriaItemIdToNum, this.itemCollection = t.itemCollection, this.centerFrontNode = t.centerFrontNode, this.centerFrontNewNode = t.centerFrontNewNode, this.playSpeedCoefficient = 1, this.serverConst = t.serverConst, this.dropItemList = this.itemCollection.makeItemList(this.dropRecordMateriaItemIdToNum), this.dropItemList = this.dropItemList.concat(this.itemCollection.makeItemList(this.scoreRecordMateriaItemIdToNum), this.itemCollection.makeItemList(this.dropItemIdToNum)), this.dropItemNum = e.min([u.MAX_ROW, this.dropItemList.length]), FF.logger.debug("ResultItem : ", this.dropItemList);
            if (this._hasRecordMateriaInList()) {
                var r = "materia_get",
                    i = this.assetsManager.getAssetInfo(r);
                this.materiaGetLayer = new n({
                    layerName: i.layerName,
                    assetPath: i.assetPath
                }), this.materiaGetLayer.activate()
            }
            this.itemNodes = []
        },
        start: function() {
            var e = this,
                t = this._makeItems();
            this._showListItemsDeferred(t).then(this.tutorialView.getTutorialFunc("battleItemMog")).then(function() {
                FF.logger.debug("ResultItem animation complete"), e.isDone = !0, e.trigger("show:nextBtn")
            })
        },
        _hasRecordMateriaInList: function() {
            for (var e = 0; e < this.dropItemNum; e++) {
                var t = this.dropItemList[e];
                if (t.isRecordMateria()) return 1
            }
            return 0
        },
        _makeItems: function() {
            var e = [];
            for (var t = 0; t < this.dropItemNum; t++) {
                var n = (new i({
                        name: "item_pos_nul_" + (t + 1),
                        layer: this.layer.layerName,
                        parentNodeName: "item_pos_nul_" + (t + 1),
                        duplicateFrom: "item_base_nul",
                        duplicateFromOptions: {
                            parentNode: "item_pos_nul_" + (t + 1)
                        }
                    })).process(),
                    r = this.dropItemList[t].getAssetIdOfTreasure(),
                    s = this.assetsManager.getAssetInfo(r);
                n.loadBundle(s.bundle).setSpriteAnimeByNode("sprite_treasure_symbol", s.assetPath).setSpriteActionByNode("sprite_treasure_symbol", "stop").process(), e.push({
                    node: n,
                    model: this.dropItemList[t]
                }), this.itemNodes.push(n)
            }
            return e
        },
        _showListItemsDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            if (e.length === 0) return r.resolve().promise();
            var i = function(t) {
                    t.then(function() {
                        if (e.length === 0) {
                            r.resolve();
                            return
                        }
                        var t = e.shift(),
                            s = n._showEachItemDeferred(t);
                        i(s)
                    })
                },
                s = e.shift(),
                o = this._showEachItemDeferred(s);
            return i(o), r.promise()
        },
        _showEachItemDeferred: function(e) {
            return e.model.needToDisplayModal(this.serverConst) ? this._showItemInListWithModalDeferred(e) : this._showItemInListDeferred(e)
        },
        _showItemInListDeferred: function(e) {
            var n = this,
                r = t.Deferred(),
                i = e.model.get("name"),
                s = e.model.getNameWithNum(),
                o = e.model.getAssetId(),
                u = this.assetsManager.getAssetInfo(o),
                a = e.model.getRewardListPlayTagName();
            return FF.logger.debug("ãƒªã‚¹ãƒˆã¸ã®ã‚¢ã‚¤ãƒ†ãƒ è¡¨ç¤º", i, "playTag", a), e.node.setSpriteActionByNode("sprite_treasure_symbol", "open").setText("icon_item_txt", s).loadBundle(u.bundle).setImage("image_icon_item", u.assetPath).play(a, {
                speed: n.playSpeedCoefficient
            }), this.shouldCompleteAtOnce ? r.resolve() : e.node.addCallbackOnce("action_stop", function() {
                r.resolve()
            }), e.node.process(), r.promise()
        },
        _showItemInListWithModalDeferred: function(e) {
            var n = this,
                r = t.Deferred(),
                s = e.model,
                o = s.getAssetId(),
                u = this.assetsManager.getAssetInfo(o),
                a = s.getRewardModalCloseButtonNodeName(),
                f = s.isRecordMateria() ? n.materiaGetLayer : n.layer.layerName,
                l = new i({
                    name: a,
                    layer: f
                });
            return s.isRecordMateria() ? n._showRecordMateriaModalDeffered(l, e).then(function() {
                r.resolve()
            }) : n._showNormalModalDeffered(l, e, u).then(function() {
                r.resolve()
            }), r.promise()
        },
        _showNormalModalDeffered: function(e, n, r) {
            var i = this,
                s = t.Deferred(),
                u = n.model,
                a = this.assetsManager.getAssetInfo(u.getAssetIdOfTreasure());
            return this.centerFrontNode.loadBundle(a.bundle).setSpriteAnimeByNode("sprite_treasure_symbol_front", a.assetPath).setSpriteActionByNode("sprite_treasure_symbol_front", "stop").setVisible(!0).setText(u.getModalTextTagName(), sprintf(o.getInstance().get("R10040"), u.get("name"))).loadBundle(r.bundle).setImage(u.getModalImageTagName(), r.assetPath).play(u.getRewardModalPlayTagName()).processDeferred("action_stop").then(function() {
                return e.processDeferred("action_touch_ended")
            }).then(function() {
                return i.centerFrontNode.play(u.getModalCloseTagName()).processDeferred("action_stop")
            }).then(function() {
                return i.centerFrontNode.setVisible(!1).process(), i._showItemInListDeferred(n)
            }).then(function() {
                s.resolve()
            }), s.promise()
        },
        _showRecordMateriaModalDeffered: function(e, n) {
            var r = this,
                i = t.Deferred();
            return this._prepareRecordMateriaModal(n), this.materiaGetNode.play("in").processDeferred("action_stop").then(function() {
                r.materiaGetNode.play("loop").process()
            }).then(function() {
                return e.processDeferred("action_touch_ended")
            }).then(function() {
                return r.materiaGetNode.play("tap_end").processDeferred("action_stop")
            }).then(function() {
                return r.materiaGetNode.setVisible(!1).process(), r._showItemInListDeferred(n)
            }).then(function() {
                i.resolve()
            }), i.promise()
        },
        _getRecordMateriaCutinBodyText: function(e) {
            var t = this._isCondTypeScore(e) ? o.getInstance().get("R10140") + "\n" : "";
            return t + sprintf(o.getInstance().get("R10040"), e.model.get("name"))
        },
        _prepareRecordMateriaModal: function(t) {
            var n = this,
                r = t.model.getAssetId(u.RECORD_MATERIA_MODAL_ASSET_SIZE),
                i = this.assetsManager.getAssetInfo(r),
                s = this._getRecorcMateriaModalPlayTag(t);
            this.materiaGetLayer.createNode("cutin_bg_nul").play(s, {
                autoRemove: !1
            }).process();
            var o = this._getRecordMateriaCutinBodyText(t),
                a = e.findWhere(this.buddy, {
                    buddyId: t.model.get("buddyId")
                }),
                f = sprintf("buddy-%s", a.path),
                l = this.assetsManager.getAssetInfo(f);
            this.materiaGetNode = this.materiaGetLayer.createNode("cutin_nul"), this.materiaGetNode.setVisualParent("layer_battle_result", "cutin_pos_nul").setText("cutin_body_txt", o).loadBundle(i.bundle).setImage("materia_img", i.assetPath).setImage("materia_img_add", i.assetPath).loadBundle(l.bundle).setSpriteAnimeByNode("chara_sprite", l.assetPath).setVisible(!0);
            var c = t.model.get("condDescription");
            c = c.replace(/<br>/g, "\n"), this._isCondTypeScore(t) && n.materiaGetNode.setText("notice_txt", c)
        },
        _getRecorcMateriaModalPlayTag: function(e) {
            return this._isCondTypeScore(e) ? "scale_window_2" : "scale_window_1"
        },
        _isCondTypeScore: function(e) {
            var t = parseInt(e.model.get("condType"));
            return t === u.RECORD_MATERIA_COND_TYPE.SCORE ? !0 : !1
        },
        completeAtOnce: function() {
            !this.isDone && !this.shouldCompleteAtOnce && (FF.SoundMgr.playChooseEffect(), this.playSpeedCoefficient = 100, this.shouldCompleteAtOnce = !0)
        },
        dispose: function() {
            this.dropItemIdToNum = null, this.itemCollection = null;
            var t = function(t) {
                e.each(t, function(e) {
                    e && (e.removeAllCallback(), e.deleteNode().process())
                })
            };
            e(this.itemNodes).each(function(e) {
                e.suspendParticle().setVisible(!1).process()
            }), this.centerFrontNode.createChildNode("reward_front_nul").suspendParticle().process(), this.centerFrontNode.setVisible(!1).process(), t(this.itemNodes), this.tutorialView = void 0
        }
    })
}), define("scenes/battle_result/views/ResultDungeon", ["underscore", "jquery", "backbone", "lib/ab/ABLayer", "lib/ab/ABNode", "lib/EventBase", "lib/GooglePlayGameService", "sprintf", "lib/ab/ScrollableTextNode", "lib/TextMaster"], function(e, t, n, r, i, s, o, u, a, f) {
    var l = {
        BONUS: {
            FIRST: {
                TYPE: "first",
                MAX_ROW: 2
            },
            CLEAR: {
                TYPE: "clear",
                MAX_ROW: 1
            },
            MASTER: {
                TYPE: "master",
                MAX_ROW: 2
            }
        },
        UNLOCK_FLD_WIDTH: 260,
        UNLOCK_FLD_HEIGHT: 135,
        UNLOCK_FLD_MARGIN: 8,
        DURATION_PER_PX: .015,
        STAMINA_PIECE_NUM_FOR_GAIN_STAMINA: 5,
        RANK_NUM_EXCELLENT: 3
    };
    return s.extend({
        initialize: function(e) {
            this.tutorialView = e.tutorialView, this.rank = e.result.dungeonRank, this.googlePlayAchievements = e.result.googlePlayAchievements, this.assetsManager = e.assetsManager, this.centerFrontNode = e.centerFrontNode, this.itemCollection = e.itemCollection, this.firstClearPrizeItemIdToNum = e.result.firstClearPrizeItemIdToNum, this.clearPrizeItemIdToNum = e.result.clearPrizeItemIdToNum, this.firstMasterPrizeItemIdToNum = e.result.firstMasterPrizeItemIdToNum, this.isFirstClearMaster = e.result.isFirstClearMaster, this.unlockDungeons = e.result.unlockDungeons, this.unlockWorlds = e.result.unlockWorlds, this.staminaInfo = e.result.staminaInfo, this.layer = e.layer, this.playSpeedCoefficient = 1, this.serverConst = e.serverConst, this.firstClearPrizeList = this.itemCollection.makeItemList(this.firstClearPrizeItemIdToNum), this.clearPrizeList = this.itemCollection.makeItemList(this.clearPrizeItemIdToNum), this.firstMasterPrizeList = this.itemCollection.makeItemList(this.firstMasterPrizeItemIdToNum), FF.logger.debug("firstClearPrizeList", this.firstClearPrizeList), FF.logger.debug("clearPrizeList", this.clearPrizeList), FF.logger.debug("firstMasterPrizeList", this.firstMasterPrizeList), this.masterBackEffNode = new i({
                name: "master_back_eff_nul",
                layer: this.layer.layerName
            }), this.duplicateNodes = [], this.duplicateModalNewNode(), this.switchMasterWindow()
        },
        switchMasterWindow: function() {
            this.rewardMasterNode = new i({
                name: "reward_master_nul",
                layer: this.layer.layerName
            }), !this.isFirstClearMaster || this.firstMasterPrizeList.length === 0 ? this.rewardMasterNode.setVisible(!1).process() : this.rewardMasterNode.setVisible(!0).process()
        },
        start: function() {
            var t = this;
            FF.logger.debug("ãƒãƒ§ã‚³ãƒœè¡¨ç¤º");
            var n = this._makeUnlockPlaces();
            this.showSymbolDeferred().then(function() {
                return FF.logger.debug("ãƒžã‚¹ã‚¿ãƒ¼ã®æ¼”å‡ºè¡¨ç¤ºï¼ˆãƒžã‚¹ã‚¿ãƒ¼æ™‚ã®ã¿ï¼‰"), t.playMasterDeferred()
            }).then(function() {
                return FF.logger.debug("ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚¢ãƒ³ãƒ­ãƒƒã‚¯"), o.sendAchievement(t.googlePlayAchievements), FF.env.isWWRegion() && e.each(t.googlePlayAchievements, function(e) {
                    kickmotor.iosgamecenter.unlockAchievement(e.achievementId)
                }), t.showDungeonDeferred(n)
            }).then(function() {
                return FF.logger.debug("ã‚¯ãƒªã‚¢ãƒœãƒ¼ãƒŠã‚¹è¡¨ç¤º"), t.showClearBonusDeferred()
            }).then(function() {
                return FF.logger.debug("ãƒžã‚¹ã‚¿ãƒ¼ãƒœãƒ¼ãƒŠã‚¹è¡¨ç¤º"), t.showMasterBonusDeferred()
            }).then(function() {
                return FF.logger.debug("åˆå›žã‚¯ãƒªã‚¢ãƒœãƒ¼ãƒŠã‚¹è¡¨ç¤º"), t.showFirstBonusDeferred()
            }).then(function() {
                return FF.logger.debug("ã‚¹ã‚¿ãƒŸãƒŠã®ã‹ã‘ã‚‰ãã‚ã£ãŸè¡¨ç¤º"), t.showStaminaPieceDeferred()
            }).then(this.tutorialView.getTutorialFunc("battleDungeonMog")).then(function() {
                FF.logger.debug("ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³çµæžœã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†"), t.isDone = !0, t.trigger("show:nextBtn")
            })
        },
        getDungeonTypeName: function(e) {
            return e.isForce ? f.getInstance().get("R10080") + " " : ""
        },
        getDungeonUnlockText: function(e) {
            return f.getInstance().get("R10070")
        },
        _makeUnlockPlaces: function() {
            var t = this,
                n = this.unlockDungeons || [],
                r = this.unlockWorlds || [];
            if (n.length + r.length === 0) return [];
            var i = e.map(n, function(e) {
                return u(t.getDungeonUnlockText(e), e.worldName, t.getDungeonTypeName(e), e.name)
            });
            return i
        },
        showSymbolDeferred: function() {
            var e = t.Deferred(),
                n = new i({
                    name: "symbol_nul",
                    layer: this.layer.layerName
                });
            return this.rank === 0 ? e.resolve().promise() : (n.setVisible(!0).addCallbackOnce("action_stop", function() {
                e.resolve()
            }).play("symbol_start_" + this.rank, {
                speed: this.playSpeedCoefficient
            }).process(), e.promise())
        },
        playMasterDeferred: function() {
            return t.when(this._playMasterBackEffDeferred(), this._playDungeonClearTitleDeferred())
        },
        _playMasterBackEffDeferred: function() {
            var e = this,
                n = t.Deferred();
            return this.rank === l.RANK_NUM_EXCELLENT ? this.masterBackEffNode.play("master", {
                speed: this.playSpeedCoefficient
            }).processDeferred("action_stop").then(function() {
                n.resolve()
            }) : n.resolve(), n.promise()
        },
        _playDungeonClearTitleDeferred: function() {
            var e = t.Deferred();
            return (new i({
                name: "dungeon_clear_title_nul",
                layer: this.layer.layerName
            })).play("master").processDeferred("action_stop").then(function() {
                e.resolve()
            }), e.promise()
        },
        showFirstBonusDeferred: function() {
            var e = t.Deferred(),
                n = this.makeBonusItems(l.BONUS.FIRST, this.firstClearPrizeList);
            return this.showListDeferred(n, this.showEachItemDeferred).then(function() {
                e.resolve()
            }), e.promise()
        },
        showClearBonusDeferred: function() {
            var e = t.Deferred(),
                n = this.makeBonusItems(l.BONUS.CLEAR, this.clearPrizeList);
            return this.showListDeferred(n, this.showEachItemDeferred).then(function() {
                e.resolve()
            }), e.promise()
        },
        showMasterBonusDeferred: function() {
            var e = t.Deferred(),
                n = this.makeBonusItems(l.BONUS.MASTER, this.firstMasterPrizeList);
            return this.showListDeferred(n, this.showEachItemDeferred).then(function() {
                e.resolve()
            }), e.promise()
        },
        showStaminaPieceDeferred: function() {
            var n = this,
                r = t.Deferred(),
                s = "stamina_piece",
                o = this.assetsManager.getAssetInfo(s);
            if (e.isEmpty(this.staminaInfo) || !this.staminaInfo.additionalStamina) return r.resolve().promise();
            var a = u(f.getInstance().get("R10090"), l.STAMINA_PIECE_NUM_FOR_GAIN_STAMINA),
                c = u(f.getInstance().get("R10100"), this.staminaInfo.additionalStamina, this.staminaInfo.prevMaxStamina, this.staminaInfo.currentMaxStamina),
                h = new i({
                    name: "get_piece_close_btn_nul",
                    layer: n.layer.layerName
                });
            return this.tutorialView.isTutorial() && h.setVisible(!1).process(), this.isShowingModal = !0, this.centerFrontNode.setVisible(!0).setText("get_piece_title_txt", a).setText("get_piece_body_txt", c).loadBundle(o.bundle).setImage("image_get_piece", o.assetPath).play("get_piece", {
                speed: this.playSpeedCoefficient
            }).processDeferred("action_stop").then(this.tutorialView.getTutorialFunc("battleStaminaMog")).then(function() {
                return n.tutorialView.isTutorial() && h.setVisible(!0).process(), t.Deferred().resolve().promise()
            }).then(function() {
                return h.processDeferred("action_touch_ended")
            }).then(function() {
                return n.centerFrontNode.play("close_window").processDeferred("action_stop")
            }).then(function() {
                n.isShowingModal = !1, n.centerFrontNode.setVisible(!1).process(), r.resolve()
            }), r.promise()
        },
        makeBonusItems: function(t, n) {
            var r = [],
                s = e.min([t.MAX_ROW, n.length]);
            for (var o = 0; o < s; o++) {
                var a = (new i({
                    name: u("reward_%s_item_pos_nul_%s", t.TYPE, o + 1),
                    layer: this.layer.layerName,
                    parentNodeName: u("reward_%s_item_pos_nul_%s", t.TYPE, o + 1),
                    duplicateFrom: "item_base_nul",
                    duplicateFromOptions: {
                        parentNode: u("reward_%s_item_pos_nul_%s", t.TYPE, o + 1)
                    }
                })).process();
                r.push({
                    node: a,
                    model: n[o]
                }), this.duplicateNodes.push(a)
            }
            return r
        },
        showEachItemDeferred: function(e) {
            return e.model.needToDisplayModalInDungeonReward(this.serverConst) ? this.showItemInListWithModalDeferred(e) : this.showItemInListDeferred(e)
        },
        showItemInListDeferred: function(e) {
            var n = t.Deferred(),
                r = e.model.get("name"),
                i = e.model.getNameWithNum(),
                s = e.model.getAssetId(),
                o = this.assetsManager.getAssetInfo(s),
                u = e.model.getDungeonRewardListPlayTagName();
            return FF.logger.debug("ãƒªã‚¹ãƒˆã¸ã®ã‚¢ã‚¤ãƒ†ãƒ è¡¨ç¤º", r, "playTag", u), e.node.setVisible(!0).setText("icon_item_txt", i).loadBundle(o.bundle).setImage("image_icon_item", o.assetPath).play(u, {
                speed: this.playSpeedCoefficient
            }), this.shouldCompleteAtOnce ? n.resolve() : e.node.addCallbackOnce("action_stop", function() {
                n.resolve()
            }), e.node.process(), n.promise()
        },
        showItemInListWithModalDeferred: function(e) {
            var n = this,
                r = t.Deferred(),
                s = e.model,
                o = s.getAssetId(),
                u = this.assetsManager.getAssetInfo(o),
                a = this.getModalLayerName(s),
                f = new i({
                    name: s.getDungeonModalCloseButtonNodeName(),
                    layer: a
                });
            return FF.logger.debug("Modal è¡¨ç¤º", name), this.tutorialView.isTutorial() && f.setVisible(!1).process(), this.isShowingModal = !0, s.isMemoryCrystalToGrowEgg() ? n._showMemoryCrystalToGrowEggModalDeffered(f, e, u).then(function() {
                r.resolve()
            }) : s.isMemoryCrystal() ? n._showMemoryCrystalModalDeffered(f, e, u).then(function() {
                r.resolve()
            }) : s.isBuddyToGrowEgg() || s.isDressRecordToGrowEgg() ? n._showBuddyToGrowEggModalDeffered(f, e, u).then(function() {
                r.resolve()
            }) : n._showNormalModalDeffered(f, e, u).then(function() {
                r.resolve()
            }), r.promise()
        },
        _showMemoryCrystalModalDeffered: function(e, n, r) {
            var i = this,
                s = t.Deferred(),
                o = u("memory-crystal-buddy-%s", n.model.get("itemId")),
                a = this.assetsManager.getAssetInfo(o),
                l = u("memory-crystal-battle-result-modal-%s", n.model.get("itemId")),
                c = this.assetsManager.getAssetInfo(l),
                h = u(f.getInstance().get("R10040"), n.model.get("name")) + "\n" + u(f.getInstance().get("R10150"), n.model.get("buddyName"));
            return i.memoryCrystalGetNode = i.memoryCrystalGetLayer.createNode("cutin_nul"), i.memoryCrystalGetNode.setVisualParent("layer_battle_result", "cutin_pos_nul").setText("cutin_body_txt", h).loadBundle(a.bundle).setSpriteAnimeByNode("chara_sprite", a.assetPath).loadBundle(c.bundle).setImage("crystal_img", c.assetPath).setVisible(!0).play("in").processDeferred("action_stop").then(function() {
                i.memoryCrystalGetNode.play("loop").process()
            }).then(function() {
                return e.processDeferred("action_touch_ended")
            }).then(function() {
                return i.memoryCrystalGetNode.play("tap_end").processDeferred("action_stop")
            }).then(function() {
                return i.memoryCrystalGetNode.setVisible(!1).process(), i.showItemInListDeferred(n)
            }).then(function() {
                s.resolve()
            }), this._applyMemoryCrystalEffect(n), s.promise()
        },
        _applyMemoryCrystalEffect: function(e) {
            var t = "crystal_get",
                n = this.assetsManager.getAssetInfo(t),
                r = +e.model.get("rank");
            (new i({
                name: u("eff_cutin_particle_%02d", r),
                layer: n.layerName
            })).setVisible(!0).process(), (new i({
                name: u("crystal_star_particle_%02d", r),
                layer: n.layerName
            })).setVisible(!0).process()
        },
        _showBuddyToGrowEggModalDeffered: function(e, n, r) {
            var i = this,
                s = t.Deferred(),
                o = u("animation-buddy-%s", n.model.get("itemId")),
                a = this.assetsManager.getAssetInfo(o),
                l = n.model.getRemapItemModel(),
                c = u("item-%s", l.get("itemId")),
                h = this.assetsManager.getAssetInfo(c),
                p = "";
            return n.model.isBuddy() ? p = f.getInstance().get("R10210") : n.model.isDressRecord() && (p = f.getInstance().get("R10260")), i.buddyToGrowEggGetNode = i.buddyToGrowEggGetLayer.createNode("cutin_nul"), i.buddyToGrowEggGetNode.setVisualParent("layer_battle_result", "cutin_pos_nul").setText("cutin_body_txt", p).loadBundle(a.bundle).setSpriteAnimeByNode("chara_sprite", a.assetPath).loadBundle(h.bundle).setImage("grow_egg_img", h.assetPath).setVisible(!0).play("in").processDeferred("action_stop").then(function() {
                return i.buddyToGrowEggGetNode.play("loop").process(), e.processDeferred("action_touch_ended")
            }).then(function() {
                return i.buddyToGrowEggGetNode.play("tap_end").processDeferred("action_stop")
            }).then(function() {
                i.buddyToGrowEggGetNode.setVisible(!1).process();
                var e = l.clone();
                return e.num = n.model.num, i.showItemInListDeferred({
                    node: n.node,
                    model: e
                })
            }).then(function() {
                s.resolve()
            }), s.promise()
        },
        _showMemoryCrystalToGrowEggModalDeffered: function(e, n, r) {
            var i = this,
                s = t.Deferred(),
                o = u("memory-crystal-battle-result-modal-%s", n.model.get("itemId")),
                a = this.assetsManager.getAssetInfo(o),
                l = n.model.getRemapItemModel(),
                c = u("item-%s", l.get("itemId")),
                h = this.assetsManager.getAssetInfo(c);
            return i.memoryCrystalToGrowEggGetNode = i.memoryCrystalToGrowEggGetLayer.createNode("cutin_nul"), i.memoryCrystalToGrowEggGetNode.setVisualParent("layer_battle_result", "cutin_pos_nul").setText("cutin_body_txt", f.getInstance().get("R10220")).loadBundle(a.bundle).setImage("crystal_img_01", a.assetPath).loadBundle(h.bundle).setImage("grow_egg_img", h.assetPath).setVisible(!0).play("in").processDeferred("action_stop").then(function() {
                return i.memoryCrystalToGrowEggGetNode.play("loop").process(), e.processDeferred("action_touch_ended")
            }).then(function() {
                return i.memoryCrystalToGrowEggGetNode.play("tap_end").processDeferred("action_stop")
            }).then(function() {
                i.memoryCrystalToGrowEggGetNode.setVisible(!1).process();
                var e = l.clone();
                return e.num = n.model.num, i.showItemInListDeferred({
                    node: n.node,
                    model: e
                })
            }).then(function() {
                s.resolve()
            }), s.promise()
        },
        _showNormalModalDeffered: function(e, n, r) {
            var i = this,
                s = t.Deferred(),
                o = n.model,
                u = this.assetsManager.getAssetInfo(o.getAssetIdOfTreasure());
            return this.centerFrontNode.loadBundle(u.bundle).setSpriteAnimeByNode("sprite_treasure_symbol_front", u.assetPath).setSpriteActionByNode("sprite_treasure_symbol_front", "stop").setVisible(!0).setText(o.getModalTextTagName(), o.getDungeonRewardText()).setText(o.getModalHeaderTextTagName(), o.getModalHeaderText()).loadBundle(r.bundle).setImage(o.getModalImageTagName(), r.assetPath).play(o.getDungeonRewardModalPlayTagName(), {
                speed: this.playSpeedCoefficient
            }).processDeferred("action_stop").then(function() {
                return o.isMythril() ? i.tutorialView.getTutorialFunc("battleMythrilMog")() : t.Deferred().resolve().promise()
            }).then(function() {
                return i.tutorialView.isTutorial() && e.setVisible(!0).process(), t.Deferred().resolve().promise()
            }).then(function() {
                return e.processDeferred("action_touch_ended")
            }).then(function() {
                return i.centerFrontNode.play(o.getModalCloseTagName()).processDeferred("action_stop")
            }).then(function() {
                return i.isShowingModal = !1, i.centerFrontNode.setVisible(!1).process(), i.showItemInListDeferred(n)
            }).then(function() {
                s.resolve()
            }), s.promise()
        },
        showDungeonDeferred: function(n) {
            var r = this,
                s = t.Deferred(),
                o;
            n = n || [];
            if (!n.length) return s.resolve().promise();
            var u = new a({
                name: "unlock_txt",
                layer: this.layer.layerName
            });
            this.rewardFrontNode = new i({
                name: "reward_front_nul",
                layer: this.layer.layerName
            }), this.rewardFrontNode.suspendParticle().process();
            var c = t.Deferred(),
                h = n.join("\n"),
                p = function() {
                    var e = t.Deferred();
                    return u.setVisible(!0).setText(h, {
                        callback: function(t) {
                            FF.logger.debug("whole text size", t), o = t.height, u.addTouchRect([0, 0, l.UNLOCK_FLD_WIDTH, o]).addCallbackOnce("action_touch_began", d).process(), e.resolve()
                        }
                    }).process(), e.promise()
                },
                d = function() {
                    c.reject();
                    var e = o > l.UNLOCK_FLD_HEIGHT - l.UNLOCK_FLD_MARGIN ? !0 : !1;
                    u.setDragEnable([0, -(o / 2) + l.UNLOCK_FLD_MARGIN * 3, 0, o / 2 - l.UNLOCK_FLD_MARGIN * 3], e, {
                        dragMargin: [0, 0, 0, 0]
                    }).process()
                },
                v = function() {
                    if (o > l.UNLOCK_FLD_HEIGHT - l.UNLOCK_FLD_MARGIN) {
                        var e = l.UNLOCK_FLD_HEIGHT - l.UNLOCK_FLD_MARGIN - o;
                        u.scrollDeferred({
                            x: 0,
                            y: e,
                            duration: Math.abs(e * l.DURATION_PER_PX)
                        }).then(function() {
                            FF.logger.debug("scroll done"), c.resolve()
                        })
                    } else c.resolve()
                };
            return c.progress(e.bind(v, this)), this.isShowingModal = !0, this.centerFrontNode.setVisible(!0).play("get_dungeon", {
                speed: this.playSpeedCoefficient
            }).addCallbackOnce("action_stop", function() {
                (new i({
                    name: "unlock_title_txt",
                    layer: r.layer.layerName
                })).setText("unlock_title_txt", f.getInstance().get("R10110")).process();
                var e = new i({
                    name: "close_btn_nul",
                    layer: r.layer.layerName
                });
                r.registerDialogOnBackKey(e, s), e.addCallback("action_touch_began", function() {
                    r.didTouchBeganCloseButton = !0
                }).addCallback("action_touch_ended", function() {
                    r.didTouchBeganCloseButton ? (r.unregisterDialogOnBackKey(), e.removeAllCallback().process(), r.centerFrontNode.removeAllCallback().play("close_window").addCallbackOnce("action_stop", function() {
                        r.isShowingModal = !1, r.centerFrontNode.setVisible(!1).process(), s.resolve()
                    }).process()) : r.didTouchBeganCloseButton = !1
                }).addCallback("action_touch_exited", function() {
                    r.didTouchBeganCloseButton = !1
                }).process(), p().then(function() {
                    return c.notify()
                })
            }).process(), s.promise()
        },
        showListDeferred: function(e, n) {
            var r = this,
                i = t.Deferred();
            if (e.length === 0) return i.resolve().promise();
            var s = function(t) {
                    t.then(function() {
                        if (e.length === 0) {
                            i.resolve();
                            return
                        }
                        var t = e.shift(),
                            o = n.call(r, t);
                        s(o)
                    })
                },
                o = e.shift(),
                u = n.call(this, o);
            return s(u), i.promise()
        },
        duplicateModalNewNode: function() {
            var e = (new i({
                name: "pos_center_front_chara_new_nul",
                layer: this.layer.layerName,
                parentNodeName: "new_chara_get_pos_nul",
                duplicateFrom: "new_nul",
                duplicateFromOptions: {
                    parentNode: "new_chara_get_pos_nul"
                }
            })).process();
            e.play("new_loop", {
                speed: this.playSpeedCoefficient
            }).setVisible(!0).process(), this.duplicateNodes.push(e);
            var t = (new i({
                name: "pos_center_front_dungeon_new_nul",
                layer: this.layer.layerName,
                parentNodeName: "new_unlock_pos_nul",
                duplicateFrom: "new_nul",
                duplicateFromOptions: {
                    parentNode: "new_unlock_pos_nul"
                }
            })).process();
            t.play("new_loop", {
                speed: this.playSpeedCoefficient
            }).setVisible(!0).process(), this.duplicateNodes.push(t)
        },
        completeAtOnce: function() {
            !this.isDone && !this.shouldCompleteAtOnce && !this.isShowingModal && (FF.SoundMgr.playChooseEffect(), this.shouldCompleteAtOnce = !0, this.playSpeedCoefficient = 100)
        },
        getModalLayerName: function(e) {
            if (e.isMemoryCrystalToGrowEgg()) {
                if (this.memoryCrystalToGrowEggGetLayer) return this.memoryCrystalToGrowEggGetLayer;
                var t = "crystal_growegg",
                    n = this.assetsManager.getAssetInfo(t);
                return this.memoryCrystalToGrowEggGetLayer = new r({
                    layerName: n.layerName,
                    assetPath: n.assetPath
                }), this.memoryCrystalToGrowEggGetLayer.activate(), this.memoryCrystalToGrowEggGetLayer
            }
            if (e.isMemoryCrystal()) {
                if (this.memoryCrystalGetLayer) return this.memoryCrystalGetLayer;
                var i = "crystal_get",
                    s = this.assetsManager.getAssetInfo(i);
                return this.memoryCrystalGetLayer = new r({
                    layerName: s.layerName,
                    assetPath: s.assetPath
                }), this.memoryCrystalGetLayer.activate(), this.memoryCrystalGetLayer
            }
            if (e.isBuddyToGrowEgg() || e.isDressRecordToGrowEgg) {
                if (this.buddyToGrowEggGetLayer) return this.buddyToGrowEggGetLayer;
                var o = "chara_growegg",
                    u = this.assetsManager.getAssetInfo(o);
                return this.buddyToGrowEggGetLayer = new r({
                    layerName: u.layerName,
                    assetPath: u.assetPath
                }), this.buddyToGrowEggGetLayer.activate(), this.buddyToGrowEggGetLayer
            }
            return this.layer.layerName
        },
        registerDialogOnBackKey: function(e, t) {
            if (FF.env.isWWRegion()) {
                var n = this;
                kickmotor.nativefn.onBackKeyHandler.once("System::onBackKey", function() {
                    n.unregisterDialogOnBackKey(), e.removeAllCallback().process(), n.centerFrontNode.removeAllCallback().play("close_window").addCallbackOnce("action_stop", function() {
                        n.isShowingModal = !1, n.centerFrontNode.setVisible(!1).process(), t.resolve()
                    }).process()
                }, n)
            }
        },
        unregisterDialogOnBackKey: function() {
            FF.env.isWWRegion() && kickmotor.nativefn.onBackKeyHandler.off("System::onBackKey", null, this)
        },
        dispose: function() {
            var t = function(t) {
                e.each(t, function(e) {
                    e && (e.removeAllCallback(), e.deleteNode().process())
                })
            };
            t(this.duplicateNodes), this.tutorialView = void 0
        }
    })
}), define("scenes/battle_result/models/Tutorial", ["backbone"], function(e) {
    var t = e.Model.extend({
        initialize: function(e) {
            this.talks = e
        },
        isTutorial: function() {
            return FF.env.isTutorial()
        },
        getMessage: function(e) {
            var t = _.findWhere(this.talks, {
                no: e
            });
            return t.content ? t.content : ""
        }
    });
    return t
}), define("scenes/battle_result/views/TutorialActionHelper", [], function() {
    var e = {
        firstMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "101"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2091"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "102"
                }), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleScoreMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "103"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2092"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2093"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2094"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "104"
                }), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleExpMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2095"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleItemMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2097"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleDungeonMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "203"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2101"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "205"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2102"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "206"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2103"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e.nodeMap.tutor.setPosition([0, -180]).process(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "207"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2104"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "208"
                }), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleMythrilMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2098"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2099"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleStaminaMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2100"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        }
    };
    return e
}), define("scenes/battle_result/views/ResultTutorial", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/EventBase", "../models/Tutorial", "./TutorialActionHelper", "util"], function(e, t, n, r, i, s, o, u) {
    return i.extend({
        initialize: function(e) {
            this.assetsManager = e, this.nodeMap = {}
        },
        prepareForTutorial: function() {
            var e = FF.battleResult.result.tutorial_talks;
            this.model = new s(e);
            if (!this.isTutorial()) return;
            var t = "tut_res_1",
                n = this.assetsManager.getAssetInfo(t);
            this.nodeMap.indicator = (new r({
                name: "tutorial_nul",
                layer: n.layerName,
                visualParentTo: "tutorial_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: "layer_battle_field"
                }
            })).play("reset");
            var i = "tut_res_msg_1",
                o = this.assetsManager.getAssetInfo(i);
            this.nodeMap.tutor = (new r({
                name: "tutorial_msg_nul",
                layer: o.layerName,
                visualParentTo: "tutorial_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: "layer_battle_field"
                }
            })).play("reset"), this.flush()
        },
        releaseFromWaiting: function() {
            this.promiseWaitingForTouch && (this.promiseWaitingForTouch.resolve(), this.promiseWaitingForTouch = void 0)
        },
        _playTutorDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            if (e.action === "OUT") this.playTutorDeferred({
                action: e.action
            }).then(function() {
                r.resolve()
            });
            else {
                var i = e.autoResolve ? function() {
                    r.resolve()
                } : function() {
                    n.promiseWaitingForTouch = r
                };
                this.playTutorDeferred({
                    action: e.action,
                    messageId: e.messageId
                }).then(i)
            }
            return r.promise()
        },
        _playIndicatorDeferred: function(e) {
            var n = t.Deferred();
            return this.playIndicatorDeferred(e).then(function() {
                n.resolve()
            }), n.promise()
        },
        playTutorDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            if (!e) return r.resolve().promise();
            var i = void 0;
            e.messageId && (i = this.model.getMessage(e.messageId));
            switch (e.action) {
                case "IN":
                    i && this.nodeMap.tutor.setText("main_txt", i), this.nodeMap.tutor.play("in").processDeferred("action_stop").then(function() {
                        n.nodeMap.tutor.play("loop"), n.flush(), r.resolve()
                    });
                    break;
                case "SAY":
                    i && this.nodeMap.tutor.setText("main_txt", i), this.nodeMap.tutor.play("tap").processDeferred("action_stop").then(function() {
                        n.nodeMap.tutor.play("loop"), n.flush(), r.resolve()
                    }), this.flush();
                    break;
                case "OUT":
                    this.nodeMap.tutor.play("out").processDeferred("action_stop").then(function() {
                        r.resolve()
                    });
                    break;
                case "RESET":
                    this.nodeMap.tutor.play("reset").processDeferred("action_stop").then(function() {
                        r.resolve()
                    });
                    break;
                default:
                    throw new Error("invalid acion. " + e.action)
            }
            return r.promise()
        },
        playIndicatorDeferred: function(e) {
            var n = t.Deferred();
            if (!e) return n.resolve().promise();
            switch (e.action) {
                case "PLAY":
                    this._playByFrameNoDeferred(e.frameNo).then(function() {
                        n.resolve()
                    });
                    break;
                case "RESET":
                    this.nodeMap.indicator.play("reset").processDeferred("action_stop").then(function() {
                        n.resolve()
                    });
                    break;
                default:
                    throw new Error("invalid acion. " + e.action)
            }
            return n.promise()
        },
        _playByFrameNoDeferred: function(e) {
            var n = this,
                r = t.Deferred(),
                i = sprintf("play_%s", e),
                s = sprintf("loop_%s", e);
            return this.nodeMap.indicator.play(i).processDeferred("action_stop").then(function() {
                n.nodeMap.indicator.play(s), n.flush(), r.resolve()
            }), this.flush(), r.promise()
        },
        setVisible: function(e) {
            this.nodeMap.tutor.setVisible(e), this.nodeMap.indicator.setVisible(e), this.flush()
        },
        flush: function() {
            var t = [];
            e.each(this.nodeMap, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        isTutorial: function() {
            return this.model.isTutorial()
        },
        getTutorialFunc: function(n) {
            var r = this,
                i;
            return this.isTutorial() ? i = o[n] : i = function() {
                return t.Deferred().resolve().promise()
            }, e.bind(i, this)
        },
        dispose: function() {
            var t = function(t) {
                e.each(t, function(e) {
                    e && (e.removeAllCallback(), e.deleteNode().process())
                })
            };
            t(this.nodeMap)
        }
    })
}), define("scenes/battle_result/views/PrizeBuddyModal", ["underscore", "jquery", "lib/ab/ABLayer", "backbone", "lib/ab/ABNode", "lib/EventBase", "lib/TextMaster"], function(e, t, n, r, i, s, o) {
    var u = ["acc", "atk", "def", "eva", "hp", "matk", "mdef", "mnd", "spd"];
    return s.extend({
        initialize: function(e) {
            this.prizeBuddyInfoList = e.prizeBuddyInfoList, this.layer = e.layer, this.assetsManager = e.assetsManager, this.ab = {}, this.ab.topNode = this.layer.createNode("visible_nul"), this.ab.cutInNode = this.ab.topNode.createChildNode("cutin_nul"), this.ab.cutInFrameNode = this.ab.topNode.createChildNode("cutin_frame_nul"), this.ab.charaNameNode = this.ab.topNode.createChildNode("chara_name_nul"), this.ab.btnNode = this.ab.topNode.createChildNode("btn_cutin_01"), this._createStatusNode()
        },
        _createStatusNode: function() {
            var t = this;
            this._statusNodes = {}, e.each(u, function(e) {
                t._statusNodes[e] = new i({
                    name: sprintf("%s_pos_nul", e),
                    layer: t.ab.topNode.layer,
                    duplicateFrom: "status_point_nul",
                    duplicateFromOptions: {
                        parentNode: sprintf("%s_pos_nul", e)
                    }
                })
            })
        },
        showModalsDeferred: function() {
            var e = this;
            return this._handleNextModal(), this._deferred = t.Deferred(), this._deferred.promise()
        },
        _handleNextModal: function() {
            if (!this.prizeBuddyInfoList || this.prizeBuddyInfoList.length === 0) this._deferred && (this.dispose(), this._deferred.resolve(), this._deferred = void 0);
            else {
                var e = this.prizeBuddyInfoList.shift();
                this._showModal(e)
            }
        },
        _showModal: function(t) {
            var n = this;
            this._setUpCharacter(t), this._setUpSoulStrike(t), this.ab.topNode.setVisible(!0).process(), this.ab.cutInNode.play("in").addCallbackOnce("action_point", function() {
                e.each(n._statusNodes, function(e, n) {
                    e.play(sprintf("status_point_%s", t.starNum[n]), {
                        autoRemove: !1
                    }).process()
                })
            }).addCallbackOnce("action_stop", function() {
                n.ab.cutInNode.play("loop").process(), n._setUpBtn()
            }).addCallbackOnce("action_chara_change", function() {
                n.ab.topNode.setSpriteActionByNode("chara_sprite", t.prizeImage).process()
            }), this.flush()
        },
        _setUpCharacter: function(e) {
            this.ab.cutInFrameNode.setText("job_txt", e.roleTypeName), this.ab.charaNameNode.setText("chara_name_txt", e.name);
            var t = "animation-buddy-" + e.id,
                n = this.assetsManager.getAssetInfo(t);
            this.ab.topNode.loadBundle(n.bundle).setSpriteAnimeByNode("chara_sprite", n.assetPath)
        },
        _setUpSoulStrike: function(e) {
            this.ab.cutInFrameNode.setText("special_name_txt", e.soulStrike.name), this.ab.cutInFrameNode.setText("special_description_txt", e.soulStrike.description);
            var t = "soul_strike_" + e.id,
                n = this.assetsManager.getAssetInfo(t);
            this.ab.topNode.loadBundle(n.bundle).setImage("special_orb_img", n.assetPath);
            var r = +e.soulStrike.consumeSsGauge;
            switch (r) {
                case 1:
                    this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_01"
                    });
                    break;
                case 2:
                    this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_01"
                    }), this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_02"
                    });
                    break;
                case 3:
                    this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_01"
                    }), this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_02"
                    }), this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_03"
                    });
                    break;
                default:
            }
        },
        _setUpBtn: function() {
            var e = this;
            this.ab.btnNode.addCallbackOnce("action_touch_began", function() {
                e.ab.cutInNode.play("tap_start").process()
            }, {
                node: "btn_cutin_visible_touch_01"
            }).addCallbackOnce("action_touch_ended", function() {
                e.ab.cutInNode.play("tap_end").processDeferred("action_stop").then(function() {
                    e.ab.cutInNode.play("out").addCallbackOnce("action_stop", function() {
                        e._handleNextModal()
                    }).process()
                })
            }, {
                node: "btn_cutin_visible_touch_01"
            }).process()
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            this.ab.topNode.setVisible(!1).process(), this.ab.btnNode.deleteNode().process(), e.each(this._statusNodes, function(e) {
                e.deleteNode().process()
            }), this.layer = null
        }
    })
}), define("scenes/battle_result/views/SpecialItemModal", ["underscore", "jquery", "lib/ab/ABLayer", "backbone", "lib/ab/ABNode", "lib/EventBase"], function(e, t, n, r, i, s) {
    return s.extend({
        initialize: function(e) {
            this.itemInfoList = e.specialItemInfoList, this.layer = e.layer, this.assetsManager = e.assetsManager, this.ab = {}, this.ab.topNode = this.layer.createNode("visible_nul"), this.ab.cutInNode = this.ab.topNode.createChildNode("cutin_nul"), this.ab.rewardFrontNode = this.ab.topNode.createChildNode("reward_front_nul"), this.ab.itemNameNode = this.ab.topNode.createChildNode("item_name_nul"), this.ab.btnNode = this.ab.topNode.createChildNode("btn_cutin_01")
        },
        showModalsDeferred: function() {
            var e = this,
                n = t.Deferred();
            if (this.itemInfoList.length === 0) return n.resolve().promise();
            var r = function(t) {
                    t.then(function() {
                        if (e.itemInfoList.length === 0) {
                            e.dispose(), n.resolve();
                            return
                        }
                        var t = e.itemInfoList.shift(),
                            i = e._showModalDeferred(t);
                        r(i)
                    })
                },
                i = this.itemInfoList.shift(),
                s = this._showModalDeferred(i);
            return r(s), n.promise()
        },
        _showModalDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            return this._setUpItem(e), this.ab.topNode.setVisible(!0), this.ab.cutInNode.play("in").addCallbackOnce("action_stop", function() {
                n.ab.cutInNode.play("loop"), n._setUpBtnDeferred().then(function() {
                    r.resolve()
                })
            }), this.flush(), r.promise()
        },
        _setUpItem: function(e) {
            var t = sprintf("item-%s", e.get("itemId")),
                n = this.assetsManager.getAssetInfo(t);
            this.ab.rewardFrontNode.loadBundle(n.bundle).setImage("image_reward_front ", n.assetPath).setVisible(!0), this.ab.rewardFrontNode.setText("cutin_frame_txt ", e.get("description")), this.ab.itemNameNode.setText("item_name_txt", e.get("name"))
        },
        _setUpBtnDeferred: function() {
            var e = this,
                n = t.Deferred();
            return this.ab.btnNode.addCallbackOnce("action_touch_began", function() {
                e.ab.cutInNode.play("tap_start").process()
            }, {
                node: "btn_cutin_visible_touch_01"
            }).addCallbackOnce("action_touch_ended", function() {
                e.ab.cutInNode.play("tap_end").processDeferred("action_stop").then(function() {
                    e.ab.cutInNode.play("out").addCallbackOnce("action_stop", function() {
                        n.resolve()
                    }).process()
                })
            }, {
                node: "btn_cutin_visible_touch_01"
            }).process(), n.promise()
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            this.ab.topNode.setVisible(!1).process(), this.ab.btnNode.deleteNode().process(), this.layer = null
        }
    })
}), define("scenes/battle_result/models/Item", ["backbone", "sprintf", "lib/TextMaster"], function(e, t, n) {
    var r = {
            THRESHOLD_RARITY: 4,
            TYPE_OF_TYPE_NAME: {
                EQUIPMENT: "box",
                ABILITY: "box",
                ABILITY_MATERIAL: "orb",
                GROW_EGG: "box",
                EQUIPMENT_SP_MATERIAL: "box",
                COMMON: "box",
                BUDDY: "box",
                RECORD_MATERIA: "box",
                MEMORY_CRYSTAL: "box",
                DRESS_RECORD: "box"
            },
            ITEM_ID_FOR_MYTHRIL: 91e6,
            ITEM_ID_FOR_GIL: 92e6
        },
        i = e.Model.extend({
            idAttribute: "itemId",
            initialize: function(t) {
                e.Model.prototype.initialize.apply(t)
            },
            isEquip: function() {
                return this.get("typeName") === "EQUIPMENT"
            },
            isBuddy: function() {
                return this.get("typeName") === "BUDDY"
            },
            isCommon: function() {
                return this.get("typeName") === "COMMON"
            },
            isMythril: function() {
                return this.get("itemId") === r.ITEM_ID_FOR_MYTHRIL
            },
            isRecordMateria: function() {
                return this.get("typeName") === "RECORD_MATERIA"
            },
            isMemoryCrystal: function() {
                return this.get("typeName") === "MEMORY_CRYSTAL"
            },
            isAbility: function() {
                return this.get("typeName") === "ABILITY"
            },
            isAbilityMaterial: function() {
                return this.get("typeName") === "ABILITY_MATERIAL"
            },
            isNew: function() {
                return this.get("isNew") ? !0 : !1
            },
            isRemapped: function() {
                return this.get("remapItemId") ? !0 : !1
            },
            isBuddyToGrowEgg: function() {
                return this.isBuddy() && this.isRemapped()
            },
            isMemoryCrystalToGrowEgg: function() {
                return this.isMemoryCrystal() && this.isRemapped()
            },
            isDressRecordToGrowEgg: function() {
                return this.isDressRecord() && this.isRemapped()
            },
            isGrowEgg: function() {
                return this.get("typeName") === "GROW_EGG"
            },
            isDressRecord: function() {
                return this.get("typeName") === "DRESS_RECORD"
            },
            isEquipmentSpMaterial: function() {
                return this.get("typeName") === "EQUIPMENT_SP_MATERIAL"
            },
            needToDisplayModal: function(e) {
                return this.isRecordMateria() ? !0 : this._shouldShowModal(e) ? !0 : !1
            },
            needToDisplayModalInDungeonReward: function(e) {
                return this.isBuddyToGrowEgg() ? !0 : this._isNoRarityItem() ? !0 : this.isMemoryCrystal() ? !0 : this.isDressRecord() ? !0 : this.isBuddyToGrowEgg() ? !0 : this._shouldShowModal(e) ? !0 : !1
            },
            _shouldShowModal: function(e) {
                var t = _.any([this.isEquip(), this.isAbilityMaterial() && +this.get("type") !== +e.ABILITY_MATERIAL.TYPE_OF.MEMORY, this.isAbility(), this.isGrowEgg(), this.isEquipmentSpMaterial()]);
                return t && this._getRarity() >= r.THRESHOLD_RARITY
            },
            getRewardListPlayTagName: function() {
                var e = r.TYPE_OF_TYPE_NAME[this.get("typeName")];
                FF.logger.debug(e, this.get("typeName"), this.attributes);
                if (!e) throw new Error("invalid type");
                return t("reward_open_%s_%s", e, this._getRarity())
            },
            getRewardModalPlayTagName: function() {
                var e = r.TYPE_OF_TYPE_NAME[this.get("typeName")],
                    n = this._getRarity();
                if (!e) throw new Error("invalid type");
                if (n < 3) throw new Error("invalid rarity:" + n);
                return t("reward_open_%s_%s", e, n)
            },
            getRewardModalCloseButtonNodeName: function() {
                return this.isRecordMateria() ? "cutin_bt_nul_01" : "reward_front_close_btn_nul"
            },
            getDungeonRewardModalPlayTagName: function() {
                if (this.isDressRecord()) return "get_chara";
                if (this._isNoRarityItem()) return "get_system";
                var e = r.TYPE_OF_TYPE_NAME[this.get("typeName")];
                if (!e) throw new Error("invalid type");
                var n;
                return this._getRarity() > r.THRESHOLD_RARITY ? n = this._getRarity() : n = r.THRESHOLD_RARITY, t("reward_open_%s_%s", e, n)
            },
            getDungeonRewardListPlayTagName: function() {
                var e = r.TYPE_OF_TYPE_NAME[this.get("typeName")];
                FF.logger.debug(e, this.get("typeName"), this.attributes);
                if (!e) throw new Error("invalid type:" + this.get("typeName"));
                return t("reward_open_%s_%s", e, 1)
            },
            getDungeonModalCloseButtonNodeName: function() {
                return this.isMemoryCrystal() || this.isBuddyToGrowEgg() || this.isMemoryCrystalToGrowEgg() || this.isDressRecordToGrowEgg() ? "cutin_bt_nul_01" : this.isDressRecord() || this._isNoRarityItem() ? "close_btn_nul" : "reward_front_close_btn_nul"
            },
            getDungeonRewardText: function() {
                return this.isDressRecord() ? t(n.getInstance().get("R10250"), this.get("name")) : t(n.getInstance().get("R10040"), this.get("name"))
            },
            getModalTextTagName: function() {
                return this.isDressRecord() ? "chara_get_txt" : this._isNoRarityItem() ? "system_body_txt" : "reward_front_txt"
            },
            getModalHeaderTextTagName: function() {
                return this._isNoRarityItem() ? "system_title_txt" : "reward_front_title_txt"
            },
            getModalHeaderText: function() {
                if (this.isDressRecord()) return "";
                var e = this._getHeaderTextId();
                return n.getInstance().get(e)
            },
            getModalImageTagName: function() {
                return this.isDressRecord() ? "image_get_chara" : this._isNoRarityItem() ? "system_image" : "image_reward_front"
            },
            getModalCloseTagName: function() {
                return this.isDressRecord() || this._isNoRarityItem() ? "close_window" : "reward_close"
            },
            getAssetId: function(e) {
                return e ? t("item-%s-%s", e, this.get("itemId")) : t("item-%s", this.get("itemId"))
            },
            getAssetIdOfTreasure: function() {
                return t("treasure%s_%s", r.TYPE_OF_TYPE_NAME[this.get("typeName")], this.get("rarity"))
            },
            getNameWithNum: function() {
                var e = this.get("name");
                if (this.isDressRecord()) return e;
                if (this.get("itemId") === r.ITEM_ID_FOR_GIL) {
                    var i = FF.env.isWWRegion() ? " " : "";
                    return t("%s%s%s", this.num, i, n.getInstance().get("R10050"))
                }
                return t("%s x %s", e, this.num)
            },
            _getRarity: function() {
                return this.isCommon() ? 1 : this.get("rarity")
            },
            getRemapItemModel: function() {
                if (!this.isRemapped()) throw new Error("not defined remap_item_id");
                return this.collection.get(+this.get("remapItemId"))
            },
            _isNoRarityItem: function() {
                return this.isMythril() ? !0 : !1
            },
            _getHeaderTextId: function() {
                return this.isMythril() ? "R10010" : "R10020"
            }
        });
    return i
}), define("scenes/battle_result/collections/Item", ["backbone", "../models/Item", "util"], function(e, t, n) {
    var r = e.Collection.extend({
        model: t,
        makeItemList: function(e) {
            var t = this,
                r = [];
            return _.each(e, function(e, i) {
                var s = n.cloneDeep(t.get(i));
                s.num = e, r.push(s)
            }), r.sort(function(e, t) {
                return e.get("itemId") < t.get("itemId") ? -1 : 1
            }), r
        }
    });
    return r
}), define("scenes/battle_result/ResultViewController", ["underscore", "jquery", "backbone", "sprintf", "lib/ab/ABLayer", "lib/ab/ABNode", "lib/ab/AssetsManager", "lib/EventBase", "lib/api", "components/Loading", "components/Overlay", "./views/ResultScore", "./views/ResultExp", "./views/ResultItem", "./views/ResultDungeon", "./views/ResultTutorial", "./views/PrizeBuddyModal", "./views/SpecialItemModal", "./collections/Item", "util"], function(e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b) {
    var w = {
        NEXT_ACTIONS: ["drawExpResult", "drawSoulStrikeExp", "drawItemResult", "drawDungeonResult", "goOutToExternalUrl"],
        WAIT_UNTIL_NEXT_BTN_DISPLAYED: 300
    };
    return FF.ns.battle.ResultViewController = u.extend({
        initialize: function(n, r) {
            FF.logger.debug("ResultView: initialize", n), this.result = n, this.serverConst = r, this.isFirstClear = n.isFirstClear, this.firstClearPrizeNum = b.sum(e.values(n.firstClearPrizeItemIdToNum)), this.nextActions = e.clone(w.NEXT_ACTIONS), this.overlay = new l({
                el: t(".overlay")
            }), this.loading = new f({
                el: t(".loading")
            }), this.overlay.registerChildren(this.loading), kickmotor.nativefn.call("setIsEnableTouchEvent", {
                isEnable: !0
            }), this.assetsManager = new o, this.resultLayer = null, this.itemCollection = new y(e.map(e.values(n.prizeMaster), function(e) {
                return e.itemId = +e.itemId, e
            })), this.soulStrikeLevelUpInfos = this._createSoulStrikeLevelUpInfos()
        },
        willShowSoulStrikeLevelup: function() {
            return this.soulStrikeLevelUpInfos.length > 0
        },
        loadViewDeferred: function() {
            FF.logger.debug("ResultView: loadView");
            var e = this,
                n = t.Deferred();
            return this.loadAssetsDeferred().then(function() {
                e.loadLayer(), e.loadExtraLayer(), e.loading.hide(), e._drawModalBeforeBattleResultsDeferred().then(function() {
                    e.createTutorialView(), e.drawView(), e.makeNextActionsQueue(), e.drawScoreResult(), n.resolve()
                })
            }).fail(function() {
                n.reject()
            }), n.promise()
        },
        loadAssetsDeferred: function() {
            FF.logger.debug("ResultView: loadAssetsDeferred");
            var e = t.Deferred();
            return this.assetsManager.populateAssetsDeferred(FF.battleResult.assets).then(function() {
                e.resolve()
            }).fail(function() {
                e.reject()
            }), e.promise()
        },
        loadLayer: function() {
            FF.logger.debug("ResultView: loadLayer");
            var e = "battle_result",
                t = this.assetsManager.getAssetInfo(e);
            this.battleResultLayer = new i({
                layerName: t.layerName,
                assetPath: t.assetPath
            }), this.battleResultLayer.activate()
        },
        loadExtraLayer: function() {
            this.willShowSoulStrikeLevelup() && this.loadLayerForSoulStrikeLevelup(), this._hasPrizeBuddy() && this.loadLayerForPrizeBuddy(), this._hasSpecialPrizeItem() && this.loadLayerForSpecialItem()
        },
        loadLayerForSoulStrikeLevelup: function() {
            FF.logger.debug("ResultView: loadLayerForSoulStrikeLevelup");
            var e = this,
                t = "soul_strike_lvup",
                n = this.assetsManager.getAssetInfo(t);
            this.soulStrikeLevelUpLayer = new i({
                layerName: n.layerName,
                assetPath: n.assetPath
            }), this.soulStrikeLevelUpLayer.activate()
        },
        loadLayerForPrizeBuddy: function() {
            var e = "chara_get",
                t = this.assetsManager.getAssetInfo(e);
            this.charaGetLayer = new i({
                layerName: t.layerName,
                assetPath: t.assetPath
            }), this.charaGetLayer.activate()
        },
        loadLayerForSpecialItem: function() {
            var e = "item_get",
                t = this.assetsManager.getAssetInfo(e);
            this.specialItemGetLayer = new i({
                layerName: t.layerName,
                assetPath: t.assetPath
            }), this.specialItemGetLayer.activate()
        },
        createTutorialView: function() {
            this.tutorialView = new v(this.assetsManager), this.tutorialView.prepareForTutorial()
        },
        drawView: function() {
            this.stageNode = new s({
                name: "stage_nul",
                layer: this.battleResultLayer.layerName
            }), this.nextBtnNode = new s({
                name: "next_btn_nul",
                layer: this.battleResultLayer.layerName
            }), this.nextBtnNode.setVisible(!1).process(), this.centerFrontNode = (new s({
                name: "pos_center_front_nul",
                layer: this.battleResultLayer.layerName
            })).setVisible(!1).process(), this.centerFrontNewNode = (new s({
                name: "pos_center_front_new_nul",
                layer: this.battleResultLayer.layerName,
                parentNodeName: "new_reward_front_pos_nul",
                duplicateFrom: "new_nul",
                duplicateFromOptions: {
                    parentNode: "new_reward_front_pos_nul"
                }
            })).setVisible(!1).process(), this.centerFrontNewNode.play("new_loop").setVisible(!1).process(), this.stageNode.addCallback("action_touch_began", e.bind(function() {
                this.tutorialView.promiseWaitingForTouch ? this.tutorialView.releaseFromWaiting() : this.currentPageView.completeAtOnce()
            }, this)).process(), FF.env.isUsingWWBackKeyHandler() && FF.env.isTutorial() && this.setupTutorialOnBackKey()
        },
        changeCurrentPage: function(e) {
            this.currentPageView && this.stopListening(this.currentPageView), this.currentPageView = e, this.listenTo(this.currentPageView, "show:nextBtn", this.showNextBtn)
        },
        showNextBtn: function() {
            this.nextBtnNode.setVisible(!0).process(), this._nextBtnDrawn = !0;
            var t = setTimeout(e.bind(function() {
                this.nextBtnNode.addCallbackOnce("action_touch_began", e.bind(function() {
                    this.nextBtnNode.play("tap_start").process()
                }, this)).addCallbackOnce("action_touch_ended", e.bind(function() {
                    FF.SoundMgr.playChooseEffect(), this.nextBtnNode.play("tap_end").processDeferred("action_stop").then(e.bind(function() {
                        this.nextBtnNode.setVisible(!1).process(), this.drawNextPage()
                    }, this))
                }, this)).process(), clearTimeout(t), this._bindBackKeyToNextBtn()
            }, this), w.WAIT_UNTIL_NEXT_BTN_DISPLAYED)
        },
        drawNextPage: function() {
            this._nextBtnDrawn = !1;
            var e = this.nextActionsQueue.shift();
            e()
        },
        _bindBackKeyToNextBtn: function() {
            FF.env.isUsingWWBackKeyHandler() && this.listenTo(kickmotor.nativefn.onBackKeyHandler, "System::onBackKey", e.bind(function() {
                if (!this._nextBtnDrawn) return;
                this._nextBtnDrawn = !1, this.nextBtnNode.play("tap_end").processDeferred("action_stop").then(e.bind(function() {
                    this.nextBtnNode.setVisible(!1).process(), this.drawNextPage()
                }, this))
            }, this))
        },
        makeNextActionsQueue: function() {
            this.nextActionsQueue = this.nextActions, this.result.isDungeonClear || (this.nextActionsQueue = e.reject(this.nextActionsQueue, function(e) {
                return e === "drawDungeonResult"
            })), this._hasBattleDropPrize() || (this.nextActionsQueue = e.reject(this.nextActionsQueue, function(e) {
                return e === "drawItemResult"
            }));
            if (!this._hasSoulStrikeExp() || !this._hasUnmasteredSoulStrike()) this.nextActionsQueue = e.reject(this.nextActionsQueue, function(e) {
                return e === "drawSoulStrikeExp"
            });
            this.nextActionsQueue = e(this.nextActionsQueue).map(function(t) {
                return e.bind(this[t], this)
            }, this)
        },
        _hasBattleDropPrize: function() {
            return e.keys(this.result.dropItemIdToNum).length || e.keys(this.result.dropRecordMateriaItemIdToNum).length || e.keys(this.result.scoreRecordMateriaItemIdToNum).length ? !0 : !1
        },
        _hasSoulStrikeExp: function() {
            return e.some(this.result.buddy, function(e) {
                return e.soulStrikeExps.length > 0
            })
        },
        setupTutorialOnBackKey: function() {
            this.listenTo(kickmotor.nativefn.onBackKeyHandler, "System::onBackKey", e.bind(function() {
                this.tutorialView.promiseWaitingForTouch ? this.tutorialView.releaseFromWaiting() : this.currentPageView.completeAtOnce()
            }, this))
        },
        _hasUnmasteredSoulStrike: function() {
            return e.some(this.result.buddy, function(t) {
                return e.some(t.soulStrikeExps, function(e) {
                    return !e.isAlreadyMastered
                })
            })
        },
        _hasPrizeBuddy: function() {
            return this.result.prizeBuddyInfoList.length === 0 ? !1 : e.some(this.result.prizeBuddyInfoList, function(e) {
                return e.remapItemId === null
            })
        },
        _hasSpecialPrizeItem: function() {
            return this.itemCollection.length === 0 ? !1 : this._getSpecialPrizeItemList().length > 0
        },
        _getSpecialPrizeItemList: function() {
            var e = this.serverConst.ABILITY_MATERIAL.TYPE_OF.MEMORY;
            return this.itemCollection.filter(function(t) {
                return t.isAbilityMaterial() ? e === +t.get("type") : !1
            })
        },
        goOutToExternalUrl: function() {
            this.stageNode.removeAllCallback(), this.nextBtnNode.removeAllCallback(), this.tutorialView.dispose(), this.assetsManager.destroyAllLayer(), this.stopListening(), FF.redirect(this.result.url)
        },
        drawPrizeBuddyModalDeferredIfNeedDeferred: function() {
            return this._hasPrizeBuddy() ? (this.prizeBuddyModal = new m({
                layer: this.charaGetLayer,
                assetsManager: this.assetsManager,
                prizeBuddyInfoList: this.result.prizeBuddyInfoList
            }), this.prizeBuddyModal.showModalsDeferred()) : t.Deferred().resolve().promise()
        },
        drawSpecialItemModalDeferredIfNeedDeferred: function() {
            return this._hasSpecialPrizeItem() ? (this.specialItemModal = new g({
                layer: this.specialItemGetLayer,
                assetsManager: this.assetsManager,
                specialItemInfoList: this._getSpecialPrizeItemList()
            }), this.specialItemModal.showModalsDeferred()) : t.Deferred().resolve().promise()
        },
        drawScoreResult: function() {
            FF.logger.debug("ResultView: drawScoreResult");
            var e = this,
                t = this.result.score.specific && this.result.score.specific.length ? "special_score_start" : "score_start";
            FF.battleResult.isMock ? ((new s({
                name: "visible_stage_nul",
                layer: this.battleResultLayer.layerName
            })).setVisible(!0).process(), FF.ns.battle.Conf = {
                STATUS_AILMENTS_TYPE: {
                    PETRIFACTION: 212
                }
            }) : this.stageNode.setVisualParent("layer_battle_field", "sys_pos_nul").process(), this.stageNode.setVisible(!0).play(t).process(), this.resultScoreView = new c({
                layer: this.battleResultLayer,
                result: this.result,
                tutorialView: this.tutorialView
            }), this.changeCurrentPage(this.resultScoreView), this.resultScoreView.start()
        },
        drawExpResult: function() {
            FF.logger.debug("ResultView: drawExpResult"), this.resultScoreView && this.resultScoreView.dispose(), this.stageNode.play("exp_start").process(), this.resultExpView = new h({
                layer: this.battleResultLayer,
                exp: this.result.buddy,
                totalExp: this.result.totalDevidedExp,
                assetsManager: this.assetsManager,
                tutorialView: this.tutorialView,
                soulStrikeLevelUpLayer: this.soulStrikeLevelUpLayer,
                soulStrikeLevelUpInfos: this.soulStrikeLevelUpInfos
            }), this.changeCurrentPage(this.resultExpView), this.resultExpView.start()
        },
        drawSoulStrikeExp: function() {
            FF.logger.debug("ResultView: drawSoulStrikeExpResult"), this.resultExpView.drawSoulStrikeExp()
        },
        _createSoulStrikeLevelUpInfos: function() {
            var t = [];
            return e.each(this.result.buddy, function(n) {
                var r = e.sortBy(n.soulStrikeExps, function(e) {
                    return +e.equipmentId
                });
                e.each(r, function(e) {
                    if (e.isLevelUp) {
                        var r = {};
                        r.buddy = n, r.soulStrike = e, t.push(r)
                    }
                })
            }), t
        },
        _drawModalBeforeBattleResultsDeferred: function() {
            var e = t.Deferred(),
                n = this;
            return this.drawPrizeBuddyModalDeferredIfNeedDeferred().then(this.drawSpecialItemModalDeferredIfNeedDeferred.bind(this)).then(function() {
                e.resolve()
            }), e.promise()
        },
        drawItemResult: function() {
            FF.logger.debug("ResultView: drawItemResult"), this.resultExpView && (this.resultExpView.dispose(), this.resultExpView = null), this.stageNode.play("reward_start").process(), this.resultItemView = new p({
                layer: this.battleResultLayer,
                buddy: this.result.buddy,
                dropItemIdToNum: this.result.dropItemIdToNum,
                dropRecordMateriaItemIdToNum: this.result.dropRecordMateriaItemIdToNum,
                scoreRecordMateriaItemIdToNum: this.result.scoreRecordMateriaItemIdToNum,
                itemCollection: this.itemCollection,
                assetsManager: this.assetsManager,
                centerFrontNode: this.centerFrontNode,
                centerFrontNewNode: this.centerFrontNewNode,
                tutorialView: this.tutorialView,
                serverConst: this.serverConst
            }), this.changeCurrentPage(this.resultItemView), this.resultItemView.start()
        },
        resultDungeonViewClass: d,
        drawDungeonResult: function() {
            var e = this.isFirstClear && this.firstClearPrizeNum ? "clear_start_first" : "clear_start";
            FF.logger.debug("ResultView: drawDungeonResult"), this.resultExpView && (this.resultExpView.dispose(), this.resultExpView = null), this.resultItemView && this.resultItemView.dispose(), this.stageNode.play(e).process(), this.resultDungeonView = new this.resultDungeonViewClass({
                layer: this.battleResultLayer,
                result: this.result,
                serverConst: this.serverConst,
                itemCollection: this.itemCollection,
                assetsManager: this.assetsManager,
                centerFrontNode: this.centerFrontNode,
                tutorialView: this.tutorialView
            }), this.changeCurrentPage(this.resultDungeonView), this.resultDungeonView.start()
        }
    }), FF.ns.battle.ResultViewController
}), define("scenes/battle_result/BattleResultScene", ["underscore", "jquery", "backbone", "scenes/common/Config", "scenes/common/helper/FirstDungeonClearFlag", "scenes/progress_map/LatestProgressData", "./ResultViewController", "lib/Scene", "lib/Ticker", "lib/Storage", "util", "lib/api"], function(e, t, n, r, i, s, o, u, a, f, l, c) {
    var h = FF.ns.battle;
    return u.extend({
        initialize: function() {
            FF.logger.debug("FF.battleResult", FF.battleResult), FF.battleResult || FF.redirect("/dff/"), FF.battleResult.isMock || h.ExternalFunc.openLoading();
            var e = FF.battleResult.result;
            this.result = e || {}, this.battleLayers = FF.battleResult.battleLayers || [], this.result = l.camelizeDeep(e), this.result.url = FF.battleResult.url, this.serverConst = JSON.parse(t("[data-app-constants-data]").html()), a.start()
        },
        setupDeferred: function() {
            var e = this,
                n = t.Deferred();
            return s.getCanReturnDeferred().then(function(t) {
                t.canReturn || n.resolve(), e._setDungeonClearDataDeferred().then(e._saveIsFirstClearDeferred.bind(e)).then(function() {
                    n.resolve()
                })
            }), n.promise()
        },
        _setDungeonClearDataDeferred: function() {
            var e = t.Deferred();
            if (this.result.isFirstClear || this.result.isFirstMaster) {
                var n = "LATEST_UNLOCK_DUNGEONS",
                    r = {
                        isFirstClear: this.result.isFirstClear,
                        isFirstMaster: this.result.isFirstClearMaster,
                        clearDungeonId: this.result.dungeonId,
                        clearDungeonRank: this.result.dungeonRank,
                        unlockDungeons: this.result.unlockDungeons
                    };
                f.setItemDeferred(n, JSON.stringify(r)).then(function(t) {
                    e.resolve()
                })
            } else e.resolve();
            return e.promise()
        },
        _saveIsFirstClearDeferred: function() {
            return i.saveDeferred(this.result.isFirstClear)
        },
        start: function() {
            var e = this;
            kickmotor.googleanalytics.sendScreenName(r.googleAnalytics.DIRECT_CALL_SCREEN_NAME_OF.BattleAnimationResult);
            var n = this.getErrorHandler();
            this._setupErrorHandler();
            var i = void 0;
            t.Deferred().resolve().promise().then(n.bindTryCatchDeferred(function() {
                i = "4122";
                var t = h.BattleViewController.getInstance();
                return t.dispose(), e.viewController = new h.ResultViewController(e.result, e.serverConst), FF.logger.debug("loadView"), e.viewController.loadViewDeferred()
            })).then(n.bindTryCatchDeferred(function() {
                i = "4135", FF.battleResult.isMock || h.ExternalFunc.closeLoading(), FF.logger.debug("processCount", FF.Debug.processCount)
            })).fail(function(t) {
                if (!FF.env.isNative()) throw t;
                e._revealErrorMessage(), window.onErrorFunc(t, i)
            }), this.defineOnAppForeground(), h.ExternalUserAuth.checkExternalUserAuthCallDeferred()
        },
        defineOnAppForeground: function() {
            if (!FF.env.isNative()) return;
            kickmotor.nativefn.onApplicationForeground = function() {
                FF.env.checkMobageLoginDeferred().then(function(e) {
                    e && h.ExternalUserAuth.checkExternalUserAuthCallDeferred()
                })
            }
        },
        _revealErrorMessage: function() {
            var n = this,
                r = [];
            n.battleLayers.push("layer_battle_result"), n.battleLayers.push("layer_soul_strike_lvup"), e(n.battleLayers).each(function(e) {
                r.push({
                    exec: "destroyLayer",
                    layer: e
                })
            }), kickmotor.animation.processAnimation(r), t(".overlay").removeClass("hide")
        },
        _setupErrorHandler: function() {
            var e = this._errorHandler;
            t(window).off("error"), t(window).on("error", e.bind(this))
        },
        _errorHandler: function(e) {
            var n = e.originalEvent;
            t(window).off("error"), this._revealErrorMessage(), window.onErrorFunc(n, "4148");
            var r = {
                filename: n.filename,
                lineno: n.lineno || 0,
                colno: n.colno || 0,
                message: n.message || "",
                error: n.error || ""
            };
            c.errorDeferred(JSON.stringify(r))
        },
        dispose: function() {
            u.prototype.dispose.apply(this)
        }
    })
}), define("routers/Battle", ["underscore", "backbone", "scenes/battle/BattleScene", "scenes/battle_result/BattleResultScene"], function(e, t, n, r) {
    return t.Router.extend({
        initialize: function() {
            this.currentScene = void 0, this._setupOnBackKey()
        },
        routes: {
            "": "createBattleScene",
            "battle_result(/)(:url)": "createBattleResultScene"
        },
        createBattleScene: function() {
            this.disposeCurrentScene(), FF.scene = this.currentScene = new n, FF.scene.setupDeferred().then(function() {
                FF.scene.start()
            })
        },
        createBattleResultScene: function() {
            var e = this;
            this.disposeCurrentScene(), this.currentScene = new r, this.currentScene.setupDeferred().then(function() {
                e.currentScene.start()
            })
        },
        disposeCurrentScene: function() {
            this.currentScene && (this.currentScene.dispose(), this.currentScene = null)
        },
        getCurrentScene: function() {
            return this.currentScene
        },
        _setupOnBackKey: function() {
            FF.env.isUsingWWBackKeyHandler() && (kickmotor.nativefn.onBackKeyHandler = e.extend({
                hasModal: !1
            }, t.Events), kickmotor.nativefn.onBackKey = function() {
                kickmotor.nativefn.onBackKeyHandler.trigger("System::onBackKey")
            })
        }
    })
}), require(["jquery", "underscore", "backbone", "kickmotor", "lib/SoundMgr", "logger", "env", "scenes/battle/Conf"], function(e, t, n, r, i) {
    require(["routers/Battle"], function(t) {
        e(function() {
            var n = e("input#debug-battle-init-ep").val();
            n && (FF.Debug || (FF.Debug = {}), FF.Debug.battleInitEp = n), e.nativefn = r.nativefn, r.animation.setAnimationInterval(1 / FF.env.framesPerSecond), r.view.showGameView(), FF.SoundMgr = new i, FF.router = new t, FF.onload()
        })
    })
}), define("battle", function() {});